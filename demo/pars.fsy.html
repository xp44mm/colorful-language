<html><head>
   <meta charset="utf-8">
   <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
   <title>pars.fsy</title>
<link rel="icon" href="favicon.ico"><script defer="" src="main.b525d5efa1abe7ea853e.js"></script><style>.table-danger,
.table-danger > th,
.table-danger > td {
    background-color: #f5c6cb;
}

.table-warning,
.table-warning > th,
.table-warning > td {
    background-color: #ffeeba;
}

.table-success,
.table-success > th,
.table-success > td {
    background-color: #c3e6cb;
}

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL2Nzcy9iYWNrZ3JvdW5kLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0lBR0kseUJBQXlCO0FBQzdCOztBQUVBOzs7SUFHSSx5QkFBeUI7QUFDN0I7O0FBRUE7OztJQUdJLHlCQUF5QjtBQUM3QiIsInNvdXJjZXNDb250ZW50IjpbIi50YWJsZS1kYW5nZXIsXHJcbi50YWJsZS1kYW5nZXIgPiB0aCxcclxuLnRhYmxlLWRhbmdlciA+IHRkIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmNWM2Y2I7XHJcbn1cclxuXHJcbi50YWJsZS13YXJuaW5nLFxyXG4udGFibGUtd2FybmluZyA+IHRoLFxyXG4udGFibGUtd2FybmluZyA+IHRkIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmVlYmE7XHJcbn1cclxuXHJcbi50YWJsZS1zdWNjZXNzLFxyXG4udGFibGUtc3VjY2VzcyA+IHRoLFxyXG4udGFibGUtc3VjY2VzcyA+IHRkIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNjM2U2Y2I7XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ== */</style><style>
.btn {
    display: inline-block;
    font-weight: 400;
    line-height: 1.5;
    color: #212529;
    text-align: center;
    vertical-align: middle;
    cursor: pointer;
    user-select: none;
    background-color: transparent;
    border: 1px solid transparent;
    padding: 0.375rem 0.75rem;
    border-radius: 0.25rem;
    transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

.btn:hover {
    color: #212529;
    text-decoration: none;
}

.btn:focus, .btn.focus {
    outline: 0;
    box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
}

.btn.disabled, .btn:disabled {
    opacity: 0.65;
}

a.btn.disabled,
fieldset:disabled a.btn {
    pointer-events: none;
}

.btn-link {
    font-weight: 400;
    color: #0d6efd;
    text-decoration: none;
}

    .btn-link:hover {
        color: #024dbc;
        text-decoration: underline;
    }

    .btn-link:focus, .btn-link.focus {
        text-decoration: underline;
        box-shadow: none;
    }

    .btn-link:disabled, .btn-link.disabled {
        color: #6c757d;
        pointer-events: none;
    }

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL2Nzcy9idXR0b25zLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7SUFDSSxxQkFBcUI7SUFDckIsZ0JBQWdCO0lBQ2hCLGdCQUFnQjtJQUNoQixjQUFjO0lBQ2Qsa0JBQWtCO0lBQ2xCLHNCQUFzQjtJQUN0QixlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLDZCQUE2QjtJQUM3Qiw2QkFBNkI7SUFDN0IseUJBQXlCO0lBQ3pCLHNCQUFzQjtJQUN0QixxSUFBcUk7QUFDekk7O0FBRUE7SUFDSSxjQUFjO0lBQ2QscUJBQXFCO0FBQ3pCOztBQUVBO0lBQ0ksVUFBVTtJQUNWLGlEQUFpRDtBQUNyRDs7QUFFQTtJQUNJLGFBQWE7QUFDakI7O0FBRUE7O0lBRUksb0JBQW9CO0FBQ3hCOztBQUVBO0lBQ0ksZ0JBQWdCO0lBQ2hCLGNBQWM7SUFDZCxxQkFBcUI7QUFDekI7O0lBRUk7UUFDSSxjQUFjO1FBQ2QsMEJBQTBCO0lBQzlCOztJQUVBO1FBQ0ksMEJBQTBCO1FBQzFCLGdCQUFnQjtJQUNwQjs7SUFFQTtRQUNJLGNBQWM7UUFDZCxvQkFBb0I7SUFDeEIiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLmJ0biB7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICBmb250LXdlaWdodDogNDAwO1xyXG4gICAgbGluZS1oZWlnaHQ6IDEuNTtcclxuICAgIGNvbG9yOiAjMjEyNTI5O1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIHVzZXItc2VsZWN0OiBub25lO1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcclxuICAgIHBhZGRpbmc6IDAuMzc1cmVtIDAuNzVyZW07XHJcbiAgICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xyXG4gICAgdHJhbnNpdGlvbjogY29sb3IgMC4xNXMgZWFzZS1pbi1vdXQsIGJhY2tncm91bmQtY29sb3IgMC4xNXMgZWFzZS1pbi1vdXQsIGJvcmRlci1jb2xvciAwLjE1cyBlYXNlLWluLW91dCwgYm94LXNoYWRvdyAwLjE1cyBlYXNlLWluLW91dDtcclxufVxyXG5cclxuLmJ0bjpob3ZlciB7XHJcbiAgICBjb2xvcjogIzIxMjUyOTtcclxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcclxufVxyXG5cclxuLmJ0bjpmb2N1cywgLmJ0bi5mb2N1cyB7XHJcbiAgICBvdXRsaW5lOiAwO1xyXG4gICAgYm94LXNoYWRvdzogMCAwIDAgMC4ycmVtIHJnYmEoMTMsIDExMCwgMjUzLCAwLjI1KTtcclxufVxyXG5cclxuLmJ0bi5kaXNhYmxlZCwgLmJ0bjpkaXNhYmxlZCB7XHJcbiAgICBvcGFjaXR5OiAwLjY1O1xyXG59XHJcblxyXG5hLmJ0bi5kaXNhYmxlZCxcclxuZmllbGRzZXQ6ZGlzYWJsZWQgYS5idG4ge1xyXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbn1cclxuXHJcbi5idG4tbGluayB7XHJcbiAgICBmb250LXdlaWdodDogNDAwO1xyXG4gICAgY29sb3I6ICMwZDZlZmQ7XHJcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbn1cclxuXHJcbiAgICAuYnRuLWxpbms6aG92ZXIge1xyXG4gICAgICAgIGNvbG9yOiAjMDI0ZGJjO1xyXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xyXG4gICAgfVxyXG5cclxuICAgIC5idG4tbGluazpmb2N1cywgLmJ0bi1saW5rLmZvY3VzIHtcclxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcclxuICAgICAgICBib3gtc2hhZG93OiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC5idG4tbGluazpkaXNhYmxlZCwgLmJ0bi1saW5rLmRpc2FibGVkIHtcclxuICAgICAgICBjb2xvcjogIzZjNzU3ZDtcclxuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgIH1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ== */</style><style>/* custom.css */
button,
input,
select,
textarea {
    font-family: inherit;
}

textarea {
    display: block;
    width: 100%;
    height: auto;
    resize: vertical;
}

body {
    margin: 8px;
}

.text-left {
    text-align: left;
}

.text-right {
    text-align: right;
}

.text-center {
    text-align: center;
}

.hidden, [hidden] {
    display: none;
}

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL2Nzcy9jdXN0b20uY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGVBQWU7QUFDZjs7OztJQUlJLG9CQUFvQjtBQUN4Qjs7QUFFQTtJQUNJLGNBQWM7SUFDZCxXQUFXO0lBQ1gsWUFBWTtJQUNaLGdCQUFnQjtBQUNwQjs7QUFFQTtJQUNJLFdBQVc7QUFDZjs7QUFFQTtJQUNJLGdCQUFnQjtBQUNwQjs7QUFFQTtJQUNJLGlCQUFpQjtBQUNyQjs7QUFFQTtJQUNJLGtCQUFrQjtBQUN0Qjs7QUFFQTtJQUNJLGFBQWE7QUFDakIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBjdXN0b20uY3NzICovXHJcbmJ1dHRvbixcclxuaW5wdXQsXHJcbnNlbGVjdCxcclxudGV4dGFyZWEge1xyXG4gICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XHJcbn1cclxuXHJcbnRleHRhcmVhIHtcclxuICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IGF1dG87XHJcbiAgICByZXNpemU6IHZlcnRpY2FsO1xyXG59XHJcblxyXG5ib2R5IHtcclxuICAgIG1hcmdpbjogOHB4O1xyXG59XHJcblxyXG4udGV4dC1sZWZ0IHtcclxuICAgIHRleHQtYWxpZ246IGxlZnQ7XHJcbn1cclxuXHJcbi50ZXh0LXJpZ2h0IHtcclxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xyXG59XHJcblxyXG4udGV4dC1jZW50ZXIge1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG59XHJcblxyXG4uaGlkZGVuLCBbaGlkZGVuXSB7XHJcbiAgICBkaXNwbGF5OiBub25lO1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0= */</style><style>
.nav {
    display: flex;
    flex-wrap: wrap;
    padding-left: 0;
    margin-bottom: 0;
    list-style: none;
}

.nav-link {
    display: block;
    padding: 0.5rem 1rem;
}

    .nav-link:hover, .nav-link:focus {
        text-decoration: none;
    }

    .nav-link.disabled {
        color: #6c757d;
        pointer-events: none;
        cursor: default;
    }

.nav-tabs {
    border-bottom: 1px solid teal;
}

    .nav-tabs .nav-item {
        margin-bottom: -1px;
    }

    .nav-tabs .nav-link {
        border: 1px solid transparent;
        border-radius: 0;
        border-top-left-radius: 0.25rem;
        border-top-right-radius: 0.25rem;

    }

        .nav-tabs .nav-link:hover, 
        .nav-tabs .nav-link:focus {
            border-color: #e9ecef #e9ecef teal;
        }

        .nav-tabs .nav-link.disabled {
            color: #6c757d;
            background-color: transparent;
            border-color: transparent;
        }

        .nav-tabs .nav-link.active,
        .nav-tabs .nav-item.show .nav-link {
            color: #495057;
            background-color: #fff;
            border-color: teal teal #fff;
        }

    .nav-tabs .dropdown-menu {
        margin-top: -1px;
        border-top-left-radius: 0;
        border-top-right-radius: 0;

    }

.nav-pills .nav-link {
    border-radius: 0.25rem;
}

    .nav-pills .nav-link.active,
    .nav-pills .show > .nav-link {
        color: #fff;
        background-color: #0d6efd;
    }

.nav-fill .nav-item {
    flex: 1 1 auto;
    text-align: center;
}

.nav-justified .nav-item {
    flex-basis: 0;
    flex-grow: 1;
    text-align: center;
}

.tab-content > .tab-pane {
    display: none;
}

.tab-content > .active {
    display: block;
}

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL2Nzcy9uYXYuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtJQUNJLGFBQWE7SUFDYixlQUFlO0lBQ2YsZUFBZTtJQUNmLGdCQUFnQjtJQUNoQixnQkFBZ0I7QUFDcEI7O0FBRUE7SUFDSSxjQUFjO0lBQ2Qsb0JBQW9CO0FBQ3hCOztJQUVJO1FBQ0kscUJBQXFCO0lBQ3pCOztJQUVBO1FBQ0ksY0FBYztRQUNkLG9CQUFvQjtRQUNwQixlQUFlO0lBQ25COztBQUVKO0lBQ0ksNkJBQTZCO0FBQ2pDOztJQUVJO1FBQ0ksbUJBQW1CO0lBQ3ZCOztJQUVBO1FBQ0ksNkJBQTZCO1FBQzdCLGdCQUFnQjtRQUNoQiwrQkFBK0I7UUFDL0IsZ0NBQWdDOztJQUVwQzs7UUFFSTs7WUFFSSxrQ0FBa0M7UUFDdEM7O1FBRUE7WUFDSSxjQUFjO1lBQ2QsNkJBQTZCO1lBQzdCLHlCQUF5QjtRQUM3Qjs7UUFFQTs7WUFFSSxjQUFjO1lBQ2Qsc0JBQXNCO1lBQ3RCLDRCQUE0QjtRQUNoQzs7SUFFSjtRQUNJLGdCQUFnQjtRQUNoQix5QkFBeUI7UUFDekIsMEJBQTBCOztJQUU5Qjs7QUFFSjtJQUNJLHNCQUFzQjtBQUMxQjs7SUFFSTs7UUFFSSxXQUFXO1FBQ1gseUJBQXlCO0lBQzdCOztBQUVKO0lBQ0ksY0FBYztJQUNkLGtCQUFrQjtBQUN0Qjs7QUFFQTtJQUNJLGFBQWE7SUFDYixZQUFZO0lBQ1osa0JBQWtCO0FBQ3RCOztBQUVBO0lBQ0ksYUFBYTtBQUNqQjs7QUFFQTtJQUNJLGNBQWM7QUFDbEIiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLm5hdiB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC13cmFwOiB3cmFwO1xyXG4gICAgcGFkZGluZy1sZWZ0OiAwO1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcclxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XHJcbn1cclxuXHJcbi5uYXYtbGluayB7XHJcbiAgICBkaXNwbGF5OiBibG9jaztcclxuICAgIHBhZGRpbmc6IDAuNXJlbSAxcmVtO1xyXG59XHJcblxyXG4gICAgLm5hdi1saW5rOmhvdmVyLCAubmF2LWxpbms6Zm9jdXMge1xyXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcclxuICAgIH1cclxuXHJcbiAgICAubmF2LWxpbmsuZGlzYWJsZWQge1xyXG4gICAgICAgIGNvbG9yOiAjNmM3NTdkO1xyXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICAgIGN1cnNvcjogZGVmYXVsdDtcclxuICAgIH1cclxuXHJcbi5uYXYtdGFicyB7XHJcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgdGVhbDtcclxufVxyXG5cclxuICAgIC5uYXYtdGFicyAubmF2LWl0ZW0ge1xyXG4gICAgICAgIG1hcmdpbi1ib3R0b206IC0xcHg7XHJcbiAgICB9XHJcblxyXG4gICAgLm5hdi10YWJzIC5uYXYtbGluayB7XHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcclxuICAgICAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwLjI1cmVtO1xyXG4gICAgICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwLjI1cmVtO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAgICAgLm5hdi10YWJzIC5uYXYtbGluazpob3ZlciwgXHJcbiAgICAgICAgLm5hdi10YWJzIC5uYXYtbGluazpmb2N1cyB7XHJcbiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogI2U5ZWNlZiAjZTllY2VmIHRlYWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAubmF2LXRhYnMgLm5hdi1saW5rLmRpc2FibGVkIHtcclxuICAgICAgICAgICAgY29sb3I6ICM2Yzc1N2Q7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xyXG4gICAgICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLm5hdi10YWJzIC5uYXYtbGluay5hY3RpdmUsXHJcbiAgICAgICAgLm5hdi10YWJzIC5uYXYtaXRlbS5zaG93IC5uYXYtbGluayB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAjNDk1MDU3O1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xyXG4gICAgICAgICAgICBib3JkZXItY29sb3I6IHRlYWwgdGVhbCAjZmZmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAubmF2LXRhYnMgLmRyb3Bkb3duLW1lbnUge1xyXG4gICAgICAgIG1hcmdpbi10b3A6IC0xcHg7XHJcbiAgICAgICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcclxuICAgICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcclxuXHJcbiAgICB9XHJcblxyXG4ubmF2LXBpbGxzIC5uYXYtbGluayB7XHJcbiAgICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xyXG59XHJcblxyXG4gICAgLm5hdi1waWxscyAubmF2LWxpbmsuYWN0aXZlLFxyXG4gICAgLm5hdi1waWxscyAuc2hvdyA+IC5uYXYtbGluayB7XHJcbiAgICAgICAgY29sb3I6ICNmZmY7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzBkNmVmZDtcclxuICAgIH1cclxuXHJcbi5uYXYtZmlsbCAubmF2LWl0ZW0ge1xyXG4gICAgZmxleDogMSAxIGF1dG87XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbn1cclxuXHJcbi5uYXYtanVzdGlmaWVkIC5uYXYtaXRlbSB7XHJcbiAgICBmbGV4LWJhc2lzOiAwO1xyXG4gICAgZmxleC1ncm93OiAxO1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG59XHJcblxyXG4udGFiLWNvbnRlbnQgPiAudGFiLXBhbmUge1xyXG4gICAgZGlzcGxheTogbm9uZTtcclxufVxyXG5cclxuLnRhYi1jb250ZW50ID4gLmFjdGl2ZSB7XHJcbiAgICBkaXNwbGF5OiBibG9jaztcclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9 */</style><style>html {
    font-size: 14px;
    line-height: 1.25;
}

body {
    font-size: 1rem;
}

h1 {
    font-size: 2.4rem;
}

h2 {
    font-size: 2rem;
}

h3 {
    font-size: 1.6rem;
}

h4 {
    font-size: 1.4rem;
}

h5 {
    font-size: 1.2rem;
}

h6 {
    font-size: 1.1rem;
}

small {
    font-size: 80%;
}

sub, sup {
    font-size: 75%;
}

pre,
code,
kbd,
samp {
    font-size: 1em;
}

input,
button,
select,
optgroup,
textarea {
    font-size: 1rem;
}

legend {
    font-size: 1.5rem;
}

.full-width {
    width: calc(100% - 8px);
}

.inline-full-width {
    display:inline-block;
    width: calc(100% - 8px);
}
/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL2Nzcy9zaXppbmcuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksZUFBZTtJQUNmLGlCQUFpQjtBQUNyQjs7QUFFQTtJQUNJLGVBQWU7QUFDbkI7O0FBRUE7SUFDSSxpQkFBaUI7QUFDckI7O0FBRUE7SUFDSSxlQUFlO0FBQ25COztBQUVBO0lBQ0ksaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksY0FBYztBQUNsQjs7QUFFQTtJQUNJLGNBQWM7QUFDbEI7O0FBRUE7Ozs7SUFJSSxjQUFjO0FBQ2xCOztBQUVBOzs7OztJQUtJLGVBQWU7QUFDbkI7O0FBRUE7SUFDSSxpQkFBaUI7QUFDckI7O0FBRUE7SUFDSSx1QkFBdUI7QUFDM0I7O0FBRUE7SUFDSSxvQkFBb0I7SUFDcEIsdUJBQXVCO0FBQzNCIiwic291cmNlc0NvbnRlbnQiOlsiaHRtbCB7XHJcbiAgICBmb250LXNpemU6IDE0cHg7XHJcbiAgICBsaW5lLWhlaWdodDogMS4yNTtcclxufVxyXG5cclxuYm9keSB7XHJcbiAgICBmb250LXNpemU6IDFyZW07XHJcbn1cclxuXHJcbmgxIHtcclxuICAgIGZvbnQtc2l6ZTogMi40cmVtO1xyXG59XHJcblxyXG5oMiB7XHJcbiAgICBmb250LXNpemU6IDJyZW07XHJcbn1cclxuXHJcbmgzIHtcclxuICAgIGZvbnQtc2l6ZTogMS42cmVtO1xyXG59XHJcblxyXG5oNCB7XHJcbiAgICBmb250LXNpemU6IDEuNHJlbTtcclxufVxyXG5cclxuaDUge1xyXG4gICAgZm9udC1zaXplOiAxLjJyZW07XHJcbn1cclxuXHJcbmg2IHtcclxuICAgIGZvbnQtc2l6ZTogMS4xcmVtO1xyXG59XHJcblxyXG5zbWFsbCB7XHJcbiAgICBmb250LXNpemU6IDgwJTtcclxufVxyXG5cclxuc3ViLCBzdXAge1xyXG4gICAgZm9udC1zaXplOiA3NSU7XHJcbn1cclxuXHJcbnByZSxcclxuY29kZSxcclxua2JkLFxyXG5zYW1wIHtcclxuICAgIGZvbnQtc2l6ZTogMWVtO1xyXG59XHJcblxyXG5pbnB1dCxcclxuYnV0dG9uLFxyXG5zZWxlY3QsXHJcbm9wdGdyb3VwLFxyXG50ZXh0YXJlYSB7XHJcbiAgICBmb250LXNpemU6IDFyZW07XHJcbn1cclxuXHJcbmxlZ2VuZCB7XHJcbiAgICBmb250LXNpemU6IDEuNXJlbTtcclxufVxyXG5cclxuLmZ1bGwtd2lkdGgge1xyXG4gICAgd2lkdGg6IGNhbGMoMTAwJSAtIDhweCk7XHJcbn1cclxuXHJcbi5pbmxpbmUtZnVsbC13aWR0aCB7XHJcbiAgICBkaXNwbGF5OmlubGluZS1ibG9jaztcclxuICAgIHdpZHRoOiBjYWxjKDEwMCUgLSA4cHgpO1xyXG59Il0sInNvdXJjZVJvb3QiOiIifQ== */</style><style>table {
    table-layout: fixed;
    width: 100%;
    white-space: nowrap;
    border-collapse: collapse;
}

td {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: clip;
}

/*
th {
    background: darkblue;
    color: white;
}
*/

td, th {
    text-align: left;
    padding: 2px 4px;
    border: solid 1px;
}

tr:hover {
    /*color: #212529;*/
    background-color: rgba(0, 0, 0, 0.075);
}


/*

thead th:nth-child(2) {
    width: 40%;
}

tr:nth-child(even) {
    background: lightblue;
}

*/

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL2Nzcy90YWJsZS5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7SUFDSSxtQkFBbUI7SUFDbkIsV0FBVztJQUNYLG1CQUFtQjtJQUNuQix5QkFBeUI7QUFDN0I7O0FBRUE7SUFDSSxtQkFBbUI7SUFDbkIsZ0JBQWdCO0lBQ2hCLG1CQUFtQjtBQUN2Qjs7QUFFQTs7Ozs7Q0FLQzs7QUFFRDtJQUNJLGdCQUFnQjtJQUNoQixnQkFBZ0I7SUFDaEIsaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksa0JBQWtCO0lBQ2xCLHNDQUFzQztBQUMxQzs7O0FBR0E7Ozs7Ozs7Ozs7Q0FVQyIsInNvdXJjZXNDb250ZW50IjpbInRhYmxlIHtcclxuICAgIHRhYmxlLWxheW91dDogZml4ZWQ7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XHJcbiAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xyXG59XHJcblxyXG50ZCB7XHJcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgIHRleHQtb3ZlcmZsb3c6IGNsaXA7XHJcbn1cclxuXHJcbi8qXHJcbnRoIHtcclxuICAgIGJhY2tncm91bmQ6IGRhcmtibHVlO1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG59XHJcbiovXHJcblxyXG50ZCwgdGgge1xyXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcclxuICAgIHBhZGRpbmc6IDJweCA0cHg7XHJcbiAgICBib3JkZXI6IHNvbGlkIDFweDtcclxufVxyXG5cclxudHI6aG92ZXIge1xyXG4gICAgLypjb2xvcjogIzIxMjUyOTsqL1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjA3NSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG5cclxudGhlYWQgdGg6bnRoLWNoaWxkKDIpIHtcclxuICAgIHdpZHRoOiA0MCU7XHJcbn1cclxuXHJcbnRyOm50aC1jaGlsZChldmVuKSB7XHJcbiAgICBiYWNrZ3JvdW5kOiBsaWdodGJsdWU7XHJcbn1cclxuXHJcbiovXHJcbiJdLCJzb3VyY2VSb290IjoiIn0= */</style><style>

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ== */</style><style>.Red300 {
  color: #E57373;
}
.Pink300 {
  color: #F06292;
}
.Purple300 {
  color: #BA68C8;
}
.DeepPurple300 {
  color: #9575CD;
}
.Indigo300 {
  color: #7986CB;
}
.Blue300 {
  color: #64B5F6;
}
.LightBlue300 {
  color: #4FC3F7;
}
.Cyan300 {
  color: #4DD0E1;
}
.Teal300 {
  color: #4DB6AC;
}
.Green300 {
  color: #81C784;
}
.LightGreen300 {
  color: #AED581;
}
.Lime300 {
  color: #DCE775;
}
.Yellow300 {
  color: #FFF176;
}
.Amber300 {
  color: #FFD54F;
}
.Orange300 {
  color: #FFB74D;
}
.DeepOrange300 {
  color: #FF8A65;
}
.Brown300 {
  color: #A1887F;
}
.Gray300 {
  color: #E0E0E0;
}
.keyword {
  color: #64B5F6;
}
.comment {
  color: #A1887F;
}
.string,
.char {
  color: #FF8A65;
}
.punctuation {
  color: #F06292;
}
.identifier {
  color: #DCE775;
}
pre {
  background-color: black;
  color: white;
}

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL2Nzcy9jb2xvcnMvMzAwLmxlc3MiLCJ3ZWJwYWNrOi8vLi9jc3MvY29sb3JzL3ByZS5sZXNzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQWlCLGNBQUE7QUNFakI7QUREQTtFQUFpQixjQUFBO0FDSWpCO0FESEE7RUFBaUIsY0FBQTtBQ01qQjtBRExBO0VBQWlCLGNBQUE7QUNRakI7QURQQTtFQUFpQixjQUFBO0FDVWpCO0FEVEE7RUFBaUIsY0FBQTtBQ1lqQjtBRFZBO0VBQWlCLGNBQUE7QUNhakI7QURaQTtFQUFpQixjQUFBO0FDZWpCO0FEZEE7RUFBaUIsY0FBQTtBQ2lCakI7QURoQkE7RUFBaUIsY0FBQTtBQ21CakI7QURsQkE7RUFBaUIsY0FBQTtBQ3FCakI7QURwQkE7RUFBaUIsY0FBQTtBQ3VCakI7QURyQkE7RUFBaUIsY0FBQTtBQ3dCakI7QUR2QkE7RUFBaUIsY0FBQTtBQzBCakI7QUR6QkE7RUFBaUIsY0FBQTtBQzRCakI7QUQzQkE7RUFBaUIsY0FBQTtBQzhCakI7QUQ3QkE7RUFBaUIsY0FBQTtBQ2dDakI7QUQvQkE7RUFBaUIsY0FBQTtBQ2tDakI7QUFuREE7RURHaUIsY0FBQTtBQ21EakI7QUFsREE7RURZaUIsY0FBQTtBQ3lDakI7QUFqREE7O0VET2lCLGNBQUE7QUM4Q2pCO0FBakRBO0VEYmlCLGNBQUE7QUNpRWpCO0FBaERBO0VETmlCLGNBQUE7QUN5RGpCO0FBL0NBO0VBQ0ksdUJBQUE7RUFDQSxZQUFBO0FBaURKIiwic291cmNlc0NvbnRlbnQiOlsiLlJlZDMwMCAgICAgICAgeyBjb2xvcjogI0U1NzM3MyB9XG4uUGluazMwMCAgICAgICB7IGNvbG9yOiAjRjA2MjkyIH1cbi5QdXJwbGUzMDAgICAgIHsgY29sb3I6ICNCQTY4QzggfVxuLkRlZXBQdXJwbGUzMDAgeyBjb2xvcjogIzk1NzVDRCB9XG4uSW5kaWdvMzAwICAgICB7IGNvbG9yOiAjNzk4NkNCIH1cbi5CbHVlMzAwICAgICAgIHsgY29sb3I6ICM2NEI1RjYgfVxuXG4uTGlnaHRCbHVlMzAwICB7IGNvbG9yOiAjNEZDM0Y3IH1cbi5DeWFuMzAwICAgICAgIHsgY29sb3I6ICM0REQwRTEgfVxuLlRlYWwzMDAgICAgICAgeyBjb2xvcjogIzREQjZBQyB9XG4uR3JlZW4zMDAgICAgICB7IGNvbG9yOiAjODFDNzg0IH1cbi5MaWdodEdyZWVuMzAwIHsgY29sb3I6ICNBRUQ1ODEgfVxuLkxpbWUzMDAgICAgICAgeyBjb2xvcjogI0RDRTc3NSB9XG5cbi5ZZWxsb3czMDAgICAgIHsgY29sb3I6ICNGRkYxNzYgfVxuLkFtYmVyMzAwICAgICAgeyBjb2xvcjogI0ZGRDU0RiB9XG4uT3JhbmdlMzAwICAgICB7IGNvbG9yOiAjRkZCNzREIH1cbi5EZWVwT3JhbmdlMzAwIHsgY29sb3I6ICNGRjhBNjUgfVxuLkJyb3duMzAwICAgICAgeyBjb2xvcjogI0ExODg3RiB9XG4uR3JheTMwMCAgICAgICB7IGNvbG9yOiAjRTBFMEUwIH1cbiIsIkBpbXBvcnQgXCIuLzMwMC5sZXNzXCI7XG5cbi5rZXl3b3JkIHtcbiAgICAuQmx1ZTMwMCgpXG59XG5cbi5jb21tZW50IHtcbiAgICAuQnJvd24zMDAoKVxufVxuXG4uc3RyaW5nLCAuY2hhciB7XG4gICAgLkRlZXBPcmFuZ2UzMDAoKVxufVxuXG4ucHVuY3R1YXRpb24ge1xuICAgIC5QaW5rMzAwKClcbn1cblxuLmlkZW50aWZpZXIge1xuICAgIC5MaW1lMzAwKClcbn1cblxucHJlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcbiAgICBjb2xvcjogd2hpdGU7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9 */</style></head>
<body>
<pre><code class="comment">// Copyright (c) Microsoft Corporation.  All Rights Reserved.  See License.txt in the project root for license information.</code>

%{

<code class="keyword">#nowarn</code> <code class="string">"1182"</code>  <code class="comment">// generated code has lots of unused "parseState"</code>

<code class="keyword">open</code> <code class="identifier">System</code>

<code class="keyword">open</code> <code class="identifier">Internal</code>.<code class="identifier">Utilities</code>
<code class="keyword">open</code> <code class="identifier">Internal</code>.<code class="identifier">Utilities</code>.<code class="identifier">Text</code>.<code class="identifier">Parsing</code>

<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">AbstractIL</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">AbstractIL</code>
<code class="keyword">open</code> <code class="identifier">Internal</code>.<code class="identifier">Utilities</code>.<code class="identifier">Library</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">ErrorLogger</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">Features</code>
<code class="keyword">open</code> <code class="identifier">Internal</code>.<code class="identifier">Utilities</code>.<code class="identifier">Library</code>.<code class="identifier">Extras</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">ParseHelpers</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">Syntax</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">Syntax</code>.<code class="identifier">PrettyNaming</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">SyntaxTreeOps</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">SyntaxTreeOps</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">Text</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">Text</code>.<code class="identifier">Position</code>
<code class="keyword">open</code> <code class="identifier">FSharp</code>.<code class="identifier">Compiler</code>.<code class="identifier">Text</code>.<code class="identifier">Range</code>

<code class="keyword">#if</code> <code class="identifier">DEBUG</code>
<code class="keyword">let</code> <code class="identifier">debugPrint</code> <code class="identifier">s</code> =
    <code class="keyword">if</code> <code class="identifier">Internal</code>.<code class="identifier">Utilities</code>.<code class="identifier">Text</code>.<code class="identifier">Parsing</code>.<code class="identifier">Flags</code>.<code class="identifier">debug</code> <code class="keyword">then</code> 
        <code class="identifier">printfn</code> <code class="string">"\n%s"</code> <code class="identifier">s</code>
<code class="keyword">#else</code>
<code class="keyword">let</code> <code class="identifier">debugPrint</code> <code class="identifier">s</code> = <code class="identifier">ignore</code> <code class="identifier">s</code>
<code class="keyword">#endif</code>

<code class="keyword">let</code> <code class="identifier">exprFromParseError</code> (<code class="identifier">e</code>:<code class="identifier">SynExpr</code>) = <code class="identifier">SynExpr</code>.<code class="identifier">FromParseError</code> (<code class="identifier">e</code>, <code class="identifier">e</code>.<code class="identifier">Range</code>)

<code class="keyword">let</code> <code class="identifier">patFromParseError</code> (<code class="identifier">e</code>:<code class="identifier">SynPat</code>) = <code class="identifier">SynPat</code>.<code class="identifier">FromParseError</code>(<code class="identifier">e</code>, <code class="identifier">e</code>.<code class="identifier">Range</code>)

<code class="keyword">let</code> <code class="identifier">mkSynOptionalExpr</code> (<code class="identifier">m</code>: <code class="identifier">range</code>) <code class="identifier">xopt</code> = 
    <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">m</code>.<code class="identifier">MakeSynthetic</code>()
    <code class="keyword">match</code> <code class="identifier">xopt</code> <code class="keyword">with</code> 
    | <code class="identifier">None</code> -&gt; <code class="identifier">mkSynLidGet</code> <code class="identifier">m</code> <code class="identifier">FSharpLib</code>.<code class="identifier">CorePath</code> <code class="string">"None"</code>
    | <code class="identifier">Some</code> <code class="identifier">x</code>  -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">ExprAtomicFlag</code>.<code class="identifier">NonAtomic</code>, <code class="keyword">false</code>, <code class="identifier">mkSynLidGet</code> <code class="identifier">m</code> <code class="identifier">FSharpLib</code>.<code class="identifier">CorePath</code> <code class="string">"Some"</code>, <code class="identifier">x</code>, <code class="identifier">m</code>)

<code class="comment">// record bindings returned by the recdExprBindings rule has shape:</code>
<code class="comment">// (binding, separator-before-this-binding)</code>
<code class="comment">// this function converts arguments from form</code>
<code class="comment">// binding1 (binding2*sep1, binding3*sep2...) sepN</code>
<code class="comment">// to form</code>
<code class="comment">// binding1*sep1, binding2*sep2</code>
<code class="keyword">let</code> <code class="identifier">rebindRanges</code> <code class="identifier">first</code> <code class="identifier">fields</code> <code class="identifier">lastSep</code> = 
    <code class="keyword">let</code> <code class="keyword">rec</code> <code class="identifier">run</code> (<code class="identifier">name</code>, <code class="identifier">value</code>) <code class="identifier">l</code> <code class="identifier">acc</code> = 
        <code class="keyword">match</code> <code class="identifier">l</code> <code class="keyword">with</code>
        | [] -&gt; <code class="identifier">List</code>.<code class="identifier">rev</code> ((<code class="identifier">name</code>, <code class="identifier">value</code>, <code class="identifier">lastSep</code>) :: <code class="identifier">acc</code>)
        | (<code class="identifier">f</code>, <code class="identifier">m</code>) :: <code class="identifier">xs</code> -&gt; <code class="identifier">run</code> <code class="identifier">f</code> <code class="identifier">xs</code> ((<code class="identifier">name</code>, <code class="identifier">value</code>, <code class="identifier">m</code>) :: <code class="identifier">acc</code>)
    <code class="identifier">run</code> <code class="identifier">first</code> <code class="identifier">fields</code> []

<code class="keyword">let</code> <code class="identifier">mkUnderscoreRecdField</code> <code class="identifier">m</code> = <code class="identifier">LongIdentWithDots</code>([<code class="identifier">ident</code>(<code class="string">"_"</code>, <code class="identifier">m</code>)], []), <code class="keyword">false</code>

<code class="keyword">let</code> <code class="identifier">mkRecdField</code> <code class="identifier">lidwd</code> = <code class="identifier">lidwd</code>, <code class="keyword">true</code>

<code class="keyword">let</code> <code class="identifier">mkSynDoBinding</code> (<code class="identifier">vis</code>, <code class="identifier">strict</code>, <code class="identifier">expr</code>, <code class="identifier">m</code>) = 
    <code class="keyword">match</code> <code class="identifier">vis</code> <code class="keyword">with</code>
    | <code class="identifier">Some</code> <code class="identifier">vis</code> -&gt; <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsDoCannotHaveVisibilityDeclarations</code> (<code class="identifier">vis</code>.<code class="identifier">ToString</code>()), <code class="identifier">m</code>))
    | <code class="identifier">None</code> -&gt; ()
    <code class="identifier">SynBinding</code>(<code class="identifier">None</code>,
             (<code class="keyword">if</code> <code class="identifier">strict</code> <code class="keyword">then</code> <code class="identifier">SynBindingKind</code>.<code class="identifier">Do</code> <code class="keyword">else</code> <code class="identifier">SynBindingKind</code>.<code class="identifier">StandaloneExpression</code>),
             <code class="keyword">false</code>, <code class="keyword">false</code>, [], <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>, <code class="identifier">SynInfo</code>.<code class="identifier">emptySynValData</code>,
             (<code class="keyword">if</code> <code class="identifier">strict</code> <code class="keyword">then</code> <code class="identifier">SynPat</code>.<code class="identifier">Const</code>(<code class="identifier">SynConst</code>.<code class="identifier">Unit</code>, <code class="identifier">m</code>) <code class="keyword">else</code> <code class="identifier">SynPat</code>.<code class="identifier">Wild</code> <code class="identifier">m</code>),
             <code class="identifier">None</code>, <code class="identifier">expr</code>, <code class="identifier">m</code>, <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtDo</code>)

<code class="keyword">let</code> <code class="identifier">mkSynDoDecl</code> (<code class="identifier">e</code>: <code class="identifier">SynExpr</code>) = 
    <code class="keyword">let</code> <code class="identifier">spExpr</code> = <code class="keyword">if</code> <code class="identifier">IsControlFlowExpression</code> <code class="identifier">e</code> <code class="keyword">then</code> <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtDo</code> <code class="keyword">else</code> <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code> <code class="identifier">e</code>.<code class="identifier">Range</code>
    <code class="identifier">SynModuleDecl</code>.<code class="identifier">DoExpr</code>(<code class="identifier">spExpr</code>, <code class="identifier">e</code>, <code class="identifier">e</code>.<code class="identifier">Range</code>)

<code class="keyword">let</code> <code class="identifier">addAttribs</code> <code class="identifier">attrs</code> <code class="identifier">p</code> =  <code class="identifier">SynPat</code>.<code class="identifier">Attrib</code>(<code class="identifier">p</code>, <code class="identifier">attrs</code>, <code class="identifier">p</code>.<code class="identifier">Range</code>)


<code class="comment">// This function is called by the generated parser code. Returning initiates error recovery </code>
<code class="comment">// It must be called precisely "parse_error_rich"</code>
<code class="keyword">let</code> <code class="identifier">parse_error_rich</code> = <code class="identifier">Some</code> (<code class="keyword">fun</code> (<code class="identifier">ctxt</code>: <code class="identifier">ParseErrorContext</code>&lt;<code class="identifier">_</code>&gt;) -&gt; 
    <code class="identifier">errorR</code>(<code class="identifier">SyntaxError</code>(<code class="identifier">box</code> <code class="identifier">ctxt</code>, <code class="identifier">ctxt</code>.<code class="identifier">ParseState</code>.<code class="identifier">LexBuffer</code>.<code class="identifier">LexemeRange</code>)))

<code class="keyword">let</code> <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> <code class="identifier">s</code> = <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">s</code>, <code class="identifier">m</code>))

<code class="keyword">let</code> <code class="identifier">unionRangeWithPos</code> (<code class="identifier">r</code>:<code class="identifier">range</code>) <code class="identifier">p</code> =
    <code class="keyword">let</code> <code class="identifier">r2</code> = <code class="identifier">mkRange</code> <code class="identifier">r</code>.<code class="identifier">FileName</code> <code class="identifier">p</code> <code class="identifier">p</code>
    <code class="identifier">unionRanges</code> <code class="identifier">r</code> <code class="identifier">r2</code>

<code class="keyword">let</code> <code class="identifier">raiseParseErrorAt</code> <code class="identifier">m</code> <code class="identifier">s</code> = 
    <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> <code class="identifier">s</code>; 
    <code class="comment">// This initiates error recovery</code>
    <code class="identifier">raise</code> <code class="identifier">RecoverableParseError</code> 

<code class="comment">/// Report a good error at the end of file, e.g. for non-terminated strings</code>
<code class="keyword">let</code> <code class="identifier">checkEndOfFileError</code> <code class="identifier">t</code> = 
  <code class="keyword">match</code> <code class="identifier">t</code> <code class="keyword">with</code> 
  | <code class="identifier">LexCont</code>.<code class="identifier">IfDefSkip</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">m</code>) -&gt;
      <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInHashIf</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">String</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">LexerStringStyle</code>.<code class="identifier">SingleQuote</code>, <code class="identifier">kind</code>, <code class="identifier">m</code>) -&gt; 
     <code class="keyword">if</code> <code class="identifier">kind</code>.<code class="identifier">IsInterpolated</code> <code class="keyword">then</code>
         <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInInterpolatedString</code>())
     <code class="keyword">else</code>
         <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInString</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">String</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">LexerStringStyle</code>.<code class="identifier">TripleQuote</code>, <code class="identifier">kind</code>, <code class="identifier">m</code>) -&gt;
     <code class="keyword">if</code> <code class="identifier">kind</code>.<code class="identifier">IsInterpolated</code> <code class="keyword">then</code>
         <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInInterpolatedTripleQuoteString</code>())
     <code class="keyword">else</code>
         <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInTripleQuoteString</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">String</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">LexerStringStyle</code>.<code class="identifier">Verbatim</code>, <code class="identifier">kind</code>, <code class="identifier">m</code>) -&gt;
     <code class="keyword">if</code> <code class="identifier">kind</code>.<code class="identifier">IsInterpolated</code> <code class="keyword">then</code>
         <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInInterpolatedVerbatimString</code>())
     <code class="keyword">else</code>
         <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInVerbatimString</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">Comment</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">m</code>) -&gt;
     <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInComment</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">SingleLineComment</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">m</code>) -&gt;
     <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInComment</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">StringInComment</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">LexerStringStyle</code>.<code class="identifier">SingleQuote</code>, <code class="identifier">_</code>, <code class="identifier">m</code>) -&gt;
     <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInStringInComment</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">StringInComment</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">LexerStringStyle</code>.<code class="identifier">Verbatim</code>, <code class="identifier">_</code>, <code class="identifier">m</code>) -&gt;
     <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInVerbatimStringInComment</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">StringInComment</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">LexerStringStyle</code>.<code class="identifier">TripleQuote</code>, <code class="identifier">_</code>, <code class="identifier">m</code>) -&gt;
     <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInTripleQuoteStringInComment</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">MLOnly</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">m</code>) -&gt;
     <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInIfOcaml</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">EndLine</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">LexerEndlineContinuation</code>.<code class="identifier">Skip</code>(<code class="identifier">_</code>, <code class="identifier">m</code>)) -&gt;
     <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInDirective</code>())

  | <code class="identifier">LexCont</code>.<code class="identifier">EndLine</code>(<code class="identifier">endifs</code>, <code class="identifier">nesting</code>, <code class="identifier">LexerEndlineContinuation</code>.<code class="identifier">Token</code>)
  | <code class="identifier">LexCont</code>.<code class="identifier">Token</code>(<code class="identifier">endifs</code>, <code class="identifier">nesting</code>) -&gt; 
      <code class="keyword">match</code> <code class="identifier">endifs</code> <code class="keyword">with</code> 
      | [] -&gt; ()
      | (<code class="identifier">_</code>, <code class="identifier">m</code>) :: <code class="identifier">_</code>  -&gt; <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsNoHashEndIfFound</code>())
      <code class="keyword">match</code> <code class="identifier">nesting</code> <code class="keyword">with</code> 
      | [] -&gt; ()
      | (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">m</code>) :: <code class="identifier">_</code>  -&gt; <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEofInInterpolatedStringFill</code>())

<code class="keyword">type</code> <code class="identifier">BindingSet</code> = <code class="identifier">BindingSetPreAttrs</code> <code class="keyword">of</code> <code class="identifier">range</code> * <code class="identifier">bool</code> * <code class="identifier">bool</code> * (<code class="identifier">SynAttributes</code> -&gt; <code class="identifier">SynAccess</code> <code class="identifier">option</code> -&gt; <code class="identifier">SynAttributes</code> * <code class="identifier">SynBinding</code> <code class="identifier">list</code>) * <code class="identifier">range</code>

<code class="keyword">let</code> <code class="identifier">mkClassMemberLocalBindings</code>(<code class="identifier">isStatic</code>, <code class="identifier">initialRangeOpt</code>, <code class="identifier">attrs</code>, <code class="identifier">vis</code>, <code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">_</code>, <code class="identifier">isRec</code>, <code class="identifier">isUse</code>, <code class="identifier">declsPreAttrs</code>, <code class="identifier">bindingSetRange</code>)) = 
   <code class="keyword">let</code> <code class="identifier">ignoredFreeAttrs</code>, <code class="identifier">decls</code> = <code class="identifier">declsPreAttrs</code> <code class="identifier">attrs</code> <code class="identifier">vis</code>
   <code class="keyword">let</code> <code class="identifier">wholeRange</code> = 
       <code class="keyword">match</code> <code class="identifier">initialRangeOpt</code> <code class="keyword">with</code> 
       | <code class="identifier">None</code> -&gt; <code class="identifier">bindingSetRange</code>
       | <code class="identifier">Some</code> <code class="identifier">m</code> -&gt; <code class="identifier">unionRanges</code> <code class="identifier">m</code> <code class="identifier">bindingSetRange</code>
   <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> <code class="identifier">ignoredFreeAttrs</code>) <code class="keyword">then</code> <code class="identifier">warning</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAttributesIgnored</code>(), <code class="identifier">wholeRange</code>));
   <code class="keyword">if</code> <code class="identifier">isUse</code> <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUseBindingsIllegalInImplicitClassConstructors</code>(), <code class="identifier">wholeRange</code>))
   <code class="identifier">SynMemberDefn</code>.<code class="identifier">LetBindings</code> (<code class="identifier">decls</code>, <code class="identifier">isStatic</code>, <code class="identifier">isRec</code>, <code class="identifier">wholeRange</code>)

<code class="keyword">let</code> <code class="identifier">mkLocalBindings</code> (<code class="identifier">mWhole</code>, <code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">_</code>, <code class="identifier">isRec</code>, <code class="identifier">isUse</code>, <code class="identifier">declsPreAttrs</code>, <code class="identifier">_</code>), <code class="identifier">body</code>) = 
   <code class="keyword">let</code> <code class="identifier">ignoredFreeAttrs</code>, <code class="identifier">decls</code> = <code class="identifier">declsPreAttrs</code> [] <code class="identifier">None</code> 
   <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> <code class="identifier">ignoredFreeAttrs</code>) <code class="keyword">then</code> <code class="identifier">warning</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAttributesIgnored</code>(), <code class="identifier">mWhole</code>))
   <code class="identifier">SynExpr</code>.<code class="identifier">LetOrUse</code> (<code class="identifier">isRec</code>, <code class="identifier">isUse</code>, <code class="identifier">decls</code>, <code class="identifier">body</code>, <code class="identifier">mWhole</code>) 

<code class="keyword">let</code> <code class="identifier">mkDefnBindings</code> (<code class="identifier">mWhole</code>, <code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">_</code>, <code class="identifier">isRec</code>, <code class="identifier">isUse</code>, <code class="identifier">declsPreAttrs</code>, <code class="identifier">_bindingSetRange</code>), <code class="identifier">attrs</code>, <code class="identifier">vis</code>, <code class="identifier">attrsm</code>) = 
    <code class="keyword">if</code> <code class="identifier">isUse</code> <code class="keyword">then</code> <code class="identifier">warning</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUseBindingsIllegalInModules</code>(), <code class="identifier">mWhole</code>))
    <code class="keyword">let</code> <code class="identifier">freeAttrs</code>, <code class="identifier">decls</code> = <code class="identifier">declsPreAttrs</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> 
    <code class="keyword">let</code> <code class="identifier">letDecls</code> = [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">Let</code> (<code class="identifier">isRec</code>, <code class="identifier">decls</code>, <code class="identifier">mWhole</code>) ] 
    <code class="keyword">let</code> <code class="identifier">attrDecls</code> = <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> <code class="identifier">freeAttrs</code>) <code class="keyword">then</code> [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">Attributes</code> (<code class="identifier">freeAttrs</code>, <code class="identifier">attrsm</code>) ] <code class="keyword">else</code> [] 
    <code class="identifier">attrDecls</code> @ <code class="identifier">letDecls</code>

<code class="keyword">let</code> <code class="identifier">idOfPat</code> (<code class="identifier">parseState</code>:<code class="identifier">IParseState</code>) <code class="identifier">m</code> <code class="identifier">p</code> = 
    <code class="keyword">match</code> <code class="identifier">p</code> <code class="keyword">with</code>
    | <code class="identifier">SynPat</code>.<code class="identifier">Wild</code> <code class="identifier">r</code> <code class="keyword">when</code> <code class="identifier">parseState</code>.<code class="identifier">LexBuffer</code>.<code class="identifier">SupportsFeature</code> <code class="identifier">LanguageFeature</code>.<code class="identifier">WildCardInForLoop</code> -&gt;
        <code class="identifier">mkSynId</code> <code class="identifier">r</code> <code class="string">"_"</code>
    | <code class="identifier">SynPat</code>.<code class="identifier">Named</code> (<code class="identifier">SynPat</code>.<code class="identifier">Wild</code> <code class="identifier">_</code>, <code class="identifier">id</code>, <code class="keyword">false</code>, <code class="identifier">_</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">id</code>
    | <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code>(<code class="identifier">LongIdentWithDots</code>([<code class="identifier">id</code>], <code class="identifier">_</code>), <code class="identifier">_</code>, <code class="identifier">None</code>, <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> [], <code class="identifier">None</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">id</code>
    | <code class="identifier">_</code> -&gt; <code class="identifier">raiseParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIntegerForLoopRequiresSimpleIdentifier</code>())

<code class="keyword">let</code> <code class="identifier">checkForMultipleAugmentations</code> <code class="identifier">m</code> <code class="identifier">a1</code> <code class="identifier">a2</code> = 
    <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> <code class="identifier">a1</code>) &amp;&amp; <code class="keyword">not</code> (<code class="identifier">isNil</code> <code class="identifier">a2</code>) <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsOnlyOneWithAugmentationAllowed</code>())
    <code class="identifier">a1</code> @ <code class="identifier">a2</code>

<code class="keyword">let</code> <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>:<code class="identifier">IParseState</code>, <code class="identifier">elemIdx</code>) = 
    <code class="identifier">LexbufLocalXmlDocStore</code>.<code class="identifier">GrabXmlDocBeforeMarker</code>(<code class="identifier">parseState</code>.<code class="identifier">LexBuffer</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> <code class="identifier">elemIdx</code>)

<code class="keyword">let</code> <code class="identifier">rangeOfLongIdent</code>(<code class="identifier">lid</code>:<code class="identifier">LongIdent</code>) =
    <code class="identifier">System</code>.<code class="identifier">Diagnostics</code>.<code class="identifier">Debug</code>.<code class="identifier">Assert</code>(<code class="keyword">not</code> <code class="identifier">lid</code>.<code class="identifier">IsEmpty</code>, <code class="string">"the parser should never produce a long-id that is the empty list"</code>) 
    (<code class="identifier">lid</code>.<code class="identifier">Head</code>.<code class="identifier">idRange</code>, <code class="identifier">lid</code>) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> <code class="identifier">id</code> -&gt; <code class="identifier">id</code>.<code class="identifier">idRange</code>) 

%} 

<code class="comment">// Producing these changes the lex state, e.g. string --&gt; token, or nesting level of braces in interpolated strings</code>
<code class="keyword">%token</code> &lt;<code class="identifier">byte</code>[] * <code class="identifier">SynByteStringKind</code> * <code class="identifier">ParseHelpers</code>.<code class="identifier">LexerContinuation</code>&gt; <code class="identifier">BYTEARRAY</code>
<code class="keyword">%token</code> &lt;<code class="identifier">string</code> * <code class="identifier">SynStringKind</code> * <code class="identifier">ParseHelpers</code>.<code class="identifier">LexerContinuation</code>&gt; <code class="identifier">STRING</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code> * <code class="identifier">SynStringKind</code> * <code class="identifier">ParseHelpers</code>.<code class="identifier">LexerContinuation</code>&gt; <code class="identifier">INTERP_STRING_BEGIN_END</code>
<code class="keyword">%token</code> &lt;<code class="identifier">string</code> * <code class="identifier">SynStringKind</code> * <code class="identifier">ParseHelpers</code>.<code class="identifier">LexerContinuation</code>&gt; <code class="identifier">INTERP_STRING_BEGIN_PART</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code> * <code class="identifier">ParseHelpers</code>.<code class="identifier">LexerContinuation</code>&gt; <code class="identifier">INTERP_STRING_PART</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code> * <code class="identifier">ParseHelpers</code>.<code class="identifier">LexerContinuation</code>&gt; <code class="identifier">INTERP_STRING_END</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">ParseHelpers</code>.<code class="identifier">LexerContinuation</code>&gt; <code class="identifier">LBRACE</code> <code class="identifier">RBRACE</code>

<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">KEYWORD_STRING</code> <code class="comment">// Like __SOURCE_DIRECTORY__</code>
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">IDENT</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">HASH_IDENT</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">INFIX_STAR_STAR_OP</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">INFIX_COMPARE_OP</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">INFIX_AT_HAT_OP</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">INFIX_BAR_OP</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">PREFIX_OP</code>
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">INFIX_AMP_OP</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">PLUS_MINUS_OP</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">ADJACENT_PREFIX_OP</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">FUNKY_OPERATOR_NAME</code>

<code class="comment">/* bool indicates if INT8 was 'bad' max_int+1, e.g. '128'  */</code>
<code class="keyword">%token</code> &lt;<code class="identifier">sbyte</code> * <code class="identifier">bool</code>&gt; <code class="identifier">INT8</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">int16</code> * <code class="identifier">bool</code>&gt; <code class="identifier">INT16</code>
<code class="keyword">%token</code> &lt;<code class="identifier">int32</code> * <code class="identifier">bool</code>&gt; <code class="identifier">INT32</code> <code class="identifier">INT32_DOT_DOT</code>
<code class="keyword">%token</code> &lt;<code class="identifier">int64</code> * <code class="identifier">bool</code>&gt; <code class="identifier">INT64</code>
<code class="keyword">%token</code> &lt;<code class="identifier">int64</code> * <code class="identifier">bool</code>&gt; <code class="identifier">NATIVEINT</code>

<code class="keyword">%token</code> &lt;<code class="identifier">byte</code>&gt; <code class="identifier">UINT8</code>
<code class="keyword">%token</code> &lt;<code class="identifier">uint16</code>&gt; <code class="identifier">UINT16</code>
<code class="keyword">%token</code> &lt;<code class="identifier">uint32</code>&gt; <code class="identifier">UINT32</code>
<code class="keyword">%token</code> &lt;<code class="identifier">uint64</code>&gt; <code class="identifier">UINT64</code>
<code class="keyword">%token</code> &lt;<code class="identifier">uint64</code>&gt; <code class="identifier">UNATIVEINT</code>
<code class="keyword">%token</code> &lt;<code class="identifier">single</code>&gt; <code class="identifier">IEEE32</code>
<code class="keyword">%token</code> &lt;<code class="identifier">double</code>&gt; <code class="identifier">IEEE64</code>
<code class="keyword">%token</code> &lt;<code class="identifier">char</code>&gt; <code class="identifier">CHAR</code>
<code class="keyword">%token</code> &lt;<code class="identifier">System</code>.<code class="identifier">Decimal</code>&gt; <code class="identifier">DECIMAL</code> 
<code class="keyword">%token</code> &lt;(<code class="identifier">string</code> * <code class="identifier">string</code>)&gt; <code class="identifier">BIGNUM</code>
<code class="keyword">%token</code> &lt;<code class="identifier">bool</code>&gt; <code class="identifier">LET</code> <code class="identifier">YIELD</code> <code class="identifier">YIELD_BANG</code> <code class="identifier">AND_BANG</code>
<code class="keyword">%token</code> &lt;<code class="identifier">bool</code>&gt; <code class="identifier">LESS</code> <code class="identifier">GREATER</code> <code class="comment">/* here the bool indicates if the tokens are part of a type application or type parameter declaration, e.g. C&lt;int&gt;, detected by the lex filter */</code>
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">PERCENT_OP</code> <code class="identifier">BINDER</code> 
<code class="keyword">%token</code> &lt;<code class="identifier">string</code> * <code class="identifier">bool</code>&gt; <code class="identifier">LQUOTE</code> <code class="identifier">RQUOTE</code>  <code class="identifier">RQUOTE_DOT</code> 
<code class="keyword">%token</code> <code class="identifier">BAR_BAR</code> <code class="identifier">UPCAST</code> <code class="identifier">DOWNCAST</code> <code class="identifier">NULL</code> <code class="identifier">RESERVED</code> <code class="identifier">MODULE</code> <code class="identifier">NAMESPACE</code> <code class="identifier">DELEGATE</code> <code class="identifier">CONSTRAINT</code> <code class="identifier">BASE</code>
<code class="keyword">%token</code> <code class="identifier">AND</code> <code class="identifier">AS</code> <code class="identifier">ASSERT</code> <code class="identifier">OASSERT</code> <code class="identifier">ASR</code> <code class="identifier">BEGIN</code> <code class="identifier">DO</code> <code class="identifier">DONE</code> <code class="identifier">DOWNTO</code> <code class="identifier">ELSE</code> <code class="identifier">ELIF</code> <code class="identifier">END</code> <code class="identifier">DOT_DOT</code> <code class="identifier">DOT_DOT_HAT</code>
<code class="keyword">%token</code> <code class="identifier">EXCEPTION</code> <code class="identifier">FALSE</code> <code class="identifier">FOR</code> <code class="identifier">FUN</code> <code class="identifier">FUNCTION</code> <code class="identifier">IF</code> <code class="identifier">IN</code> <code class="identifier">JOIN_IN</code> <code class="identifier">FINALLY</code> <code class="identifier">DO_BANG</code> 
<code class="keyword">%token</code> <code class="identifier">LAZY</code> <code class="identifier">OLAZY</code>  <code class="identifier">MATCH</code> <code class="identifier">MATCH_BANG</code>  <code class="identifier">MUTABLE</code> <code class="identifier">NEW</code> <code class="identifier">OF</code> 
<code class="keyword">%token</code> <code class="identifier">OPEN</code> <code class="identifier">OR</code> <code class="identifier">REC</code> <code class="identifier">THEN</code> <code class="identifier">TO</code> <code class="identifier">TRUE</code> <code class="identifier">TRY</code> <code class="identifier">TYPE</code> <code class="identifier">VAL</code> <code class="identifier">INLINE</code> <code class="identifier">INTERFACE</code> <code class="identifier">INSTANCE</code> <code class="identifier">CONST</code>
<code class="keyword">%token</code> <code class="identifier">WHEN</code> <code class="identifier">WHILE</code> <code class="identifier">WITH</code> <code class="identifier">HASH</code> <code class="identifier">AMP</code> <code class="identifier">AMP_AMP</code> <code class="identifier">QUOTE</code> <code class="identifier">LPAREN</code> <code class="identifier">RPAREN</code> <code class="identifier">RPAREN_COMING_SOON</code> <code class="identifier">RPAREN_IS_HERE</code> <code class="identifier">STAR</code> <code class="identifier">COMMA</code> <code class="identifier">RARROW</code> <code class="identifier">GREATER_BAR_RBRACK</code> <code class="identifier">LPAREN_STAR_RPAREN</code>
<code class="keyword">%token</code> <code class="identifier">QMARK</code> <code class="identifier">QMARK_QMARK</code> <code class="identifier">DOT</code> <code class="identifier">COLON</code> <code class="identifier">COLON_COLON</code> <code class="identifier">COLON_GREATER</code>  <code class="identifier">COLON_QMARK_GREATER</code> <code class="identifier">COLON_QMARK</code> <code class="identifier">COLON_EQUALS</code> <code class="identifier">SEMICOLON</code> 
<code class="keyword">%token</code> <code class="identifier">SEMICOLON_SEMICOLON</code> <code class="identifier">LARROW</code> <code class="identifier">EQUALS</code>  <code class="identifier">LBRACK</code>  <code class="identifier">LBRACK_BAR</code>  <code class="identifier">LBRACE_BAR</code>  <code class="identifier">LBRACK_LESS</code> 
<code class="keyword">%token</code> <code class="identifier">BAR_RBRACK</code> <code class="identifier">BAR_RBRACE</code> <code class="identifier">UNDERSCORE</code>
<code class="keyword">%token</code> <code class="identifier">BAR</code> <code class="identifier">RBRACK</code> <code class="identifier">RBRACE_COMING_SOON</code> <code class="identifier">RBRACE_IS_HERE</code> <code class="identifier">MINUS</code> <code class="identifier">DOLLAR</code>
<code class="keyword">%token</code> <code class="identifier">GREATER_RBRACK</code> <code class="identifier">STRUCT</code> <code class="identifier">SIG</code> 
<code class="keyword">%token</code> <code class="identifier">STATIC</code> <code class="identifier">MEMBER</code> <code class="identifier">CLASS</code> <code class="identifier">ABSTRACT</code> <code class="identifier">OVERRIDE</code> <code class="identifier">DEFAULT</code> <code class="identifier">CONSTRUCTOR</code> <code class="identifier">INHERIT</code> 
<code class="keyword">%token</code> <code class="identifier">EXTERN</code> <code class="identifier">VOID</code> <code class="identifier">PUBLIC</code> <code class="identifier">PRIVATE</code> <code class="identifier">INTERNAL</code> <code class="identifier">GLOBAL</code>

<code class="comment">/* for parser 'escape hatch' out of expression context without consuming the 'recover' token */</code>
<code class="keyword">%token</code> <code class="identifier">TYPE_COMING_SOON</code> <code class="identifier">TYPE_IS_HERE</code> <code class="identifier">MODULE_COMING_SOON</code> <code class="identifier">MODULE_IS_HERE</code>

<code class="comment">/* for high-precedence tyapps and apps */</code>
<code class="keyword">%token</code> <code class="identifier">HIGH_PRECEDENCE_BRACK_APP</code>   <code class="comment">/* inserted for f[x], but not f [x] */</code>
<code class="keyword">%token</code> <code class="identifier">HIGH_PRECEDENCE_PAREN_APP</code>   <code class="comment">/* inserted for f(x) and f&lt;int&gt;(x), but not f (x) */</code>
<code class="keyword">%token</code> <code class="identifier">HIGH_PRECEDENCE_TYAPP</code> <code class="comment">/* inserted for x&lt;y&gt;, but not x&lt;y */</code>

<code class="comment">/* for offside rule */</code>
<code class="keyword">%token</code> &lt;<code class="identifier">bool</code>&gt; <code class="identifier">OLET</code>      <code class="comment">/* LexFilter #light converts 'LET' tokens to 'OLET' when starting (CtxtLetDecl(blockLet=true)) */</code>
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">OBINDER</code> <code class="comment">/* LexFilter #light converts 'BINDER' tokens to 'OBINDER' when starting (CtxtLetDecl(blockLet=true)) */</code>
<code class="keyword">%token</code> &lt;<code class="identifier">bool</code>&gt; <code class="identifier">OAND_BANG</code> <code class="comment">/* LexFilter #light converts 'AND_BANG' tokens to 'OAND_BANG' when starting (CtxtLetDecl(blockLet=true)) */</code>
<code class="keyword">%token</code> <code class="identifier">ODO</code>              <code class="comment">/* LexFilter #light converts 'DO' tokens to 'ODO' */</code>
<code class="keyword">%token</code> <code class="identifier">ODO_BANG</code>         <code class="comment">/* LexFilter #light converts 'DO_BANG' tokens to 'ODO_BANG' */</code>
<code class="keyword">%token</code> <code class="identifier">OTHEN</code>            <code class="comment">/* LexFilter #light converts 'THEN' tokens to 'OTHEN' */</code>
<code class="keyword">%token</code> <code class="identifier">OELSE</code>            <code class="comment">/* LexFilter #light converts 'ELSE' tokens to 'OELSE' except if immeditely followed by 'if', when they become 'ELIF' */</code>
<code class="keyword">%token</code> <code class="identifier">OWITH</code>            <code class="comment">/* LexFilter #light converts SOME (but not all) 'WITH' tokens to 'OWITH' */</code> 
<code class="keyword">%token</code> <code class="identifier">OFUNCTION</code>        <code class="comment">/* LexFilter #light converts 'FUNCTION' tokens to 'OFUNCTION' */</code> 
<code class="keyword">%token</code> <code class="identifier">OFUN</code>             <code class="comment">/* LexFilter #light converts 'FUN' tokens to 'OFUN' */</code>


<code class="keyword">%token</code> <code class="identifier">ORESET</code>           <code class="comment">/* LexFilter uses internally to force a complete reset on a ';;' */</code>

<code class="keyword">%token</code> <code class="identifier">OBLOCKBEGIN</code>      <code class="comment">/* LexFilter #light inserts for:
                                  - just after first '=' or ':' when in 'CtxtModuleHead', i.e. after 'module' and sequence of dot/identifier/access tokens
                                  - just after first '=' when in 'CtxtMemberHead'
                                  - just after first '=' when in 'CtxtType' 
                                  - just after 'do' in any context (when opening CtxtDo)
                                  - just after 'finally' in any context 
                                  - just after 'with' (when opening CtxtWithAsAugment)
                                  - just after 'else' (when opening CtxtElse)
                                  - just after 'then' (when opening CtxtThen)
                                  - just after 'interface' (when pushing CtxtParen(INTERFACE), i.e. next token is DEFAULT | OVERRIDE | INTERFACE | NEW | TYPE | STATIC | END | MEMBER | ABSTRACT  | INHERIT | LBRACK_LESS)
                                  - just after 'class' (when pushing CtxtParen(CLASS)
                                  - just after 'class' 
                           But not when opening these CtxtSeqBlocks:
                                  - just after first non-dot/identifier token past 'namespace' 
                                  - just after first '=' when in 'CtxtLetDecl' or 'CtxtWithAsLet' 
                                  - just after 'lazy' in any context
                                  - just after '-&gt;' in any context                                  
                                  - when opening CtxtNamespaceHead, CtxtModuleHead 
                        */</code>
<code class="keyword">%token</code> <code class="identifier">OBLOCKSEP</code>        <code class="comment">/* LexFilter #light inserts when transforming CtxtSeqBlock(NotFirstInSeqBlock, _, AddBlockEnd) to CtxtSeqBlock(FirstInSeqBlock, _, AddBlockEnd) on exact alignment */</code>

<code class="comment">/*    REVIEW: merge OEND, ODECLEND, OBLOCKEND and ORIGHT_BLOCK_END into one token */</code>
<code class="keyword">%token</code> <code class="identifier">OEND</code>             <code class="comment">/* LexFilter #light inserts when closing CtxtFun, CtxtMatchClauses, CtxtWithAsLet _        */</code>
<code class="keyword">%token</code> <code class="identifier">ODECLEND</code>         <code class="comment">/* LexFilter #light inserts when closing CtxtDo and CtxtLetDecl(block) */</code>
<code class="keyword">%token</code> <code class="identifier">ORIGHT_BLOCK_END</code> <code class="comment">/* LexFilter #light inserts when closing CtxtSeqBlock(_, _, AddOneSidedBlockEnd) */</code>
<code class="keyword">%token</code> <code class="identifier">OBLOCKEND</code> <code class="identifier">OBLOCKEND_COMING_SOON</code> <code class="identifier">OBLOCKEND_IS_HERE</code>       <code class="comment">/* LexFilter #light inserts when closing CtxtSeqBlock(_, _, AddBlockEnd) */</code>

<code class="keyword">%token</code> <code class="identifier">OINTERFACE_MEMBER</code> <code class="comment">/* inserted for non-paranthetical use of 'INTERFACE', i.e. not INTERFACE/END */</code>
<code class="keyword">%token</code> <code class="identifier">FIXED</code>
<code class="keyword">%token</code> &lt;<code class="identifier">token</code>&gt; <code class="identifier">ODUMMY</code>

<code class="comment">/* These are artificial */</code>
<code class="keyword">%token</code> &lt;<code class="identifier">string</code>&gt; <code class="identifier">LEX_FAILURE</code>
<code class="keyword">%token</code> &lt;<code class="identifier">ParseHelpers</code>.<code class="identifier">LexerContinuation</code>&gt; <code class="identifier">COMMENT</code> <code class="identifier">WHITESPACE</code> <code class="identifier">HASH_LINE</code> <code class="identifier">HASH_LIGHT</code> <code class="identifier">INACTIVECODE</code> <code class="identifier">LINE_COMMENT</code> <code class="identifier">STRING_TEXT</code> <code class="identifier">EOF</code>
<code class="keyword">%token</code> &lt;<code class="identifier">range</code> * <code class="identifier">string</code> * <code class="identifier">ParseHelpers</code>.<code class="identifier">LexerContinuation</code>&gt; <code class="identifier">HASH_IF</code> <code class="identifier">HASH_ELSE</code> <code class="identifier">HASH_ENDIF</code> 

<code class="keyword">%start</code> <code class="identifier">signatureFile</code> <code class="identifier">implementationFile</code> <code class="identifier">interaction</code> <code class="identifier">typedSeqExprEOF</code> <code class="identifier">typEOF</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExpr</code>&gt; <code class="identifier">typedSeqExprEOF</code>
<code class="keyword">%type</code> &lt;<code class="identifier">ParsedImplFile</code>&gt; <code class="identifier">implementationFile</code>
<code class="keyword">%type</code> &lt;<code class="identifier">ParsedSigFile</code>&gt; <code class="identifier">signatureFile</code>
<code class="keyword">%type</code> &lt;<code class="identifier">ParsedScriptInteraction</code>&gt; <code class="identifier">interaction</code>
<code class="keyword">%type</code> &lt;<code class="identifier">Ident</code>&gt; <code class="identifier">ident</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynType</code>&gt; <code class="identifier">typ</code> <code class="identifier">typEOF</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynTypeDefnSig</code> <code class="identifier">list</code>&gt; <code class="identifier">tyconSpfns</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExpr</code>&gt; <code class="identifier">patternResult</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExpr</code>&gt; <code class="identifier">declExpr</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExpr</code>&gt; <code class="identifier">minusExpr</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExpr</code>&gt; <code class="identifier">appExpr</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExpr</code>&gt; <code class="identifier">argExpr</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExpr</code>&gt; <code class="identifier">declExprBlock</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynPat</code>&gt; <code class="identifier">headBindingPattern</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExpr</code>&gt; <code class="identifier">atomicExprAfterType</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExpr</code>&gt; <code class="identifier">typedSeqExprBlock</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExpr</code> * <code class="identifier">bool</code>&gt; <code class="identifier">atomicExpr</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynTypeDefnSimpleRepr</code>&gt; <code class="identifier">tyconDefnOrSpfnSimpleRepr</code>
<code class="keyword">%type</code> &lt;(<code class="identifier">SynEnumCase</code>, <code class="identifier">SynUnionCase</code>) <code class="identifier">Choice</code> <code class="identifier">list</code>&gt; <code class="identifier">unionTypeRepr</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynMemberDefns</code>&gt; <code class="identifier">tyconDefnAugmentation</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExceptionDefn</code>&gt; <code class="identifier">exconDefn</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynExceptionDefnRepr</code>&gt; <code class="identifier">exconCore</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynModuleDecl</code> <code class="identifier">list</code>&gt; <code class="identifier">moduleDefnsOrExprPossiblyEmptyOrBlock</code>
<code class="keyword">%type</code> &lt;<code class="identifier">LongIdentWithDots</code>&gt; <code class="identifier">path</code>
<code class="keyword">%type</code> &lt;<code class="identifier">LongIdentWithDots</code>&gt; <code class="identifier">pathOp</code>
<code class="comment">/*     LESS    GREATER        parsedOk   typeArgs           m for each   mWhole  */</code>
<code class="keyword">%type</code> &lt;<code class="identifier">range</code> * <code class="identifier">range</code> <code class="identifier">option</code> * <code class="identifier">bool</code>     * <code class="identifier">SynType</code> <code class="identifier">list</code> * <code class="identifier">range</code> <code class="identifier">list</code> * <code class="identifier">range</code>&gt; <code class="identifier">typeArgsActual</code>
<code class="comment">/*     LESS    GREATER        typeArgs           m for each   mWhole  */</code>
<code class="keyword">%type</code> &lt;<code class="identifier">range</code> * <code class="identifier">range</code> <code class="identifier">option</code> * <code class="identifier">SynType</code> <code class="identifier">list</code> * <code class="identifier">range</code> <code class="identifier">list</code> * <code class="identifier">range</code>&gt; <code class="identifier">typeArgsNoHpaDeprecated</code>
<code class="keyword">%type</code> &lt;<code class="identifier">SynTypar</code>&gt; <code class="identifier">typar</code>

<code class="comment">/* About precedence rules: 
 * 
 * Tokens and dummy-terminals are given precedence below (lowest first).
 * A rule has precedence of the first token or the dummy terminal given after %prec.
 * The precedence resolve shift/reduce conflicts:
 *   (a) If either rule has no precedence:
 *       S/R: shift over reduce, and
 *       R/R: reduce earlier rule over later rule.
 *   (b) If both rules have precedence:
 *       S/R: choose highest precedence action (precedence of reduce rule vs shift token)
 *            if same precedence: leftassoc gives reduce, rightassoc gives shift, nonassoc error.
 *       R/R: reduce the rule that comes first (textually first in the yacc file)
 *
 * Advice from: http://dinosaur.compilertools.net/yacc/
 *
 *   'Conflicts resolved by precedence are not counted in the number of S/R and R/R
 *    conflicts reported by Yacc. This means that mistakes in the moduleSpfn of
 *    precedences may disguise errors in the input grammar; it is a good idea to be
 *    sparing with precedences, and use them in an essentially ``cookbook'' fashion,
 *    until some experience has been gained'
 *
 * Observation:
 *   It is possible to eliminate conflicts by giving precedence to rules and tokens.
 *   Dummy tokens can be used for the rule and the tokens also need precedence.
 *   The danger is that giving precedence to the tokens may twist the grammar elsewhere.
 *   Maybe it would be good to assign precedence at given locations, e.g.
 *
 *   order: precShort precLong
 *
 *   rule: TokA TokB %@precShort        {action1}     -- assign prec to rule.
 *       | TokA TokB TokC@precLong TokD {action2}     -- assign prec to TokC at this point.
 *
 * Observation: reduce/reduce
 *   If there is a common prefix with a reduce/reduce conflict,
 *   e.g "OPEN path" for topopens and moduleDefns then can factor
 *   opendef = "OPEN path" which can be on both paths.
 *
 * Debugging and checking precedence rules.
 *   - comment out a rule's %prec and see what conflicts are introduced.
 *
 * Dummy terminals (like prec_type_prefix) can assign precedence to a rule.
 * Doc says rule and (shift) token precedence resolves shift/reduce conflict.
 * It seems like dummy terminals can not assign precedence to the shift,
 * but including the tokens in the precedences below will order them.
 * e.g. prec_type_prefix lower precedence than RARROW, LBRACK, IDENT, STAR (all extend types).
 */</code>

<code class="comment">/* start with lowest */</code>

<code class="keyword">%nonassoc</code> <code class="identifier">prec_args_error</code>             <code class="comment">/* less than RPAREN */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_atomexpr_lparen_error</code>  <code class="comment">/* less than RPAREN */</code>

<code class="keyword">%right</code> <code class="identifier">AS</code>

<code class="comment">/* prec_wheretyp_prefix = "where typ" lower than extensions, i.e. "WHEN" */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_wheretyp_prefix</code>        <code class="comment">/* lower than WHEN and RPAREN */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">RPAREN</code> <code class="identifier">RPAREN_COMING_SOON</code> <code class="identifier">RPAREN_IS_HERE</code>

<code class="keyword">%right</code> <code class="identifier">WHEN</code>

<code class="comment">/* prec_pat_pat_action = "pattern when expr -&gt; expr"
 * Lower than match extensions - i.e. BAR.
 */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_pat_pat_action</code>          <code class="comment">/* lower than BAR */</code>

<code class="comment">/* "a then b" as an object constructor is very low precedence */</code>
<code class="comment">/* Lower than "if a then b" */</code>
<code class="keyword">%left</code> <code class="identifier">prec_then_before</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_then_if</code> 
<code class="keyword">%left</code>  <code class="identifier">BAR</code>

<code class="keyword">%right</code> <code class="identifier">SEMICOLON</code>  <code class="identifier">prec_semiexpr_sep</code> <code class="identifier">OBLOCKSEP</code>
<code class="keyword">%right</code> <code class="identifier">prec_defn_sep</code>

<code class="comment">/* prec_atompat_pathop = precedence of at atomic pattern, e.g "Constructor".
 * Lower than possible pattern extensions, so "pathOp . extension" does shift not reduce.
 * possible extensions are:
 *  - constant terminals.
 *  - null
 *  - LBRACK = [
 *  - TRUE, FALSE
 
 */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_atompat_pathop</code>
<code class="keyword">%nonassoc</code> <code class="identifier">INT8</code> <code class="identifier">UINT8</code> <code class="identifier">INT16</code> <code class="identifier">UINT16</code> <code class="identifier">INT32</code> <code class="identifier">UINT32</code> <code class="identifier">INT64</code> <code class="identifier">UINT64</code> <code class="identifier">NATIVEINT</code> <code class="identifier">UNATIVEINT</code> <code class="identifier">IEEE32</code> <code class="identifier">IEEE64</code> <code class="identifier">CHAR</code> <code class="identifier">KEYWORD_STRING</code> <code class="identifier">STRING</code> <code class="identifier">BYTEARRAY</code> <code class="identifier">BIGNUM</code> <code class="identifier">DECIMAL</code>
<code class="keyword">%nonassoc</code> <code class="identifier">INTERP_STRING_BEGIN</code> <code class="identifier">INTERP_STRING_PART</code> <code class="identifier">INTERP_STRING_END</code>
<code class="keyword">%nonassoc</code> <code class="identifier">LPAREN</code> <code class="identifier">LBRACE</code> <code class="identifier">LBRACK_BAR</code> 
<code class="keyword">%nonassoc</code> <code class="identifier">TRUE</code> <code class="identifier">FALSE</code> <code class="identifier">UNDERSCORE</code> <code class="identifier">NULL</code>


<code class="comment">/* prec_typ_prefix        lower than "T  -&gt; T  -&gt; T" extensions.
 * prec_tuptyp_prefix     lower than "T * T * T * T" extensions.
 * prec_tuptyptail_prefix lower than "T * T * T * T" extensions.
 * Lower than possible extensions:
 *  - STAR, IDENT, RARROW
 *  - LBRACK = [ - for "base[]" types              
 * Shifts not reduces.
 */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_typ_prefix</code>             <code class="comment">/* lower than STAR, IDENT, RARROW etc */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_tuptyp_prefix</code>          <code class="comment">/* ditto */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_tuptyptail_prefix</code>      <code class="comment">/* ditto */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_toptuptyptail_prefix</code>      <code class="comment">/* ditto */</code>
        
<code class="keyword">%right</code>    <code class="identifier">RARROW</code>
<code class="keyword">%nonassoc</code> <code class="identifier">IDENT</code> <code class="identifier">LBRACK</code>

<code class="comment">/* prec_opt_attributes_none = precedence of no attributes
 * These can prefix LET-moduleDefns.
 * Committing to an opt_attribute (reduce) forces the decision that a following LET is a moduleDefn.
 * At the top-level, it could turn out to be an expr, so prefer to shift and find out...
 */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_opt_attributes_none</code>    <code class="comment">/* lower than LET, NEW */</code>

<code class="comment">/* LET, NEW higher than SEMICOLON so shift
 *   "seqExpr = seqExpr; . let x = y in z"
 *   "seqExpr = seqExpr; . new...."
 */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">LET</code> <code class="identifier">NEW</code>

       
<code class="comment">/* Redundant dummies: expr_let, expr_function, expr_fun, expr_match */</code>
<code class="comment">/* Resolves conflict: expr_try, expr_if */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">expr_let</code>
<code class="keyword">%nonassoc</code> <code class="identifier">decl_let</code>
<code class="keyword">%nonassoc</code> <code class="identifier">expr_function</code> <code class="identifier">expr_fun</code> <code class="identifier">expr_match</code> <code class="identifier">expr_try</code> <code class="identifier">expr_do</code>
<code class="keyword">%nonassoc</code> <code class="identifier">decl_match</code> <code class="identifier">decl_do</code>
<code class="keyword">%nonassoc</code> <code class="identifier">expr_if</code>                     <code class="comment">/* lower than ELSE to disambiguate "if _ then if _ then _ else _" */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">ELSE</code>   

<code class="comment">/* prec_atomtyp_path = precedence of atomType "path"
 * Lower than possible extension "path&lt;T1, T2&gt;" to allow "path . &lt;" shift.
 * Extensions: LESS
 */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_atomtyp_path</code>           <code class="comment">/* lower than LESS */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_atomtyp_get_path</code>       <code class="comment">/* lower than LESS */</code>

<code class="comment">/* prec_no_more_attr_bindings = precedence of "moreLocalBindings = ."
 * Lower precedence than AND so further bindings are shifted.
 */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_no_more_attr_bindings</code>  <code class="comment">/* lower than AND */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">OPEN</code>

<code class="comment">/* prec_interfaces_prefix - lower than extensions, i.e. INTERFACE */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">prec_interfaces_prefix</code>      <code class="comment">/* lower than INTERFACE */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">INTERFACE</code>

<code class="keyword">%right</code> <code class="identifier">LARROW</code> 
<code class="keyword">%right</code> <code class="identifier">COLON_EQUALS</code> 
<code class="keyword">%nonassoc</code> <code class="identifier">pat_tuple</code> <code class="identifier">expr_tuple</code>
<code class="keyword">%left</code> <code class="identifier">COMMA</code>
<code class="keyword">%nonassoc</code> <code class="identifier">slice_expr</code> <code class="comment">/* matrix.[e COMMA e] has higher precedence than "e COMMA e" */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">interpolation_fill</code> <code class="comment">/* "...{3,N4}..." .NET style fill has higher precedence than "e COMMA e" */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">DOT_DOT</code> <code class="comment">/* for matrix.[1..2, 3..4] the ".." has higher precedence than expression "2 COMMA 3" */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">slice_comma</code>  <code class="comment">/* for matrix.[1..2, 3..4] the ", " has higher precedence than ".." */</code>
<code class="keyword">%nonassoc</code> <code class="identifier">paren_pat_colon</code>
<code class="keyword">%nonassoc</code> <code class="identifier">paren_pat_attribs</code>
<code class="keyword">%left</code> <code class="identifier">OR</code> <code class="identifier">BAR_BAR</code> <code class="identifier">JOIN_IN</code>
<code class="keyword">%left</code> <code class="identifier">AND</code>
<code class="keyword">%left</code> <code class="identifier">AND_BANG</code>
<code class="keyword">%left</code>  <code class="identifier">AMP</code> <code class="identifier">AMP_AMP</code> 
<code class="keyword">%nonassoc</code> <code class="identifier">pat_conj</code>
<code class="keyword">%nonassoc</code> <code class="identifier">expr_not</code>
<code class="keyword">%left</code> <code class="identifier">COLON_GREATER</code>  <code class="identifier">COLON_QMARK_GREATER</code>
<code class="keyword">%left</code> <code class="identifier">INFIX_COMPARE_OP</code> <code class="identifier">DOLLAR</code> <code class="identifier">LESS</code> <code class="identifier">GREATER</code> <code class="identifier">EQUALS</code>  <code class="identifier">INFIX_BAR_OP</code> <code class="identifier">INFIX_AMP_OP</code> 
<code class="keyword">%right</code> <code class="identifier">INFIX_AT_HAT_OP</code>
<code class="keyword">%right</code> <code class="identifier">COLON_COLON</code>
<code class="keyword">%nonassoc</code> <code class="identifier">pat_isinst</code> 
<code class="keyword">%left</code> <code class="identifier">COLON_QMARK</code>
<code class="keyword">%left</code> <code class="identifier">PLUS_MINUS_OP</code> <code class="identifier">MINUS</code> <code class="identifier">expr_prefix_plus_minus</code> <code class="identifier">ADJACENT_PREFIX_OP</code>
<code class="keyword">%left</code>  <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> <code class="identifier">STAR</code> <code class="identifier">PERCENT_OP</code>
<code class="keyword">%right</code> <code class="identifier">INFIX_STAR_STAR_OP</code>
<code class="keyword">%left</code>  <code class="identifier">QMARK_QMARK</code>
<code class="keyword">%left</code> <code class="identifier">head_expr_adjacent_minus</code>
<code class="keyword">%left</code> <code class="identifier">expr_app</code> <code class="identifier">expr_assert</code> <code class="identifier">expr_lazy</code> <code class="identifier">LAZY</code> <code class="identifier">ASSERT</code>
<code class="keyword">%left</code> <code class="identifier">arg_expr_adjacent_minus</code>
<code class="keyword">%left</code> <code class="identifier">expr_args</code>
<code class="keyword">%right</code> <code class="identifier">matching_bar</code>
<code class="keyword">%left</code> <code class="identifier">pat_app</code>
<code class="keyword">%left</code> <code class="identifier">pat_args</code>
<code class="keyword">%left</code> <code class="identifier">PREFIX_OP</code>
<code class="keyword">%left</code> <code class="identifier">DOT</code> <code class="identifier">QMARK</code>
<code class="keyword">%left</code> <code class="identifier">HIGH_PRECEDENCE_BRACK_APP</code>
<code class="keyword">%left</code> <code class="identifier">HIGH_PRECEDENCE_PAREN_APP</code>
<code class="keyword">%left</code> <code class="identifier">HIGH_PRECEDENCE_TYAPP</code>

<code class="keyword">%nonassoc</code> <code class="identifier">prec_interaction_empty</code>

%%

<code class="comment">/*--------------------------------------------------------------------------*/</code>
<code class="comment">/* F# Interactive */</code>

<code class="comment">/* A SEMICOLON_SEMICOLON (or EOF) will mark the end of all interaction blocks. */</code>
<code class="comment">/* The end of interaction blocks must be determined without needing to lookahead one more token. */</code>
<code class="comment">/* A lookahead token would be dropped between parser calls. See bug 1027. */</code>

<code class="comment">/* An interaction in F# Interactive */</code>
<code class="identifier">interaction</code>:
  | <code class="identifier">interactiveItemsTerminator</code>
     { <code class="identifier">ParsedScriptInteraction</code>.<code class="identifier">Definitions</code> ($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">SEMICOLON</code> 
     { <code class="identifier">warning</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedSemicolon</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
       <code class="identifier">ParsedScriptInteraction</code>.<code class="identifier">Definitions</code> ([], <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">OBLOCKSEP</code>
     { <code class="identifier">ParsedScriptInteraction</code>.<code class="identifier">Definitions</code> ([], <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }


<code class="identifier">interactiveTerminator</code>: 
  | <code class="identifier">SEMICOLON_SEMICOLON</code> {}
  | <code class="identifier">EOF</code>     { <code class="identifier">checkEndOfFileError</code> $1 }


<code class="comment">/* An group of items considered to be one interaction, plus a terminator */</code>
<code class="comment">/* Represents the sequence of items swallowed in one interaction by F# Interactive */</code>
<code class="comment">/* It is important to make this as large as possible given the chunk of input */</code>
<code class="comment">/* text. More or less identical to 'moduleDefns' but where SEMICOLON_SEMICOLON is */</code>
<code class="comment">/* not part of the grammar of topSeps and HASH interactions are not part of */</code>
<code class="comment">/* the swalloed blob, since things like #use must be processed separately. */</code>
<code class="comment">/* REVIEW: limiting the input chunks until the next # directive can lead to */</code> 
<code class="comment">/* discrepencies between whole-file type checking in FSI and FSC. */</code>

<code class="identifier">interactiveItemsTerminator</code>:
  | <code class="identifier">interactiveTerminator</code>  
     { [] }

  | <code class="identifier">interactiveDefns</code> <code class="identifier">interactiveTerminator</code> 
     { $1 }

  | <code class="identifier">interactiveExpr</code>  <code class="identifier">interactiveTerminator</code> 
     { $1 }

  | <code class="identifier">interactiveHash</code>  <code class="identifier">interactiveTerminator</code> 
     { $1 }

  | <code class="identifier">interactiveDefns</code> <code class="identifier">interactiveSeparators</code> <code class="identifier">interactiveItemsTerminator</code> 
     { $1 @ $3 }

  | <code class="identifier">interactiveExpr</code>  <code class="identifier">interactiveSeparators</code> <code class="identifier">interactiveItemsTerminator</code> 
     { $1 @ $3 }

  | <code class="identifier">interactiveHash</code>  <code class="identifier">interactiveSeparators</code> <code class="identifier">interactiveItemsTerminator</code> 
     { $1 @ $3 }


<code class="comment">/* A group of definitions as part of in one interaction in F# Interactive */</code>
<code class="identifier">interactiveDefns</code>:
  | <code class="identifier">moduleDefn</code>
      { $1 }

  | <code class="identifier">moduleDefn</code> <code class="identifier">interactiveDefns</code>
      { $1 @ $2 }


<code class="comment">/* An expression as part of one interaction in F# Interactive */</code>
<code class="identifier">interactiveExpr</code>:
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">declExpr</code>
      { <code class="keyword">match</code> $2 <code class="keyword">with</code>
        | <code class="identifier">Some</code> <code class="identifier">vis</code> -&gt; <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedVisibilityDeclaration</code>(<code class="identifier">vis</code>.<code class="identifier">ToString</code>()), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3))
        | <code class="identifier">_</code> -&gt; ()
        <code class="keyword">let</code> <code class="identifier">attrDecls</code> = <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">Attributes</code> ($1, <code class="identifier">rangeOfNonNilAttrs</code> $1) ] <code class="keyword">else</code> [] <code class="keyword">in</code> 
        <code class="identifier">attrDecls</code> @ [ <code class="identifier">mkSynDoDecl</code>($3)] }


<code class="comment">/* A #directive interaction in F# Interactive */</code>
<code class="identifier">interactiveHash</code>:      
  | <code class="identifier">hashDirective</code> 
      { [<code class="identifier">SynModuleDecl</code>.<code class="identifier">HashDirective</code>($1, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)] }


<code class="comment">/* One or more separators between interactions in F# Interactive */</code>
<code class="identifier">interactiveSeparators</code>: 
  | <code class="identifier">interactiveSeparator</code> { } 

  | <code class="identifier">interactiveSeparator</code> <code class="identifier">interactiveSeparators</code> { }

<code class="comment">/* One separator between interactions in F# Interactive */</code>
<code class="identifier">interactiveSeparator</code>: 
  | <code class="identifier">SEMICOLON</code> { } 
  | <code class="identifier">OBLOCKSEP</code> { }  

<code class="comment">/*--------------------------------------------------------------------------*/</code>
<code class="comment">/* #directives - used by both F# Interactive directives and #nowarn etc.    */</code>


<code class="comment">/* A #directive in a module, namespace or an interaction */</code>
<code class="identifier">hashDirective</code>:
  | <code class="identifier">HASH</code> <code class="identifier">IDENT</code> <code class="identifier">hashDirectiveArgs</code>                            
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="keyword">match</code> $3 <code class="keyword">with</code> [] -&gt; <code class="identifier">rhs2</code>  <code class="identifier">parseState</code> 1 2 | <code class="identifier">_</code> -&gt; <code class="identifier">rhs2</code>  <code class="identifier">parseState</code> 1 3
       <code class="identifier">ParsedHashDirective</code> ($2, $3, <code class="identifier">m</code>) }


<code class="comment">/* The arguments to a #directive */</code>
<code class="identifier">hashDirectiveArgs</code>: 
  | <code class="comment">/* EMPTY */</code>
     { [] } 

  | <code class="identifier">hashDirectiveArgs</code> <code class="identifier">hashDirectiveArg</code> 
     { $1 @ [$2] }


<code class="comment">/* One argument to a #directive */</code>
<code class="identifier">hashDirectiveArg</code>: 
  | <code class="identifier">stringOrKeywordString</code> 
      { <code class="keyword">let</code> <code class="identifier">s</code>, <code class="identifier">_</code> = $1
        <code class="identifier">s</code> }
      

<code class="comment">/*--------------------------------------------------------------------------*/</code>
<code class="comment">/* F# Language Proper - signature files */</code>

<code class="comment">/* The contents of a signature file */</code>
<code class="identifier">signatureFile</code>: 
  | <code class="identifier">fileNamespaceSpecs</code> <code class="identifier">EOF</code> 
     { <code class="identifier">checkEndOfFileError</code> $2; $1 }

  | <code class="identifier">fileNamespaceSpecs</code> <code class="keyword">error</code> <code class="identifier">EOF</code> 
     { $1 }

  <code class="comment">/* If this rule fires it is kind of catastrophic: error recovery yields no results! */</code>
  <code class="comment">/* This will result in NO intellisense for the file! Ideally we wouldn't need this rule */</code>
  <code class="comment">/* Note: the compiler assumes there is at least one "fragment", so an empty one is used (see 4488) */</code>
  | <code class="keyword">error</code> <code class="identifier">EOF</code> 
     { <code class="keyword">let</code> <code class="identifier">emptySigFileFrag</code> = <code class="identifier">ParsedSigFileFragment</code>.<code class="identifier">AnonModule</code>([], <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="keyword">in</code> 
       <code class="identifier">ParsedSigFile</code> ([], [<code class="identifier">emptySigFileFrag</code>]) }     



<code class="comment">/* The start of a module declaration */</code>
<code class="identifier">moduleIntro</code>: 
  | <code class="identifier">moduleKeyword</code> <code class="identifier">opt_access</code> <code class="identifier">opt_rec</code> <code class="identifier">path</code> 
      { $3, $4.<code class="identifier">Lid</code>, <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 1), $2 }


<code class="comment">/* The start of a namespace declaration */</code>
<code class="identifier">namespaceIntro</code>: 
  | <code class="identifier">NAMESPACE</code> <code class="identifier">opt_rec</code> <code class="identifier">path</code> 
      { $2, $3.<code class="identifier">Lid</code>, <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 1)  }


<code class="comment">/* The contents of a signature file */</code>
<code class="identifier">fileNamespaceSpecs</code>: 
  | <code class="identifier">fileModuleSpec</code>  
      { <code class="identifier">ParsedSigFile</code> ([], [ ($1 (<code class="keyword">false</code>, [], <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>)) ]) }

  | <code class="identifier">fileModuleSpec</code>  <code class="identifier">fileNamespaceSpecList</code> 
      { <code class="comment">// If there are namespaces, the first fileModuleImpl may only contain # directives </code>
        <code class="keyword">let</code> <code class="identifier">decls</code> = 
            <code class="keyword">match</code> ($1 (<code class="keyword">false</code>, [], <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>)) <code class="keyword">with</code> 
            | <code class="identifier">ParsedSigFileFragment</code>.<code class="identifier">AnonModule</code>(<code class="identifier">decls</code>, <code class="identifier">m</code>) -&gt; <code class="identifier">decls</code>  
            | <code class="identifier">ParsedSigFileFragment</code>.<code class="identifier">NamespaceFragment</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">decls</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">decls</code> 
            | <code class="identifier">ParsedSigFileFragment</code>.<code class="identifier">NamedModule</code>(<code class="identifier">SynModuleOrNamespaceSig</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">m</code>)) -&gt;
                <code class="identifier">raiseParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsOnlyHashDirectivesAllowed</code>())
        <code class="keyword">let</code> <code class="identifier">decls</code> = 
            <code class="identifier">decls</code> |&gt; <code class="identifier">List</code>.<code class="identifier">collect</code> (<code class="keyword">function</code> 
                | (<code class="identifier">SynModuleSigDecl</code>.<code class="identifier">HashDirective</code> (<code class="identifier">hd</code>, <code class="identifier">_</code>)) -&gt; [<code class="identifier">hd</code>]
                | <code class="identifier">d</code> -&gt;  
                     <code class="identifier">reportParseErrorAt</code> <code class="identifier">d</code>.<code class="identifier">Range</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsOnlyHashDirectivesAllowed</code>())
                     [])
        <code class="identifier">ParsedSigFile</code> (<code class="identifier">decls</code>, $2) } 


<code class="identifier">fileNamespaceSpecList</code>: 
  | <code class="identifier">fileNamespaceSpec</code> <code class="identifier">fileNamespaceSpecList</code> 
     { $1 :: $2 }

  | <code class="identifier">fileNamespaceSpec</code> 
     { [$1] }

<code class="identifier">fileNamespaceSpec</code>: 
  | <code class="identifier">namespaceIntro</code> <code class="identifier">deprecated_opt_equals</code> <code class="identifier">fileModuleSpec</code> 
     { <code class="keyword">let</code> <code class="identifier">isRec</code>, <code class="identifier">path</code>, <code class="identifier">xml</code> = $1 <code class="keyword">in</code> ($3 (<code class="identifier">isRec</code>, <code class="identifier">path</code>, <code class="identifier">xml</code>)) }


<code class="comment">/* The single module declaration that can make up a signature file */</code>
<code class="identifier">fileModuleSpec</code>: 
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code>  <code class="identifier">moduleIntro</code> <code class="identifier">moduleSpfnsPossiblyEmptyBlock</code> 
    { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
      <code class="keyword">let</code> <code class="identifier">m2</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3
      <code class="keyword">let</code> <code class="identifier">m</code> = (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4)
      <code class="keyword">let</code> <code class="identifier">isRec</code>, <code class="identifier">path2</code>, <code class="identifier">xml</code>, <code class="identifier">vis</code> = $3 
      (<code class="keyword">fun</code> (<code class="identifier">isRec2</code>, <code class="identifier">path</code>, <code class="identifier">_</code>) -&gt; 
        <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> <code class="identifier">path</code>) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsNamespaceOrModuleNotBoth</code>(), <code class="identifier">m2</code>))
        <code class="keyword">let</code> <code class="identifier">lid</code> = <code class="identifier">path</code>@<code class="identifier">path2</code> 
        <code class="identifier">ParsedSigFileFragment</code>.<code class="identifier">NamedModule</code>(<code class="identifier">SynModuleOrNamespaceSig</code>(<code class="identifier">lid</code>, (<code class="identifier">isRec</code> || <code class="identifier">isRec2</code>), <code class="identifier">SynModuleOrNamespaceKind</code>.<code class="identifier">NamedModule</code>, $4, <code class="identifier">xml</code>, $1, <code class="identifier">vis</code>, <code class="identifier">m</code>)))  }

  | <code class="identifier">moduleSpfnsPossiblyEmptyBlock</code> 
    { <code class="keyword">let</code> <code class="identifier">m</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) 
      (<code class="keyword">fun</code> (<code class="identifier">isRec</code>, <code class="identifier">path</code>, <code class="identifier">xml</code>) -&gt; 
        <code class="keyword">match</code> <code class="identifier">path</code> <code class="keyword">with</code>
        | [] -&gt; <code class="identifier">ParsedSigFileFragment</code>.<code class="identifier">AnonModule</code>($1, <code class="identifier">m</code>)  
        | <code class="identifier">_</code> -&gt;
            <code class="keyword">let</code> <code class="identifier">lastDeclRange</code> = <code class="identifier">List</code>.<code class="identifier">tryLast</code> $1 |&gt; <code class="identifier">Option</code>.<code class="identifier">map</code> (<code class="keyword">fun</code> <code class="identifier">decl</code> -&gt; <code class="identifier">decl</code>.<code class="identifier">Range</code>) |&gt; <code class="identifier">Option</code>.<code class="identifier">defaultValue</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
            <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">mkRange</code> <code class="identifier">lastDeclRange</code>.<code class="identifier">FileName</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>).<code class="identifier">Start</code> <code class="identifier">lastDeclRange</code>.<code class="identifier">End</code>
            <code class="identifier">ParsedSigFileFragment</code>.<code class="identifier">NamespaceFragment</code>(<code class="identifier">path</code>, <code class="identifier">isRec</code>, <code class="identifier">SynModuleOrNamespaceKind</code>.<code class="identifier">DeclaredNamespace</code>, $1, <code class="identifier">xml</code>, [], <code class="identifier">m</code>))  } 


<code class="identifier">moduleSpfnsPossiblyEmptyBlock</code>: 
  | <code class="identifier">moduleSpfnsPossiblyEmpty</code>
      { $1 }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">moduleSpfnsPossiblyEmpty</code> <code class="identifier">oblockend</code>  <code class="identifier">opt_OBLOCKSEP</code>
      { $2 }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">moduleSpfnsPossiblyEmpty</code> <code class="identifier">recover</code> 
       { <code class="comment">// The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error</code>
         <code class="comment">// reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnClosedBlockInHashLight())   </code>
         $2 
       }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="keyword">error</code> <code class="identifier">oblockend</code>                
       { [] }
      

<code class="identifier">moduleSpfnsPossiblyEmpty</code>: 
  | <code class="identifier">moduleSpfns</code>
      { $1 }

  | <code class="keyword">error</code>
      { [] }

  | <code class="comment">/* EMPTY */</code>
      { [] }
      

<code class="identifier">moduleSpfns</code>: 
  | <code class="identifier">moduleSpfn</code>  <code class="identifier">opt_topSeparators</code> <code class="identifier">moduleSpfns</code> 
     { $1 :: $3 } 

  | <code class="keyword">error</code> <code class="identifier">topSeparators</code> <code class="identifier">moduleSpfns</code> 
     { <code class="comment">(* silent recovery *)</code> $3 }

  | <code class="identifier">moduleSpfn</code>  <code class="identifier">opt_topSeparators</code> 
     { [$1] } 


<code class="identifier">moduleSpfn</code>: 
  | <code class="identifier">hashDirective</code> 
      { <code class="identifier">SynModuleSigDecl</code>.<code class="identifier">HashDirective</code> ($1, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 1)  } 

  | <code class="identifier">valSpfn</code> 
      { $1 }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">moduleIntro</code> <code class="identifier">colonOrEquals</code> <code class="identifier">namedModuleAbbrevBlock</code> 
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> <code class="identifier">isRec</code>, <code class="identifier">path</code>, <code class="identifier">xml</code>, <code class="identifier">vis</code> = $3 
        <code class="keyword">if</code> <code class="identifier">isRec</code> <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidUseOfRec</code>())
        <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isSingleton</code> <code class="identifier">path</code>) <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsModuleAbbreviationMustBeSimpleName</code>())
        <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIgnoreAttributesOnModuleAbbreviation</code>())
        <code class="keyword">match</code> <code class="identifier">vis</code> <code class="keyword">with</code>
        | <code class="identifier">Some</code> <code class="identifier">vis</code> -&gt; <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate</code>(<code class="identifier">vis</code>.<code class="identifier">ToString</code>()))
        | <code class="identifier">_</code> -&gt; <code class="identifier">SynModuleSigDecl</code>.<code class="identifier">ModuleAbbrev</code>(<code class="identifier">List</code>.<code class="identifier">head</code> <code class="identifier">path</code>, $5, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5) } 

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code>  <code class="identifier">moduleIntro</code> <code class="identifier">colonOrEquals</code> <code class="identifier">moduleSpecBlock</code>
      { <code class="keyword">let</code> <code class="identifier">isRec</code>, <code class="identifier">path</code>, <code class="identifier">xml</code>, <code class="identifier">vis</code> = $3 
        <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isSingleton</code> <code class="identifier">path</code>) <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsModuleDefnMustBeSimpleName</code>())
        <code class="keyword">if</code> <code class="identifier">isRec</code> <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidUseOfRec</code>())
        <code class="keyword">let</code> <code class="identifier">info</code> = <code class="identifier">SynComponentInfo</code>($1, [], [], <code class="identifier">path</code>, <code class="identifier">xml</code>, <code class="keyword">false</code>, <code class="identifier">vis</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3)
        <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="identifier">SynModuleSigDecl</code>.<code class="identifier">NestedModule</code>(<code class="identifier">info</code>, <code class="identifier">isRec</code>, $5, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code>  <code class="identifier">tyconSpfns</code> 
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> (<code class="identifier">SynTypeDefnSig</code>(<code class="identifier">SynComponentInfo</code>(<code class="identifier">cas</code>, <code class="identifier">a</code>, <code class="identifier">cs</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">d2</code>, <code class="identifier">d3</code>), <code class="identifier">e</code>, <code class="identifier">f</code>, <code class="identifier">g</code>)), <code class="identifier">rest</code> = 
           <code class="keyword">match</code> $3 <code class="keyword">with</code>
           | [] -&gt; <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEmptyModuleDefn</code>()) 
           | <code class="identifier">h</code> :: <code class="identifier">t</code> -&gt; <code class="identifier">h</code>, <code class="identifier">t</code> 
        <code class="keyword">let</code> <code class="identifier">tc</code> = (<code class="identifier">SynTypeDefnSig</code>(<code class="identifier">SynComponentInfo</code>($1@<code class="identifier">cas</code>, <code class="identifier">a</code>, <code class="identifier">cs</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">d2</code>, <code class="identifier">d3</code>), <code class="identifier">e</code>, <code class="identifier">f</code>, <code class="identifier">g</code>))
        <code class="keyword">let</code> <code class="identifier">lastType</code> = <code class="identifier">List</code>.<code class="identifier">tryLast</code> <code class="identifier">rest</code> |&gt; <code class="identifier">Option</code>.<code class="identifier">defaultValue</code> <code class="identifier">tc</code> |&gt; <code class="keyword">fun</code> <code class="identifier">t</code> -&gt; <code class="identifier">t</code>.<code class="identifier">Range</code>
        <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">mkRange</code> <code class="identifier">lastType</code>.<code class="identifier">FileName</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>).<code class="identifier">Start</code> <code class="identifier">lastType</code>.<code class="identifier">End</code>
        <code class="identifier">SynModuleSigDecl</code>.<code class="identifier">Types</code> (<code class="identifier">tc</code> :: <code class="identifier">rest</code>, <code class="identifier">m</code>) } 

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">exconSpfn</code>
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> (<code class="identifier">SynExceptionSig</code>(<code class="identifier">SynExceptionDefnRepr</code>(<code class="identifier">cas</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">d2</code>), <code class="identifier">e</code>, <code class="identifier">f</code>)) = $3 
        <code class="keyword">let</code> <code class="identifier">ec</code> = <code class="identifier">SynExceptionSig</code>(<code class="identifier">SynExceptionDefnRepr</code>($1@<code class="identifier">cas</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">d2</code>), <code class="identifier">e</code>, <code class="identifier">f</code>)
        <code class="identifier">SynModuleSigDecl</code>.<code class="identifier">Exception</code>(<code class="identifier">ec</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) }

  | <code class="identifier">openDecl</code>
      { <code class="identifier">SynModuleSigDecl</code>.<code class="identifier">Open</code>($1, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)) }

<code class="identifier">valSpfn</code>: 
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">VAL</code> <code class="identifier">opt_attributes</code> <code class="identifier">opt_inline</code> <code class="identifier">opt_mutable</code> <code class="identifier">opt_access</code> <code class="identifier">nameop</code> <code class="identifier">opt_explicitValTyparDecls</code> <code class="identifier">COLON</code> <code class="identifier">topTypeWithTypeConstraints</code> <code class="identifier">optLiteralValueSpfn</code>
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> <code class="identifier">attr1</code>, <code class="identifier">attr2</code>, <code class="identifier">isInline</code>, <code class="identifier">isMutable</code>, <code class="identifier">vis2</code>, <code class="identifier">id</code>, <code class="identifier">doc</code>, <code class="identifier">explicitValTyparDecls</code>, (<code class="identifier">ty</code>, <code class="identifier">arity</code>), <code class="identifier">konst</code> = ($1), ($4), ($5), ($6), ($7), ($8), <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 3), ($9), ($11), ($12) 
        <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> <code class="identifier">attr2</code>) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Deprecated</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAttributesMustComeBeforeVal</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 4))
        <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 11 
        <code class="keyword">let</code> <code class="identifier">valSpfn</code> = <code class="identifier">SynValSig</code>((<code class="identifier">attr1</code>@<code class="identifier">attr2</code>), <code class="identifier">id</code>, <code class="identifier">explicitValTyparDecls</code>, <code class="identifier">ty</code>, <code class="identifier">arity</code>, <code class="identifier">isInline</code>, <code class="identifier">isMutable</code>, <code class="identifier">doc</code>, <code class="identifier">vis2</code>, <code class="identifier">konst</code>, <code class="identifier">m</code>) 
        <code class="identifier">SynModuleSigDecl</code>.<code class="identifier">Val</code>(<code class="identifier">valSpfn</code>, <code class="identifier">m</code>)
      }

<code class="comment">/* The optional literal value on a literal specification in a signature */</code>
<code class="identifier">optLiteralValueSpfn</code>: 
  | <code class="comment">/* EMPTY */</code>
      { <code class="identifier">None</code> }

  | <code class="identifier">EQUALS</code> <code class="identifier">declExpr</code> 
      { <code class="identifier">Some</code>($2) }

  | <code class="identifier">EQUALS</code> <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">declExpr</code> <code class="identifier">oblockend</code> <code class="identifier">opt_ODECLEND</code>
      { <code class="identifier">Some</code>($3) }
  

<code class="comment">/* A block of definitions in a module in a signature file */</code>
<code class="identifier">moduleSpecBlock</code>: 

  <code class="comment">/* #light-syntax, with no sig/end or begin/end */</code>
  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">moduleSpfns</code> <code class="identifier">oblockend</code> 
      { $2 }

  <code class="comment">/* #light-syntax, with sig/end or begin/end */</code>
  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">sigOrBegin</code> <code class="identifier">moduleSpfnsPossiblyEmpty</code> <code class="identifier">END</code> <code class="identifier">oblockend</code> 
      { $3 }

  <code class="comment">/* non-#light-syntax, with sig/end or begin/end */</code>
  |             <code class="identifier">sigOrBegin</code> <code class="identifier">moduleSpfnsPossiblyEmpty</code> <code class="identifier">END</code> 
      { $2 }


<code class="comment">/* A group of type definitions in a signature */</code>
<code class="identifier">tyconSpfns</code>:      
  | <code class="identifier">typeKeyword</code> <code class="identifier">tyconSpfnList</code> 
     { $2 }


<code class="identifier">tyconSpfnList</code>:  
  | <code class="identifier">tyconSpfn</code> <code class="identifier">AND</code> <code class="identifier">tyconSpfnList</code> 
     { $1 :: $3 } 

  | <code class="identifier">tyconSpfn</code> 
     { [$1] }


<code class="comment">/* A type definition in a signature */</code>
<code class="identifier">tyconSpfn</code>: 
  | <code class="identifier">typeNameInfo</code>  <code class="identifier">EQUALS</code> <code class="identifier">tyconSpfnRhsBlock</code> 
      { <code class="keyword">let</code> <code class="identifier">lhsm</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
        $3 <code class="identifier">lhsm</code> $1 }
  | <code class="identifier">typeNameInfo</code>  <code class="identifier">opt_classSpfn</code>       
      { <code class="identifier">SynTypeDefnSig</code>($1, <code class="identifier">SynTypeDefnSigRepr</code>.<code class="identifier">Simple</code> (<code class="identifier">SynTypeDefnSimpleRepr</code>.<code class="identifier">None</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>), <code class="identifier">lhs</code> <code class="identifier">parseState</code>), $2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }


<code class="comment">/* The right-hand-side of a type definition in a signature */</code>
<code class="identifier">tyconSpfnRhsBlock</code>: 
  <code class="comment">/* This rule allows members to be given for record and union types in the #light syntax */</code>
  <code class="comment">/* without the use of 'with' ... 'end'. For example: */</code>
  <code class="comment">/*     type R = */</code>
  <code class="comment">/*         { a : int } */</code>
  <code class="comment">/*         member r.A = a */</code>
  <code class="comment">/* It also takes into account that any existing 'with' */</code>
  <code class="comment">/* block still needs to be considered and may occur indented or undented from the core type */</code>
  <code class="comment">/* representation. */</code>
  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">tyconSpfnRhs</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="identifier">classSpfnMembers</code> <code class="identifier">opt_classSpfn</code> <code class="identifier">oblockend</code> <code class="identifier">opt_classSpfn</code>  
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
       (<code class="keyword">fun</code> <code class="identifier">lhsm</code> <code class="identifier">nameInfo</code> -&gt; 
           $2 <code class="identifier">lhsm</code> <code class="identifier">nameInfo</code> (<code class="identifier">checkForMultipleAugmentations</code> <code class="identifier">m</code> ($4 @ $5) $7)) }

  | <code class="identifier">tyconSpfnRhs</code> <code class="identifier">opt_classSpfn</code>
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
       (<code class="keyword">fun</code> <code class="identifier">lhsm</code> <code class="identifier">nameInfo</code> -&gt; 
           $1 <code class="identifier">lhsm</code> <code class="identifier">nameInfo</code> $2) }


<code class="comment">/* The right-hand-side of a type definition in a signature */</code>
<code class="identifier">tyconSpfnRhs</code>: 
  | <code class="identifier">tyconDefnOrSpfnSimpleRepr</code> 
     { <code class="keyword">let</code> <code class="identifier">m</code> = $1.<code class="identifier">Range</code> 
       (<code class="keyword">fun</code> <code class="identifier">lhsm</code> <code class="identifier">nameInfo</code> <code class="identifier">augmentation</code> -&gt; 
           <code class="identifier">SynTypeDefnSig</code>(<code class="identifier">nameInfo</code>, <code class="identifier">SynTypeDefnSigRepr</code>.<code class="identifier">Simple</code> ($1, <code class="identifier">m</code>), <code class="identifier">augmentation</code>, <code class="identifier">m</code>)) }

  | <code class="identifier">tyconClassSpfn</code> 
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
       <code class="keyword">let</code> <code class="identifier">needsCheck</code>, (<code class="identifier">kind</code>, <code class="identifier">decls</code>) = $1
       (<code class="keyword">fun</code> <code class="identifier">nameRange</code> <code class="identifier">nameInfo</code> <code class="identifier">augmentation</code> -&gt; 
           <code class="keyword">if</code> <code class="identifier">needsCheck</code> &amp;&amp; <code class="identifier">isNil</code> <code class="identifier">decls</code> <code class="keyword">then</code>
              <code class="identifier">reportParseErrorAt</code> <code class="identifier">nameRange</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEmptyTypeDefinition</code>())
           <code class="identifier">SynTypeDefnSig</code>(<code class="identifier">nameInfo</code>, <code class="identifier">SynTypeDefnSigRepr</code>.<code class="identifier">ObjectModel</code> (<code class="identifier">kind</code>, <code class="identifier">decls</code>, <code class="identifier">m</code>), <code class="identifier">augmentation</code>, <code class="identifier">m</code>)) }

  | <code class="identifier">DELEGATE</code> <code class="identifier">OF</code> <code class="identifier">topType</code>
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
       <code class="keyword">let</code> <code class="identifier">ty</code>, <code class="identifier">arity</code> = $3
       <code class="keyword">let</code> <code class="identifier">invoke</code> = <code class="identifier">SynMemberSig</code>.<code class="identifier">Member</code>(<code class="identifier">SynValSig</code>([], <code class="identifier">mkSynId</code> <code class="identifier">m</code> <code class="string">"Invoke"</code>, <code class="identifier">inferredTyparDecls</code>, <code class="identifier">ty</code>, <code class="identifier">arity</code>, <code class="keyword">false</code>, <code class="keyword">false</code>, <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>, <code class="identifier">None</code>, <code class="identifier">None</code>, <code class="identifier">m</code>), <code class="identifier">AbstractMemberFlags</code> <code class="identifier">SynMemberKind</code>.<code class="identifier">Member</code>, <code class="identifier">m</code>) 
       (<code class="keyword">fun</code> <code class="identifier">nameRange</code> <code class="identifier">nameInfo</code> <code class="identifier">augmentation</code> -&gt; 
           <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> <code class="identifier">augmentation</code>) <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAugmentationsIllegalOnDelegateType</code>())
           <code class="identifier">SynTypeDefnSig</code>(<code class="identifier">nameInfo</code>, <code class="identifier">SynTypeDefnSigRepr</code>.<code class="identifier">ObjectModel</code> (<code class="identifier">SynTypeDefnKind</code>.<code class="identifier">Delegate</code> (<code class="identifier">ty</code>, <code class="identifier">arity</code>), [<code class="identifier">invoke</code>], <code class="identifier">m</code>), [], <code class="identifier">m</code>)) }


<code class="comment">/* The right-hand-side of an object type definition in a signature */</code>
<code class="identifier">tyconClassSpfn</code>: 
  | <code class="identifier">classSpfnBlockKindUnspecified</code>
     { <code class="keyword">let</code> <code class="identifier">needsCheck</code>, <code class="identifier">decls</code> = $1 
       <code class="identifier">needsCheck</code>, (<code class="identifier">SynTypeDefnKind</code>.<code class="identifier">Unspecified</code>, <code class="identifier">decls</code>) }

  | <code class="identifier">classOrInterfaceOrStruct</code> <code class="identifier">classSpfnBlock</code> <code class="identifier">END</code>
     { <code class="keyword">false</code>, ($1, $2) }

  | <code class="identifier">classOrInterfaceOrStruct</code> <code class="identifier">classSpfnBlock</code> <code class="identifier">recover</code> 
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedClassInterfaceOrStruct</code>())
       <code class="keyword">false</code>, ($1, $2) }

  | <code class="identifier">classOrInterfaceOrStruct</code> <code class="keyword">error</code> <code class="identifier">END</code>
     { <code class="comment">// silent recovery </code>
       <code class="keyword">false</code>, ($1, []) }


<code class="comment">/* The right-hand-side of an object type definition in a signature with no explicit kind */</code>
<code class="identifier">classSpfnBlockKindUnspecified</code>:
  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">classSpfnMembers</code> <code class="identifier">oblockend</code> 
     { <code class="keyword">true</code>, $2 }

  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">classSpfnMembers</code> <code class="identifier">recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileTypeSignature</code>())
       <code class="keyword">false</code>, $2 }

  <code class="comment">/* NOTE: these rules enable the non-#light syntax to omit the kind of a type. */</code>
  | <code class="identifier">BEGIN</code>  <code class="identifier">classSpfnBlock</code> <code class="identifier">END</code> 
     { <code class="keyword">false</code>, $2 }

  | <code class="identifier">BEGIN</code>  <code class="identifier">classSpfnBlock</code> <code class="identifier">recover</code>
     { <code class="keyword">false</code>, $2 }


<code class="comment">/* The right-hand-side of an object type definition in a signature */</code>
<code class="identifier">classSpfnBlock</code>:
  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">classSpfnMembers</code> <code class="identifier">oblockend</code> 
      { $2 }

  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">classSpfnMembers</code> <code class="identifier">recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileTypeSignature</code>())
        $2 }
  | <code class="identifier">classSpfnMembers</code> 
      { $1 }

<code class="comment">/* The members of an object type definition in a signature, possibly empty */</code>
<code class="identifier">classSpfnMembers</code>:  
  | <code class="identifier">classSpfnMembersAtLeastOne</code> 
     { $1 } 

  |  <code class="comment">/* EMPTY */</code>
     { [] }


<code class="comment">/* The members of an object type definition in a signature */</code>
<code class="identifier">classSpfnMembersAtLeastOne</code>:  
  | <code class="identifier">classMemberSpfn</code> <code class="identifier">opt_seps</code> <code class="identifier">classSpfnMembers</code> 
     { $1 :: $3 } 


<code class="comment">/* A object member in a signature */</code>
<code class="identifier">classMemberSpfn</code>:
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">memberSpecFlags</code> <code class="identifier">opt_inline</code> <code class="identifier">opt_access</code> <code class="identifier">nameop</code> <code class="identifier">opt_explicitValTyparDecls</code> <code class="identifier">COLON</code> <code class="identifier">topTypeWithTypeConstraints</code> <code class="identifier">classMemberSpfnGetSet</code> <code class="identifier">optLiteralValueSpfn</code>
     { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       <code class="keyword">let</code> <code class="identifier">isInline</code>, <code class="identifier">doc</code>, <code class="identifier">vis2</code>, <code class="identifier">id</code>, <code class="identifier">explicitValTyparDecls</code>, (<code class="identifier">ty</code>, <code class="identifier">arity</code>), <code class="identifier">optLiteralValue</code> = $4, <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 3), $5, $6, $7, $9, $11
       <code class="keyword">let</code> <code class="identifier">getSetRangeOpt</code>, <code class="identifier">getSet</code> = $10 
       <code class="keyword">let</code> <code class="identifier">getSetAdjuster</code> <code class="identifier">arity</code> = <code class="keyword">match</code> <code class="identifier">arity</code>, <code class="identifier">getSet</code> <code class="keyword">with</code> <code class="identifier">SynValInfo</code>([], <code class="identifier">_</code>), <code class="identifier">SynMemberKind</code>.<code class="identifier">Member</code> -&gt; <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertyGet</code> | <code class="identifier">_</code> -&gt; <code class="identifier">getSet</code>
       <code class="keyword">let</code> <code class="identifier">wholeRange</code> = 
           <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3 
           <code class="keyword">match</code> <code class="identifier">getSetRangeOpt</code> <code class="keyword">with</code> 
           | <code class="identifier">None</code> -&gt; <code class="identifier">unionRanges</code> <code class="identifier">m</code> <code class="identifier">ty</code>.<code class="identifier">Range</code>
           | <code class="identifier">Some</code> <code class="identifier">m2</code> -&gt; <code class="identifier">unionRanges</code> <code class="identifier">m</code> <code class="identifier">m2</code>
       <code class="keyword">let</code> <code class="identifier">valSpfn</code> = <code class="identifier">SynValSig</code>($1, <code class="identifier">id</code>, <code class="identifier">explicitValTyparDecls</code>, <code class="identifier">ty</code>, <code class="identifier">arity</code>, <code class="identifier">isInline</code>, <code class="keyword">false</code>, <code class="identifier">doc</code>, <code class="identifier">vis2</code>, <code class="identifier">optLiteralValue</code>, <code class="identifier">wholeRange</code>)
       <code class="keyword">let</code> <code class="identifier">_</code>, <code class="identifier">flags</code> = $3 
       <code class="identifier">SynMemberSig</code>.<code class="identifier">Member</code>(<code class="identifier">valSpfn</code>, <code class="identifier">flags</code> (<code class="identifier">getSetAdjuster</code> <code class="identifier">arity</code>), <code class="identifier">wholeRange</code>) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">interfaceMember</code> <code class="identifier">appType</code>  
     { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       <code class="identifier">SynMemberSig</code>.<code class="identifier">Interface</code> ($4, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) ($4).<code class="identifier">Range</code>) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">INHERIT</code> <code class="identifier">appType</code> 
     { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       <code class="identifier">SynMemberSig</code>.<code class="identifier">Inherit</code> ($4, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) ($4).<code class="identifier">Range</code>) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">VAL</code> <code class="identifier">fieldDecl</code> 
     { <code class="keyword">let</code> <code class="identifier">wholeRange</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4
       <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code> (<code class="identifier">Error</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code> (), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       <code class="keyword">let</code> <code class="identifier">fld</code> = $4 $1 <code class="keyword">false</code> <code class="identifier">wholeRange</code> 
       <code class="identifier">SynMemberSig</code>.<code class="identifier">ValField</code> (<code class="identifier">fld</code>, <code class="identifier">wholeRange</code>) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">STATIC</code> <code class="identifier">VAL</code> <code class="identifier">fieldDecl</code> 
     { <code class="keyword">let</code> <code class="identifier">wholeRange</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5
       <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code> (<code class="identifier">Error</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code> (), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       <code class="identifier">SynMemberSig</code>.<code class="identifier">ValField</code>($5 $1 <code class="keyword">true</code> <code class="identifier">wholeRange</code>, <code class="identifier">wholeRange</code>) }

  | <code class="identifier">opt_attributes</code>  <code class="identifier">opt_declVisibility</code> <code class="identifier">STATIC</code> <code class="identifier">typeKeyword</code> <code class="identifier">tyconSpfn</code> 
     { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       <code class="identifier">SynMemberSig</code>.<code class="identifier">NestedType</code>($5, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">NEW</code> <code class="identifier">COLON</code> <code class="identifier">topTypeWithTypeConstraints</code>  
     { <code class="keyword">let</code> <code class="identifier">vis</code>, <code class="identifier">doc</code>, (<code class="identifier">ty</code>, <code class="identifier">valSynInfo</code>) = $2, <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 3), $5 
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">ty</code>.<code class="identifier">Range</code> 
       <code class="keyword">let</code> <code class="identifier">isInline</code> = <code class="keyword">false</code> 
       <code class="keyword">let</code> <code class="identifier">valSpfn</code> = <code class="identifier">SynValSig</code> ($1, <code class="identifier">mkSynId</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) <code class="string">"new"</code>, <code class="identifier">noInferredTypars</code>, <code class="identifier">ty</code>, <code class="identifier">valSynInfo</code>, <code class="identifier">isInline</code>, <code class="keyword">false</code>, <code class="identifier">doc</code>, <code class="identifier">vis</code>, <code class="identifier">None</code>, <code class="identifier">m</code>)
       <code class="identifier">SynMemberSig</code>.<code class="identifier">Member</code>(<code class="identifier">valSpfn</code>, <code class="identifier">CtorMemberFlags</code>, <code class="identifier">m</code>) }


<code class="comment">/* The optional "with get, set" on a member in a signature */</code>
<code class="identifier">classMemberSpfnGetSet</code>:
  | <code class="comment">/* EMPTY */</code> 
    { <code class="identifier">None</code>, <code class="identifier">SynMemberKind</code>.<code class="identifier">Member</code> }

  | <code class="identifier">WITH</code> <code class="identifier">classMemberSpfnGetSetElements</code> 
    { <code class="identifier">Some</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2), $2 }

  | <code class="identifier">OWITH</code> <code class="identifier">classMemberSpfnGetSetElements</code> <code class="identifier">OEND</code>
    { <code class="identifier">Some</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2), $2 }

  | <code class="identifier">OWITH</code> <code class="identifier">classMemberSpfnGetSetElements</code> <code class="keyword">error</code>
    {  <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedWith</code>())
       <code class="identifier">Some</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2), $2 }


<code class="comment">/* The "get, set" on a property member in a signature */</code>
<code class="identifier">classMemberSpfnGetSetElements</code>:
  | <code class="identifier">nameop</code> 
    { (<code class="keyword">let</code> (<code class="identifier">id</code>:<code class="identifier">Ident</code>) = $1 
       <code class="keyword">if</code> <code class="identifier">id</code>.<code class="identifier">idText</code> = <code class="string">"get"</code> <code class="keyword">then</code> <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertyGet</code> 
       <code class="keyword">else</code> <code class="keyword">if</code> <code class="identifier">id</code>.<code class="identifier">idText</code> = <code class="string">"set"</code> <code class="keyword">then</code> <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertySet</code> 
       <code class="keyword">else</code> <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsGetOrSetRequired</code>())) }

  | <code class="identifier">nameop</code> <code class="identifier">COMMA</code> <code class="identifier">nameop</code>
    { <code class="keyword">let</code> (<code class="identifier">id</code>:<code class="identifier">Ident</code>) = $1 
      <code class="keyword">if</code> <code class="keyword">not</code> ((<code class="identifier">id</code>.<code class="identifier">idText</code> = <code class="string">"get"</code> &amp;&amp; $3.<code class="identifier">idText</code> = <code class="string">"set"</code>) ||
              (<code class="identifier">id</code>.<code class="identifier">idText</code> = <code class="string">"set"</code> &amp;&amp; $3.<code class="identifier">idText</code> = <code class="string">"get"</code>)) <code class="keyword">then</code> 
         <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsGetOrSetRequired</code>())
      <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertyGetSet</code> }

<code class="identifier">memberSpecFlags</code>: 
  | <code class="identifier">memberFlags</code> { $1 }  
  | <code class="identifier">ABSTRACT</code>        { (<code class="keyword">false</code>, <code class="identifier">AbstractMemberFlags</code>) }
  | <code class="identifier">ABSTRACT</code> <code class="identifier">MEMBER</code> { (<code class="keyword">false</code>, <code class="identifier">AbstractMemberFlags</code>) }


<code class="comment">/* Part of an exception definition in a signature file */</code>
<code class="identifier">exconSpfn</code>: 
  | <code class="identifier">exconCore</code> <code class="identifier">opt_classSpfn</code> 
     { <code class="identifier">SynExceptionSig</code>($1, $2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }
  

<code class="comment">/* The optional augmentation on a type definition in a signature */</code>
<code class="identifier">opt_classSpfn</code>: 
  | <code class="identifier">WITH</code> <code class="identifier">classSpfnBlock</code> <code class="identifier">declEnd</code> 
     { $2 } 

  | <code class="comment">/* EMPTY */</code>                   
     { [] }


<code class="comment">/*--------------------------------------------------------------------------*/</code>
<code class="comment">/* F# Language Proper - implementation files */</code>

<code class="comment">/* The contents of an implementation file */</code>
<code class="identifier">implementationFile</code>: 
  | <code class="identifier">fileNamespaceImpls</code> <code class="identifier">EOF</code> 
     { <code class="identifier">checkEndOfFileError</code> $2; $1 }

  | <code class="identifier">fileNamespaceImpls</code> <code class="keyword">error</code> <code class="identifier">EOF</code> 
     { $1 }

  <code class="comment">/* If this rule fires it is kind of catastrophic: error recovery yields no results! */</code>
  <code class="comment">/* This will result in NO intellisense for the file! Ideally we wouldn't need this rule */</code>
  <code class="comment">/* Note: the compiler assumes there is at least one "fragment", so an empty one is used (see 4488) */</code>
  | <code class="keyword">error</code> <code class="identifier">EOF</code> 
     { <code class="keyword">let</code> <code class="identifier">emptyImplFileFrag</code> = <code class="identifier">ParsedImplFileFragment</code>.<code class="identifier">AnonModule</code>([], <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="keyword">in</code> 
       <code class="identifier">ParsedImplFile</code> ([], [<code class="identifier">emptyImplFileFrag</code>]) }


<code class="comment">/* The sequence of namespace definitions or a single module definition that makes up an implementation file */</code>
<code class="identifier">fileNamespaceImpls</code>: 
  | <code class="identifier">fileModuleImpl</code>   
      { <code class="identifier">ParsedImplFile</code> ([], [ ($1 (<code class="keyword">false</code>, [], <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>)) ]) }

  | <code class="identifier">fileModuleImpl</code> <code class="identifier">fileNamespaceImplList</code> 
      { <code class="comment">// If there are namespaces, the first fileModuleImpl may only contain # directives </code>
        <code class="keyword">let</code> <code class="identifier">decls</code> = 
            <code class="keyword">match</code> ($1 (<code class="keyword">false</code>, [], <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>)) <code class="keyword">with</code> 
            | <code class="identifier">ParsedImplFileFragment</code>.<code class="identifier">AnonModule</code>(<code class="identifier">decls</code>, <code class="identifier">m</code>) -&gt; <code class="identifier">decls</code>  
            | <code class="identifier">ParsedImplFileFragment</code>.<code class="identifier">NamespaceFragment</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">decls</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">decls</code> 
            | <code class="identifier">ParsedImplFileFragment</code>.<code class="identifier">NamedModule</code>(<code class="identifier">SynModuleOrNamespace</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">m</code>)) -&gt;
                <code class="identifier">raiseParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsOnlyHashDirectivesAllowed</code>())
        <code class="keyword">let</code> <code class="identifier">decls</code> = 
            <code class="identifier">decls</code> |&gt; <code class="identifier">List</code>.<code class="identifier">collect</code> (<code class="keyword">function</code> 
                | (<code class="identifier">SynModuleDecl</code>.<code class="identifier">HashDirective</code> (<code class="identifier">hd</code>, <code class="identifier">_</code>)) -&gt; [<code class="identifier">hd</code>]
                | <code class="identifier">d</code> -&gt;  
                     <code class="identifier">reportParseErrorAt</code> <code class="identifier">d</code>.<code class="identifier">Range</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsOnlyHashDirectivesAllowed</code>())
                     [])
        <code class="identifier">ParsedImplFile</code> (<code class="identifier">decls</code>, $2) } 


<code class="comment">/* The sequence of namespace definitions that can make up an implementation file */</code>
<code class="identifier">fileNamespaceImplList</code>: 
  | <code class="identifier">fileNamespaceImpl</code> <code class="identifier">fileNamespaceImplList</code> 
     { $1 :: $2 }

  | <code class="identifier">fileNamespaceImpl</code> 
     { [$1] }


<code class="comment">/* A single namespace definition in an implementation file */</code>
<code class="identifier">fileNamespaceImpl</code>: 
  | <code class="identifier">namespaceIntro</code> <code class="identifier">deprecated_opt_equals</code> <code class="identifier">fileModuleImpl</code> 
     { <code class="keyword">let</code> <code class="identifier">isRec</code>, <code class="identifier">path</code>, <code class="identifier">xml</code> = $1 <code class="keyword">in</code> ($3 (<code class="identifier">isRec</code>, <code class="identifier">path</code>, <code class="identifier">xml</code>)) }


<code class="comment">/* A single module definition in an implementation file */</code>
<code class="identifier">fileModuleImpl</code>: 
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">moduleIntro</code> <code class="identifier">moduleDefnsOrExprPossiblyEmptyOrBlock</code>
    { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
      <code class="keyword">let</code> <code class="identifier">m2</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3
      <code class="keyword">let</code> <code class="identifier">m</code> = (<code class="identifier">m2</code>, $4) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> <code class="identifier">modu</code> -&gt; <code class="identifier">modu</code>.<code class="identifier">Range</code>)
      <code class="keyword">let</code> <code class="identifier">isRec2</code>, <code class="identifier">path2</code>, <code class="identifier">xml</code>, <code class="identifier">vis</code> = $3 
      (<code class="keyword">fun</code> (<code class="identifier">isRec</code>, <code class="identifier">path</code>, <code class="identifier">_</code>) -&gt; 
        <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> <code class="identifier">path</code>) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsNamespaceOrModuleNotBoth</code>(), <code class="identifier">m2</code>))
        <code class="keyword">let</code> <code class="identifier">lid</code> = <code class="identifier">path</code>@<code class="identifier">path2</code> 
        <code class="identifier">ParsedImplFileFragment</code>.<code class="identifier">NamedModule</code>(<code class="identifier">SynModuleOrNamespace</code>(<code class="identifier">lid</code>, (<code class="identifier">isRec</code> || <code class="identifier">isRec2</code>), <code class="identifier">SynModuleOrNamespaceKind</code>.<code class="identifier">NamedModule</code>, $4, <code class="identifier">xml</code>, $1, <code class="identifier">vis</code>, <code class="identifier">m</code>))) }

  | <code class="identifier">moduleDefnsOrExprPossiblyEmptyOrBlock</code> 
    { <code class="keyword">let</code> <code class="identifier">m</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) 
      (<code class="keyword">fun</code> (<code class="identifier">isRec</code>, <code class="identifier">path</code>, <code class="identifier">xml</code>) -&gt; 
        <code class="keyword">match</code> <code class="identifier">path</code> <code class="keyword">with</code> 
        | [] -&gt; <code class="identifier">ParsedImplFileFragment</code>.<code class="identifier">AnonModule</code>($1, <code class="identifier">m</code>)  
        | <code class="identifier">_</code> -&gt;
            <code class="keyword">let</code> <code class="identifier">lastDeclRange</code> = <code class="identifier">List</code>.<code class="identifier">tryLast</code> $1 |&gt; <code class="identifier">Option</code>.<code class="identifier">map</code> (<code class="keyword">fun</code> <code class="identifier">decl</code> -&gt; <code class="identifier">decl</code>.<code class="identifier">Range</code>) |&gt; <code class="identifier">Option</code>.<code class="identifier">defaultValue</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
            <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">mkRange</code> <code class="identifier">lastDeclRange</code>.<code class="identifier">FileName</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>).<code class="identifier">Start</code> <code class="identifier">lastDeclRange</code>.<code class="identifier">End</code>
            <code class="identifier">ParsedImplFileFragment</code>.<code class="identifier">NamespaceFragment</code>(<code class="identifier">path</code>, <code class="identifier">isRec</code>, <code class="identifier">SynModuleOrNamespaceKind</code>.<code class="identifier">DeclaredNamespace</code>, $1, <code class="identifier">xml</code>, [], <code class="identifier">m</code>)) } 


<code class="comment">/* A collection/block of definitions or expressions making up a module or namespace, possibly empty */</code>
<code class="identifier">moduleDefnsOrExprPossiblyEmptyOrBlock</code>:
  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">moduleDefnsOrExprPossiblyEmpty</code> <code class="identifier">oblockend</code> <code class="identifier">opt_OBLOCKSEP</code>
     { $2 }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">moduleDefnsOrExprPossiblyEmpty</code> <code class="identifier">recover</code> 
     { <code class="comment">// The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error</code>
       <code class="comment">// reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnClosedBlockInHashLight())   </code>
       $2 }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="keyword">error</code> <code class="identifier">oblockend</code>                
     { []  }

  | <code class="identifier">moduleDefnsOrExprPossiblyEmpty</code>
     { $1 }


<code class="comment">/* A collection of definitions or expressions making up a module or namespace, possibly empty */</code>
<code class="identifier">moduleDefnsOrExprPossiblyEmpty</code>:
  | <code class="identifier">moduleDefnsOrExpr</code>
     { $1 }

  | <code class="comment">/* EMPTY */</code>
     { [] }


<code class="comment">/* A collection of definitions or expressions making up a module or namespace */</code>
<code class="comment">/* A naked expression is only allowed at the start of a module/file, or straight after a topSeparators */</code>
<code class="identifier">moduleDefnsOrExpr</code>:
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">declExpr</code> <code class="identifier">topSeparators</code> <code class="identifier">moduleDefnsOrExpr</code> 
      { <code class="keyword">match</code> $2 <code class="keyword">with</code>
        | <code class="identifier">Some</code> <code class="identifier">vis</code> -&gt; <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedVisibilityDeclaration</code>(<code class="identifier">vis</code>.<code class="identifier">ToString</code>()), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3))
        | <code class="identifier">_</code> -&gt; ()
        <code class="keyword">let</code> <code class="identifier">attrDecls</code> = <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">Attributes</code> ($1, <code class="identifier">rangeOfNonNilAttrs</code> $1) ] <code class="keyword">else</code> [] 
        <code class="identifier">attrDecls</code> @ <code class="identifier">mkSynDoDecl</code> ($3) :: $5 }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">declExpr</code> <code class="identifier">topSeparators</code>
      { <code class="keyword">match</code> $2 <code class="keyword">with</code>
        | <code class="identifier">Some</code> <code class="identifier">vis</code> -&gt; <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedVisibilityDeclaration</code>(<code class="identifier">vis</code>.<code class="identifier">ToString</code>()), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3))
        | <code class="identifier">_</code> -&gt; ()
        <code class="keyword">let</code> <code class="identifier">attrDecls</code> = <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">Attributes</code> ($1, <code class="identifier">rangeOfNonNilAttrs</code> $1) ] <code class="keyword">else</code> [] 
        <code class="identifier">attrDecls</code> @ [ <code class="identifier">mkSynDoDecl</code>($3) ] }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">declExpr</code>
      { <code class="keyword">match</code> $2 <code class="keyword">with</code>
        | <code class="identifier">Some</code> <code class="identifier">vis</code> -&gt; <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedVisibilityDeclaration</code>(<code class="identifier">vis</code>.<code class="identifier">ToString</code>()), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3))
        | <code class="identifier">_</code> -&gt; ()
        <code class="keyword">let</code> <code class="identifier">attrDecls</code> = <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">Attributes</code> ($1, <code class="identifier">rangeOfNonNilAttrs</code> $1) ] <code class="keyword">else</code> [] 
        <code class="identifier">attrDecls</code> @ [ <code class="identifier">mkSynDoDecl</code>($3) ] }

  | <code class="identifier">moduleDefns</code> 
      { $1 } 

  | <code class="identifier">opt_attributes</code> <code class="keyword">error</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">Attributes</code> ($1, <code class="identifier">rangeOfNonNilAttrs</code> $1) ] <code class="keyword">else</code> [] }


<code class="comment">/* A sequence of definitions in a namespace or module */</code>
<code class="identifier">moduleDefns</code>:
  | <code class="identifier">moduleDefnOrDirective</code> <code class="identifier">moduleDefns</code> 
      { $1 @ $2 } 

  | <code class="identifier">moduleDefnOrDirective</code> <code class="identifier">topSeparators</code> <code class="identifier">moduleDefnsOrExpr</code> 
      { $1 @ $3 } 

  | <code class="identifier">moduleDefnOrDirective</code>
      { $1 }

  | <code class="identifier">moduleDefnOrDirective</code> <code class="identifier">topSeparators</code>
      { $1 }

  | <code class="keyword">error</code> <code class="identifier">topSeparators</code> <code class="identifier">moduleDefnsOrExpr</code> 
      { $3 } 


<code class="comment">/* A single definition in a namespace, module or F# Interactive file*/</code>
<code class="identifier">moduleDefnOrDirective</code>:
  | <code class="identifier">moduleDefn</code> 
      { $1  } 

  | <code class="identifier">hashDirective</code> 
      { [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">HashDirective</code> ($1, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 1) ] } 


<code class="comment">/* A single definition in a namespace, module or interaction. */</code>
<code class="comment">/* This is used by both "fsi" interactions and "source file" fragments defined by moduleDefns */</code>
<code class="identifier">moduleDefn</code>:

  <code class="comment">/* 'let' definitions in non-#light*/</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">defnBindings</code>                   <code class="keyword">%prec</code> <code class="identifier">decl_let</code> 
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="identifier">parseState</code>.<code class="identifier">ResetSynArgNameGenerator</code>()
        <code class="keyword">let</code> (<code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">mWhole</code>)) = $3 
        <code class="identifier">mkDefnBindings</code> (<code class="identifier">mWhole</code>, $3, $1, $2, <code class="identifier">mWhole</code>)  }

  <code class="comment">/* 'let' or 'do' definitions in #light */</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">hardwhiteLetBindings</code>          <code class="keyword">%prec</code> <code class="identifier">decl_let</code> 
      { <code class="keyword">let</code> <code class="identifier">hwlb</code>, <code class="identifier">m</code> = $3
        <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="identifier">parseState</code>.<code class="identifier">ResetSynArgNameGenerator</code>()
        <code class="identifier">mkDefnBindings</code> (<code class="identifier">m</code>, <code class="identifier">hwlb</code>, $1, $2, <code class="identifier">m</code>)  }

  <code class="comment">/* 'do' definitions in non-#light*/</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">doBinding</code> <code class="keyword">%prec</code> <code class="identifier">decl_let</code> 
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> <code class="identifier">mWhole</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3 
        <code class="identifier">mkDefnBindings</code> (<code class="identifier">mWhole</code>, $3, $1, $2, <code class="identifier">mWhole</code>) }
  
  <code class="comment">/* 'type' definitions */</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">typeKeyword</code> <code class="identifier">tyconDefn</code> <code class="identifier">tyconDefnList</code>
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> (<code class="identifier">SynTypeDefn</code>(<code class="identifier">SynComponentInfo</code>(<code class="identifier">cas</code>, <code class="identifier">a</code>, <code class="identifier">cs</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">d2</code>, <code class="identifier">d3</code>), <code class="identifier">e</code>, <code class="identifier">f</code>, <code class="identifier">g</code>, <code class="identifier">h</code>)) = $4
        <code class="keyword">let</code> <code class="identifier">tc</code> = (<code class="identifier">SynTypeDefn</code>(<code class="identifier">SynComponentInfo</code>($1@<code class="identifier">cas</code>, <code class="identifier">a</code>, <code class="identifier">cs</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">d2</code>, <code class="identifier">d3</code>), <code class="identifier">e</code>, <code class="identifier">f</code>, <code class="identifier">g</code>, <code class="identifier">h</code>))
        <code class="keyword">let</code> <code class="identifier">types</code> = <code class="identifier">tc</code> :: $5
        [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">Types</code>(<code class="identifier">types</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3, <code class="identifier">types</code>) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> <code class="identifier">t</code> -&gt; <code class="identifier">t</code>.<code class="identifier">Range</code>) ) ] }

  <code class="comment">/* 'exception' definitions */</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">exconDefn</code>
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> (<code class="identifier">SynExceptionDefn</code>(<code class="identifier">SynExceptionDefnRepr</code>(<code class="identifier">cas</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">d2</code>), <code class="identifier">e</code>, <code class="identifier">f</code>)) = $3 
        <code class="keyword">let</code> <code class="identifier">f</code> = (<code class="identifier">f</code>, $1) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> <code class="identifier">a</code> -&gt; <code class="identifier">a</code>.<code class="identifier">Range</code>)
        <code class="keyword">let</code> <code class="identifier">ec</code> = (<code class="identifier">SynExceptionDefn</code>(<code class="identifier">SynExceptionDefnRepr</code>($1@<code class="identifier">cas</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">d2</code>), <code class="identifier">e</code>, <code class="identifier">f</code>)) 
        [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">Exception</code>(<code class="identifier">ec</code>, <code class="identifier">f</code>) ] }

  <code class="comment">/* 'module' definitions */</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">moduleIntro</code> <code class="identifier">EQUALS</code>  <code class="identifier">namedModuleDefnBlock</code>
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> <code class="identifier">attribs</code>, (<code class="identifier">isRec</code>, <code class="identifier">path</code>, <code class="identifier">xml</code>, <code class="identifier">vis</code>) = $1, $3 
        <code class="keyword">match</code> $5 <code class="keyword">with</code> 
        | <code class="identifier">Choice1Of2</code> <code class="identifier">eqn</code> -&gt; 
            <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
            <code class="keyword">if</code> <code class="identifier">isRec</code> <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidUseOfRec</code>())
            <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isSingleton</code> <code class="identifier">path</code>) <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsModuleAbbreviationMustBeSimpleName</code>())
            <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIgnoreAttributesOnModuleAbbreviation</code>())
            <code class="keyword">match</code> <code class="identifier">vis</code> <code class="keyword">with</code>
            | <code class="identifier">Some</code> <code class="identifier">vis</code> -&gt; <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate</code>(<code class="identifier">vis</code>.<code class="identifier">ToString</code>()))
            | <code class="identifier">_</code> -&gt; ()
            [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">ModuleAbbrev</code>(<code class="identifier">List</code>.<code class="identifier">head</code> <code class="identifier">path</code>, <code class="identifier">eqn</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3, <code class="identifier">eqn</code>) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> <code class="identifier">id</code> -&gt; <code class="identifier">id</code>.<code class="identifier">idRange</code>) ) ]
        | <code class="identifier">Choice2Of2</code> <code class="identifier">def</code> -&gt; 
            <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isSingleton</code> <code class="identifier">path</code>) <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsModuleAbbreviationMustBeSimpleName</code>())
            <code class="keyword">let</code> <code class="identifier">info</code> = <code class="identifier">SynComponentInfo</code>(<code class="identifier">attribs</code>, [], [], <code class="identifier">path</code>, <code class="identifier">xml</code>, <code class="keyword">false</code>, <code class="identifier">vis</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3)
            [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">NestedModule</code>(<code class="identifier">info</code>, <code class="identifier">isRec</code>, <code class="identifier">def</code>, <code class="keyword">false</code>, (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4, <code class="identifier">def</code>) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> <code class="identifier">d</code> -&gt; <code class="identifier">d</code>.<code class="identifier">Range</code>) ) ] }

  <code class="comment">/* unattached custom attributes */</code>
  | <code class="identifier">attributes</code> <code class="identifier">recover</code>
      { <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAttributeOnIncompleteCode</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
        [] }

  <code class="comment">/* 'open' declarations */</code>
  | <code class="identifier">openDecl</code>
      { [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">Open</code>($1, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)) ] }

<code class="identifier">openDecl</code>:
  <code class="comment">/* 'open' declarations */</code>
  | <code class="identifier">OPEN</code> <code class="identifier">path</code>
      { <code class="identifier">SynOpenDeclTarget</code>.<code class="identifier">ModuleOrNamespace</code>($2.<code class="identifier">Lid</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)) }

  | <code class="identifier">OPEN</code> <code class="identifier">typeKeyword</code> <code class="identifier">appType</code>
      { <code class="identifier">SynOpenDeclTarget</code>.<code class="identifier">Type</code>($3, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3)) }

<code class="comment">/* The right-hand-side of a module abbreviation definition */</code> 
<code class="comment">/* This occurs on the right of a module abbreviation (#light encloses the r.h.s. with OBLOCKBEGIN/OBLOCKEND) */</code>
<code class="comment">/* We don't use it in signature files */</code>
<code class="identifier">namedModuleAbbrevBlock</code>:
  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">path</code> <code class="identifier">oblockend</code> 
     { $2.<code class="identifier">Lid</code> }

  | <code class="identifier">path</code> 
     { $1.<code class="identifier">Lid</code>  }
       

<code class="comment">/* The right-hand-side of a module definition */</code> 
<code class="identifier">namedModuleDefnBlock</code>:
  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">wrappedNamedModuleDefn</code> <code class="identifier">oblockend</code> 
     { <code class="identifier">Choice2Of2</code> $2  }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">wrappedNamedModuleDefn</code> <code class="identifier">recover</code>
     { <code class="comment">// The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error</code>
       <code class="identifier">Choice2Of2</code> $2 }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">moduleDefnsOrExpr</code> <code class="identifier">oblockend</code> 
       { <code class="comment">// There is an ambiguity here </code>
         <code class="comment">// In particular, consider the following two:</code>
         <code class="comment">//</code>
         <code class="comment">// module M2 = </code>
         <code class="comment">//    System.DateTime.Now</code>
         <code class="comment">// module M2 = </code>
         <code class="comment">//    Microsoft.FSharp.Core.List</code>
         <code class="comment">// The second is a module abbreviation, the first a module containing a single expression.</code>
         <code class="comment">// The resolution is in favour of the module abbreviation, i.e. anything of the form </code>
         <code class="comment">//    module M2 = ID.ID.ID.ID</code>
         <code class="comment">// will be taken as a module abbreviation, regardles of the identifiers themselves.</code>
         <code class="comment">//</code>
         <code class="comment">// This is similar to the ambiguitty between </code>
         <code class="comment">//    type X = int</code>
         <code class="comment">// and </code>
         <code class="comment">//    type X = OneValue</code>
         <code class="comment">// However in that case we do use type name lookup to make the resolution.</code>

         <code class="keyword">match</code> $2 <code class="keyword">with</code> 
         | [ <code class="identifier">SynModuleDecl</code>.<code class="identifier">DoExpr</code> (<code class="identifier">_</code>, <code class="identifier">LongOrSingleIdent</code>(<code class="keyword">false</code>, <code class="identifier">LongIdentWithDots</code>(<code class="identifier">path</code>, <code class="identifier">_</code>), <code class="identifier">None</code>, <code class="identifier">_</code>), <code class="identifier">_</code>) ] -&gt; 
             <code class="identifier">Choice1Of2</code>  <code class="identifier">path</code>
         | <code class="identifier">_</code> -&gt; 
             <code class="identifier">Choice2Of2</code> $2 
       }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">moduleDefnsOrExpr</code> <code class="identifier">recover</code> 
     { <code class="comment">// The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error</code>
       <code class="comment">// reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnClosedBlockInHashLight())   </code>
       <code class="identifier">Choice2Of2</code> $2 }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="keyword">error</code> <code class="identifier">oblockend</code>                
     { <code class="identifier">Choice2Of2</code> [] }

  | <code class="identifier">wrappedNamedModuleDefn</code> 
     { <code class="identifier">Choice2Of2</code> $1 }

  | <code class="identifier">path</code> 
     { <code class="identifier">Choice1Of2</code> $1.<code class="identifier">Lid</code> }


<code class="comment">/* A module definition that inccludes a 'begin'...'end' (rarely used in F# with #light syntax) */</code> 
<code class="identifier">wrappedNamedModuleDefn</code>:
  | <code class="identifier">structOrBegin</code> <code class="identifier">moduleDefnsOrExprPossiblyEmpty</code> <code class="identifier">END</code> 
     { $2 }

  | <code class="identifier">structOrBegin</code> <code class="identifier">moduleDefnsOrExprPossiblyEmpty</code> <code class="identifier">recover</code> 
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBeginOrStruct</code>())  
       $2 }

  | <code class="identifier">structOrBegin</code> <code class="keyword">error</code> <code class="identifier">END</code>                      
     { [] }


<code class="identifier">tyconDefnAugmentation</code>: 
  | <code class="identifier">WITH</code> <code class="identifier">classDefnBlock</code> <code class="identifier">declEnd</code>
     { $2 }


<code class="comment">/* An optional list of custom attributes */</code>
<code class="identifier">opt_attributes</code>:
  | <code class="identifier">attributes</code>                                
      { $1 }

  |            <code class="keyword">%prec</code> <code class="identifier">prec_opt_attributes_none</code> 
      { [] }

<code class="comment">/* A list of sets of custom attributes */</code>
<code class="identifier">attributes</code>: 
  | <code class="identifier">attributeList</code>                     
     { $1 }

  | <code class="identifier">attributeList</code> <code class="identifier">attributes</code>
     { $1 @ $2 }


<code class="comment">/* One set of custom attributes, including [&lt; ... &gt;] */</code>
<code class="identifier">attributeList</code>:
  | <code class="identifier">LBRACK_LESS</code> <code class="identifier">attributeListElements</code> <code class="identifier">opt_seps</code> <code class="identifier">GREATER_RBRACK</code> <code class="identifier">opt_OBLOCKSEP</code>
      { <code class="identifier">mkAttributeList</code> $2 (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4) }

  | <code class="identifier">LBRACK_LESS</code> <code class="keyword">error</code> <code class="identifier">GREATER_RBRACK</code> <code class="identifier">opt_OBLOCKSEP</code>
      { <code class="identifier">mkAttributeList</code> [] (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

  | <code class="identifier">LBRACK_LESS</code> <code class="identifier">attributeListElements</code> <code class="identifier">opt_seps</code> <code class="identifier">ends_coming_soon_or_recover</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> $4 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedLBrackLess</code>())
        <code class="identifier">mkAttributeList</code> $2 (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2) }

  | <code class="identifier">LBRACK_LESS</code> <code class="identifier">ends_coming_soon_or_recover</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> $2 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedLBrackLess</code>())
        <code class="identifier">mkAttributeList</code> [] (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) }


<code class="comment">/* One set of custom attributes, not including [&lt; ... &gt;] */</code>
<code class="identifier">attributeListElements</code>: 
  | <code class="identifier">attribute</code>                     
     { [$1] }

  | <code class="identifier">attributeListElements</code> <code class="identifier">seps</code> <code class="identifier">attribute</code> 
     { $1 @ [$3] }


<code class="comment">/* One custom attribute */</code>
<code class="identifier">attribute</code>:
  <code class="comment">/* A custom attribute */</code>
  | <code class="identifier">path</code> <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="identifier">opt_atomicExprAfterType</code> 
     { <code class="keyword">let</code> <code class="identifier">arg</code> = <code class="keyword">match</code> $3 <code class="keyword">with</code> <code class="identifier">None</code> -&gt; <code class="identifier">mkSynUnit</code> $1.<code class="identifier">Range</code> | <code class="identifier">Some</code> <code class="identifier">e</code> -&gt; <code class="identifier">e</code> 
       ({ <code class="identifier">TypeName</code>=$1; <code class="identifier">ArgExpr</code>=<code class="identifier">arg</code>; <code class="identifier">Target</code>=<code class="identifier">None</code>; <code class="identifier">AppliesToGetterAndSetter</code>=<code class="keyword">false</code>; <code class="identifier">Range</code>=$1.<code class="identifier">Range</code> } : <code class="identifier">SynAttribute</code>) }

  <code class="comment">/* A custom attribute with an attribute target */</code>
  | <code class="identifier">attributeTarget</code> <code class="identifier">path</code> <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="identifier">opt_atomicExprAfterType</code> 
     { <code class="keyword">let</code> <code class="identifier">arg</code> = <code class="keyword">match</code> $4 <code class="keyword">with</code> <code class="identifier">None</code> -&gt; <code class="identifier">mkSynUnit</code> $2.<code class="identifier">Range</code> | <code class="identifier">Some</code> <code class="identifier">e</code> -&gt; <code class="identifier">e</code> 
       ({ <code class="identifier">TypeName</code>=$2; <code class="identifier">ArgExpr</code>=<code class="identifier">arg</code>; <code class="identifier">Target</code>=$1; <code class="identifier">AppliesToGetterAndSetter</code>=<code class="keyword">false</code>; <code class="identifier">Range</code>=$2.<code class="identifier">Range</code> } : <code class="identifier">SynAttribute</code>) }

  <code class="comment">/* A custom attribute with an attribute target */</code>
  | <code class="identifier">attributeTarget</code> <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">path</code> <code class="identifier">oblockend</code> <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="identifier">opt_atomicExprAfterType</code> 
     { <code class="keyword">let</code> <code class="identifier">arg</code> = <code class="keyword">match</code> $6 <code class="keyword">with</code> <code class="identifier">None</code> -&gt; <code class="identifier">mkSynUnit</code> $3.<code class="identifier">Range</code> | <code class="identifier">Some</code> <code class="identifier">e</code> -&gt; <code class="identifier">e</code> 
       ({ <code class="identifier">TypeName</code>=$3; <code class="identifier">ArgExpr</code>=<code class="identifier">arg</code>; <code class="identifier">Target</code>=$1; <code class="identifier">AppliesToGetterAndSetter</code>=<code class="keyword">false</code>; <code class="identifier">Range</code>=$3.<code class="identifier">Range</code> } : <code class="identifier">SynAttribute</code>) }


<code class="comment">/* The target of a custom attribute */</code>
<code class="identifier">attributeTarget</code>: 
  | <code class="identifier">moduleKeyword</code> <code class="identifier">COLON</code> 
      { <code class="identifier">Some</code>(<code class="identifier">ident</code>(<code class="string">"module"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))) } 

  | <code class="identifier">typeKeyword</code> <code class="identifier">COLON</code> 
      { <code class="identifier">Some</code>(<code class="identifier">ident</code>(<code class="string">"type"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))) } 

  | <code class="identifier">ident</code> <code class="identifier">COLON</code> { <code class="identifier">Some</code>($1) } 

  <code class="comment">/* return */</code>
  | <code class="identifier">YIELD</code> <code class="identifier">COLON</code> 
      { <code class="keyword">if</code> $1 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSyntaxError</code>())
        <code class="identifier">Some</code>(<code class="identifier">ident</code>(<code class="string">"return"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))) } 

<code class="comment">/* Flags on a member */</code>
<code class="identifier">memberFlags</code>: 
  | <code class="identifier">STATIC</code> <code class="identifier">MEMBER</code>   { (<code class="keyword">true</code>, <code class="identifier">StaticMemberFlags</code>) }  
  | <code class="identifier">MEMBER</code>          { (<code class="keyword">false</code>, <code class="identifier">NonVirtualMemberFlags</code>) }
  | <code class="identifier">OVERRIDE</code>        { (<code class="keyword">false</code>, <code class="identifier">OverrideMemberFlags</code>) }
  | <code class="identifier">DEFAULT</code>        { (<code class="keyword">false</code>, <code class="identifier">OverrideMemberFlags</code>) }

<code class="comment">/* The name of a type in a signature or implementation, possibly with type parameters and constraints */</code>
<code class="identifier">typeNameInfo</code>: 
  | <code class="identifier">opt_attributes</code> <code class="identifier">tyconNameAndTyparDecls</code> <code class="identifier">opt_typeConstraints</code>
     { <code class="keyword">let</code> <code class="identifier">typars</code>, <code class="identifier">lid</code>, <code class="identifier">fixity</code>, <code class="identifier">tpcs1</code>, <code class="identifier">vis</code>, <code class="identifier">xmlDoc</code> = $2 
       <code class="keyword">let</code> <code class="identifier">tpcs2</code> = $3 
       <code class="identifier">SynComponentInfo</code>($1, <code class="identifier">typars</code>, (<code class="identifier">tpcs1</code> @ <code class="identifier">tpcs2</code>), <code class="identifier">lid</code>, <code class="identifier">xmlDoc</code>, <code class="identifier">fixity</code>, <code class="identifier">vis</code>, <code class="identifier">rangeOfLid</code> <code class="identifier">lid</code>)  }

<code class="comment">/* Part of a set of type definitions */</code>
<code class="identifier">tyconDefnList</code>:  
  | <code class="identifier">AND</code> <code class="identifier">tyconDefn</code> <code class="identifier">tyconDefnList</code> 
     { $2 :: $3 } 
  |                             
     { [] }

<code class="comment">/* A type definition */</code>
<code class="identifier">tyconDefn</code>: 
  | <code class="identifier">typeNameInfo</code> 
     { <code class="identifier">SynTypeDefn</code>($1, <code class="identifier">SynTypeDefnRepr</code>.<code class="identifier">Simple</code>(<code class="identifier">SynTypeDefnSimpleRepr</code>.<code class="identifier">None</code>($1.<code class="identifier">Range</code>), $1.<code class="identifier">Range</code>), [], <code class="identifier">None</code>, $1.<code class="identifier">Range</code>) }

  | <code class="identifier">typeNameInfo</code> <code class="identifier">opt_equals</code> <code class="identifier">tyconDefnRhsBlock</code> 
     { <code class="keyword">if</code> <code class="keyword">not</code> $2 <code class="keyword">then</code> (
            <code class="keyword">let</code> (<code class="identifier">SynComponentInfo</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">lid</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>)) = $1 
            <code class="comment">// While the spec doesn't allow long idents here, the parser doesn't enforce this, so take one ident</code>
            <code class="keyword">let</code> <code class="identifier">typeNameId</code> = <code class="identifier">List</code>.<code class="identifier">last</code> <code class="identifier">lid</code>
            <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEqualsMissingInTypeDefinition</code>(<code class="identifier">typeNameId</code>.<code class="identifier">ToString</code>()))
       )
       <code class="keyword">let</code> <code class="identifier">nameRange</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       <code class="keyword">let</code> (<code class="identifier">tcDefRepr</code>:<code class="identifier">SynTypeDefnRepr</code>), <code class="identifier">members</code> = $3 <code class="identifier">nameRange</code>
       <code class="keyword">let</code> <code class="identifier">declRange</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">tcDefRepr</code>.<code class="identifier">Range</code>
       <code class="keyword">let</code> <code class="identifier">mWhole</code> = (<code class="identifier">declRange</code>, <code class="identifier">members</code>) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> (<code class="identifier">mem</code>:<code class="identifier">SynMemberDefn</code>) -&gt; <code class="identifier">mem</code>.<code class="identifier">Range</code>)    
       <code class="identifier">SynTypeDefn</code>($1, <code class="identifier">tcDefRepr</code>, <code class="identifier">members</code>, <code class="identifier">None</code>, <code class="identifier">mWhole</code>) }

  | <code class="identifier">typeNameInfo</code> <code class="identifier">tyconDefnAugmentation</code>
     { <code class="keyword">let</code> <code class="identifier">m</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, $2) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> <code class="identifier">mem</code> -&gt; <code class="identifier">mem</code>.<code class="identifier">Range</code>)
       <code class="identifier">SynTypeDefn</code>($1, <code class="identifier">SynTypeDefnRepr</code>.<code class="identifier">ObjectModel</code>(<code class="identifier">SynTypeDefnKind</code>.<code class="identifier">Augmentation</code>, [], <code class="identifier">m</code>), $2, <code class="identifier">None</code>, <code class="identifier">m</code>) }

  | <code class="identifier">typeNameInfo</code> <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">opt_HIGH_PRECEDENCE_APP</code>  <code class="identifier">simplePatterns</code> <code class="identifier">optAsSpec</code> <code class="identifier">EQUALS</code> <code class="identifier">tyconDefnRhsBlock</code>
     { <code class="keyword">let</code> <code class="identifier">vis</code>, <code class="identifier">spats</code>, <code class="identifier">az</code> = $3, $5, $6
       <code class="keyword">let</code> <code class="identifier">nameRange</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       <code class="keyword">let</code> (<code class="identifier">tcDefRepr</code>, <code class="identifier">members</code>) = $8 <code class="identifier">nameRange</code>
       <code class="keyword">let</code> (<code class="identifier">SynComponentInfo</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">lid</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>)) = $1 
       <code class="comment">// Gets the XML doc comments prior to the implicit constructor</code>
       <code class="keyword">let</code> <code class="identifier">xmlDoc</code> = <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 5)
       <code class="keyword">let</code> <code class="identifier">memberCtorPattern</code> = <code class="identifier">SynMemberDefn</code>.<code class="identifier">ImplicitCtor</code> (<code class="identifier">vis</code>, $2, <code class="identifier">spats</code>, <code class="identifier">az</code>, <code class="identifier">xmlDoc</code>, <code class="identifier">rangeOfLid</code> <code class="identifier">lid</code>)
       <code class="keyword">let</code> <code class="identifier">tcDefRepr</code> = 
         <code class="keyword">match</code> <code class="identifier">tcDefRepr</code> <code class="keyword">with</code>
         | <code class="identifier">SynTypeDefnRepr</code>.<code class="identifier">ObjectModel</code> (<code class="identifier">k</code>, <code class="identifier">cspec</code>, <code class="identifier">m</code>) -&gt; <code class="identifier">SynTypeDefnRepr</code>.<code class="identifier">ObjectModel</code> (<code class="identifier">k</code>, <code class="identifier">memberCtorPattern</code> :: <code class="identifier">cspec</code>, <code class="identifier">m</code>)
         | <code class="identifier">_</code> -&gt; <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsOnlyClassCanTakeValueArguments</code>()); <code class="identifier">tcDefRepr</code>
       <code class="keyword">let</code> <code class="identifier">declRange</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">tcDefRepr</code>.<code class="identifier">Range</code>
       <code class="keyword">let</code> <code class="identifier">mWhole</code> = (<code class="identifier">declRange</code>, <code class="identifier">members</code>) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> (<code class="identifier">mem</code>:<code class="identifier">SynMemberDefn</code>) -&gt; <code class="identifier">mem</code>.<code class="identifier">Range</code>)
       
       <code class="identifier">SynTypeDefn</code>($1, <code class="identifier">tcDefRepr</code>, <code class="identifier">members</code>, <code class="identifier">Some</code> <code class="identifier">memberCtorPattern</code>, <code class="identifier">mWhole</code>) }


<code class="comment">/* The right-hand-side of a type definition */</code>
<code class="identifier">tyconDefnRhsBlock</code>: 
  <code class="comment">/* This rule allows members to be given for record and union types in the #light syntax */</code>
  <code class="comment">/* without the use of 'with' ... 'end'. For example: */</code>
  <code class="comment">/*     type R = */</code>
  <code class="comment">/*         { a : int } */</code>
  <code class="comment">/*         member r.A = a */</code>
  <code class="comment">/* It also takes into account that any existing 'with' */</code>
  <code class="comment">/* block still needs to be considered and may occur indented or undented from the core type */</code>
  <code class="comment">/* representation. */</code>
  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">tyconDefnRhs</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="identifier">classDefnMembers</code> <code class="identifier">opt_classDefn</code> <code class="identifier">oblockend</code> <code class="identifier">opt_classDefn</code>  
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="keyword">match</code> $7 <code class="keyword">with</code> [] -&gt; (<code class="keyword">match</code> $5 <code class="keyword">with</code> [] -&gt; (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 4) | <code class="identifier">_</code> -&gt; (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 5)) | <code class="identifier">_</code> -&gt; (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 7))
       (<code class="keyword">fun</code> <code class="identifier">nameRange</code> -&gt; $2 <code class="identifier">nameRange</code> (<code class="identifier">checkForMultipleAugmentations</code> <code class="identifier">m</code> ($4 @ $5) $7)) }

  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">tyconDefnRhs</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="identifier">classDefnMembers</code> <code class="identifier">opt_classDefn</code> <code class="identifier">recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $6 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 6) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileTypeDefinition</code>())
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="keyword">match</code> $5 <code class="keyword">with</code> [] -&gt; (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 4) | <code class="identifier">_</code> -&gt; (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 5))
       (<code class="keyword">fun</code> <code class="identifier">nameRange</code> -&gt; $2 <code class="identifier">nameRange</code> (<code class="identifier">checkForMultipleAugmentations</code> <code class="identifier">m</code> ($4 @ $5) [])) }

  | <code class="identifier">tyconDefnRhs</code> <code class="identifier">opt_classDefn</code>
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       (<code class="keyword">fun</code> <code class="identifier">nameRange</code> -&gt; $1 <code class="identifier">nameRange</code> $2) }


<code class="comment">/* The right-hand-side of a type definition */</code>
<code class="identifier">tyconDefnRhs</code>: 

  <code class="comment">/* A simple type definition */</code>
  | <code class="identifier">tyconDefnOrSpfnSimpleRepr</code> 
     { <code class="keyword">let</code> <code class="identifier">m</code> = $1.<code class="identifier">Range</code>
       (<code class="keyword">fun</code> <code class="identifier">nameRange</code> <code class="identifier">augmentation</code> -&gt; <code class="identifier">SynTypeDefnRepr</code>.<code class="identifier">Simple</code> ($1, <code class="identifier">m</code>), <code class="identifier">augmentation</code>) }

  <code class="comment">/* An object type definition */</code>
  | <code class="identifier">tyconClassDefn</code> 
     { <code class="keyword">let</code> <code class="identifier">needsCheck</code>, (<code class="identifier">kind</code>, <code class="identifier">decls</code>), <code class="identifier">mopt</code> = $1 
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="keyword">match</code> <code class="identifier">mopt</code> <code class="keyword">with</code> 
               | <code class="identifier">None</code> -&gt; (<code class="identifier">lhs</code> <code class="identifier">parseState</code>).<code class="identifier">StartRange</code> <code class="comment">// create a zero-width range</code>
               | <code class="identifier">Some</code> <code class="identifier">m</code> -&gt; <code class="identifier">m</code>
       (<code class="keyword">fun</code> <code class="identifier">nameRange</code> <code class="identifier">augmentation</code> -&gt; 
           <code class="keyword">if</code> <code class="identifier">needsCheck</code> &amp;&amp; <code class="identifier">isNil</code> <code class="identifier">decls</code> <code class="keyword">then</code> 
               <code class="identifier">reportParseErrorAt</code> <code class="identifier">nameRange</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEmptyTypeDefinition</code>())
           <code class="identifier">SynTypeDefnRepr</code>.<code class="identifier">ObjectModel</code> (<code class="identifier">kind</code>, <code class="identifier">decls</code>, <code class="identifier">m</code>), <code class="identifier">augmentation</code>) }

  <code class="comment">/* A delegate type definition */</code>
  | <code class="identifier">DELEGATE</code> <code class="identifier">OF</code> <code class="identifier">topType</code>
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
       <code class="keyword">let</code> <code class="identifier">ty</code>, <code class="identifier">arity</code> = $3
       (<code class="keyword">fun</code> <code class="identifier">nameRange</code> <code class="identifier">augmentation</code> -&gt; 
           <code class="keyword">let</code> <code class="identifier">valSpfn</code> = <code class="identifier">SynValSig</code>([], <code class="identifier">mkSynId</code> <code class="identifier">m</code> <code class="string">"Invoke"</code>, <code class="identifier">inferredTyparDecls</code>, <code class="identifier">ty</code>, <code class="identifier">arity</code>, <code class="keyword">false</code>, <code class="keyword">false</code>, <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>, <code class="identifier">None</code>, <code class="identifier">None</code>, <code class="identifier">m</code>) 
           <code class="keyword">let</code> <code class="identifier">invoke</code> = <code class="identifier">SynMemberDefn</code>.<code class="identifier">AbstractSlot</code>(<code class="identifier">valSpfn</code>, <code class="identifier">AbstractMemberFlags</code> <code class="identifier">SynMemberKind</code>.<code class="identifier">Member</code>, <code class="identifier">m</code>) 
           <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> <code class="identifier">augmentation</code>) <code class="keyword">then</code> <code class="identifier">raiseParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAugmentationsIllegalOnDelegateType</code>())
           <code class="identifier">SynTypeDefnRepr</code>.<code class="identifier">ObjectModel</code> (<code class="identifier">SynTypeDefnKind</code>.<code class="identifier">Delegate</code> (<code class="identifier">ty</code>, <code class="identifier">arity</code>), [<code class="identifier">invoke</code>], <code class="identifier">m</code>), []) }


<code class="comment">/* The right-hand-side of a object type definition */</code>
<code class="identifier">tyconClassDefn</code>: 
  | <code class="identifier">classDefnBlockKindUnspecified</code>
     { <code class="keyword">let</code> <code class="identifier">needsCheck</code>, <code class="identifier">decls</code>, <code class="identifier">mopt</code> = $1 
       <code class="identifier">needsCheck</code>, (<code class="identifier">SynTypeDefnKind</code>.<code class="identifier">Unspecified</code>, <code class="identifier">decls</code>), <code class="identifier">mopt</code> }

  | <code class="identifier">classOrInterfaceOrStruct</code> <code class="identifier">classDefnBlock</code> <code class="identifier">END</code> 
     { <code class="keyword">false</code>, ($1, $2), <code class="identifier">Some</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

  | <code class="identifier">classOrInterfaceOrStruct</code> <code class="identifier">classDefnBlock</code> <code class="identifier">recover</code> 
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedClassInterfaceOrStruct</code>())
       <code class="keyword">let</code> <code class="identifier">m</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, $2) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> (<code class="identifier">d</code>:<code class="identifier">SynMemberDefn</code>) -&gt; <code class="identifier">d</code>.<code class="identifier">Range</code>)
       <code class="keyword">false</code>, ($1, $2), <code class="identifier">Some</code>(<code class="identifier">m</code>) }

  | <code class="identifier">classOrInterfaceOrStruct</code> <code class="keyword">error</code> <code class="identifier">END</code>
     { <code class="comment">// silent recovery </code>
       <code class="keyword">false</code>, ($1, []), <code class="identifier">Some</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }


<code class="comment">/* The right-hand-side of a object type definition where the class/interface/struct kind has not been specified */</code>
<code class="identifier">classDefnBlockKindUnspecified</code>:
  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">classDefnMembers</code> <code class="identifier">recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileTypeDefinition</code>())
       <code class="keyword">let</code> <code class="identifier">mopt</code> =
           <code class="keyword">match</code> $2 <code class="keyword">with</code>
           | <code class="identifier">_</code> :: <code class="identifier">_</code> -&gt; <code class="identifier">Some</code>( (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, $2) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> (<code class="identifier">d</code>:<code class="identifier">SynMemberDefn</code>) -&gt; <code class="identifier">d</code>.<code class="identifier">Range</code>) )
           | <code class="identifier">_</code> -&gt; <code class="identifier">None</code>
       <code class="keyword">false</code>, $2, <code class="identifier">mopt</code> }

  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">classDefnMembers</code> <code class="identifier">oblockend</code> 
     { <code class="keyword">let</code> <code class="identifier">mopt</code> =
           <code class="keyword">match</code> $2 <code class="keyword">with</code>
           | <code class="identifier">_</code> :: <code class="identifier">_</code> -&gt; <code class="identifier">Some</code>( (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, $2) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> (<code class="identifier">d</code>:<code class="identifier">SynMemberDefn</code>) -&gt; <code class="identifier">d</code>.<code class="identifier">Range</code>) )
           | <code class="identifier">_</code> -&gt; <code class="identifier">None</code>
       <code class="keyword">true</code>, $2, <code class="identifier">mopt</code> }


<code class="comment">/* The contents of an object type definition or type augmentation */</code>
<code class="identifier">classDefnBlock</code>:
  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">classDefnMembers</code> <code class="identifier">recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileTypeDefinition</code>())
        $2 }

  | <code class="identifier">OBLOCKBEGIN</code>  <code class="identifier">classDefnMembers</code> <code class="identifier">oblockend</code> 
      { $2 }

  | <code class="identifier">classDefnMembers</code> 
      { $1 }


<code class="comment">/* The members of an object type definition or type augmentation, possibly empty */</code>
<code class="identifier">classDefnMembers</code>:  
  | <code class="identifier">classDefnMembersAtLeastOne</code>
     { $1 }

  <code class="comment">/* REVIEW: Error recovery rules that are followed by potentially empty productions are suspicious! */</code>
  | <code class="keyword">error</code> <code class="identifier">classDefnMembers</code> 
     { $2 }

  | <code class="comment">/* EMPTY */</code>
     { [] }
  

<code class="comment">/* The members of an object type definition or type augmentation */</code>
<code class="identifier">classDefnMembersAtLeastOne</code>:
  | <code class="identifier">classDefnMember</code> <code class="identifier">opt_seps</code> <code class="identifier">classDefnMembers</code>
     { <code class="keyword">match</code> $1, $3 <code class="keyword">with</code>
       | [ <code class="identifier">SynMemberDefn</code>.<code class="identifier">Interface</code> (<code class="identifier">_</code>, <code class="identifier">Some</code> [], <code class="identifier">m</code>) ], <code class="identifier">nextMember</code> :: <code class="identifier">_</code> -&gt;
           <code class="identifier">warning</code>(<code class="identifier">IndentationProblem</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexfltTokenIsOffsideOfContextStartedEarlier</code>(<code class="identifier">warningStringOfPos</code> <code class="identifier">m</code>.<code class="identifier">Start</code>), <code class="identifier">nextMember</code>.<code class="identifier">Range</code>))
       | <code class="identifier">_</code> -&gt; ()
       $1 @ $3 }


<code class="comment">/* The "with get, set" part of a member definition */</code>
<code class="identifier">classDefnMemberGetSet</code>: 
  | <code class="identifier">WITH</code> <code class="identifier">classDefnMemberGetSetElements</code>
     { $2  }

  | <code class="identifier">OWITH</code> <code class="identifier">classDefnMemberGetSetElements</code> <code class="identifier">OEND</code>
     { $2  }

  | <code class="identifier">OWITH</code> <code class="identifier">classDefnMemberGetSetElements</code> <code class="keyword">error</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedWith</code>())
       $2  }

<code class="comment">/* The "get, set" part of a member definition */</code>
<code class="identifier">classDefnMemberGetSetElements</code>: 
  | <code class="identifier">classDefnMemberGetSetElement</code> 
     { [$1]  }
  | <code class="identifier">classDefnMemberGetSetElement</code> <code class="identifier">AND</code> <code class="identifier">classDefnMemberGetSetElement</code>
     { [$1;$3] }

<code class="identifier">classDefnMemberGetSetElement</code>: 
  | <code class="identifier">opt_inline</code> <code class="identifier">opt_attributes</code> <code class="identifier">bindingPattern</code> <code class="identifier">opt_topReturnTypeWithTypeConstraints</code> <code class="identifier">EQUALS</code> <code class="identifier">typedSeqExprBlock</code> 
     { <code class="keyword">let</code> <code class="identifier">mRhs</code> = ($6 : <code class="identifier">SynExpr</code>).<code class="identifier">Range</code> 
       ($1, $2, $3, $4, $6, <code class="identifier">mRhs</code>) }


<code class="comment">/* The core of a member definition */</code>
<code class="identifier">memberCore</code>:  
  <code class="comment">/* Methods and simple getter properties */</code>
  | <code class="identifier">opt_inline</code> <code class="identifier">bindingPattern</code> <code class="identifier">opt_topReturnTypeWithTypeConstraints</code> <code class="identifier">EQUALS</code> <code class="identifier">typedSeqExprBlock</code>  
     { <code class="keyword">let</code> <code class="identifier">mRhs</code> = $5.<code class="identifier">Range</code> 
       <code class="keyword">let</code> <code class="identifier">optReturnType</code> = $3 
       <code class="keyword">let</code> <code class="identifier">bindingBuilder</code>, <code class="identifier">mBindLhs</code> = $2 
       (<code class="keyword">fun</code> <code class="identifier">vis</code> <code class="identifier">memFlagsBuilder</code> <code class="identifier">attrs</code> <code class="identifier">rangeStart</code> -&gt;
            <code class="keyword">let</code> <code class="identifier">memberFlags</code> = <code class="identifier">Some</code> (<code class="identifier">memFlagsBuilder</code> <code class="identifier">SynMemberKind</code>.<code class="identifier">Member</code>)
            <code class="keyword">let</code> <code class="identifier">binding</code> = <code class="identifier">bindingBuilder</code> (<code class="identifier">vis</code>, $1, <code class="keyword">false</code>, <code class="identifier">mBindLhs</code>, <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtInvisible</code>, <code class="identifier">optReturnType</code>, $5, <code class="identifier">mRhs</code>, [], <code class="identifier">attrs</code>, <code class="identifier">memberFlags</code>)
            <code class="keyword">let</code> <code class="identifier">memberRange</code> = <code class="identifier">unionRanges</code> <code class="identifier">rangeStart</code> <code class="identifier">mRhs</code>
            [ <code class="identifier">SynMemberDefn</code>.<code class="identifier">Member</code> (<code class="identifier">binding</code>, <code class="identifier">memberRange</code>) ]) }

  <code class="comment">/* Properties with explicit get/set, also indexer properties */</code>
  | <code class="identifier">opt_inline</code> <code class="identifier">bindingPattern</code> <code class="identifier">opt_topReturnTypeWithTypeConstraints</code> <code class="identifier">classDefnMemberGetSet</code>  
     { <code class="keyword">let</code> <code class="identifier">mWhole</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2, $4) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">m2</code>) -&gt; <code class="identifier">m2</code>) 
       <code class="keyword">let</code> <code class="identifier">propertyNameBindingBuilder</code>, <code class="identifier">_</code> = $2 
       <code class="keyword">let</code> <code class="identifier">optPropertyType</code> = $3 
       <code class="keyword">let</code> <code class="identifier">isMutable</code> = <code class="keyword">false</code>
       (<code class="keyword">fun</code> <code class="identifier">visNoLongerUsed</code> <code class="identifier">memFlagsBuilder</code> <code class="identifier">attrs</code> <code class="identifier">rangeStart</code> -&gt; 
             <code class="keyword">let</code> <code class="identifier">hasGet</code> = <code class="identifier">ref</code> <code class="keyword">false</code>
             <code class="keyword">let</code> <code class="identifier">hasSet</code> = <code class="identifier">ref</code> <code class="keyword">false</code>

             <code class="comment">// Iterate over 1 or 2 'get'/'set' entries</code>
             $4 |&gt; <code class="identifier">List</code>.<code class="identifier">choose</code> (<code class="keyword">fun</code> (<code class="identifier">optInline</code>, <code class="identifier">optAttrs</code>, (<code class="identifier">bindingBuilder</code>, <code class="identifier">mBindLhs</code>), <code class="identifier">optReturnType</code>, <code class="identifier">expr</code>, <code class="identifier">exprm</code>) -&gt;

                   <code class="keyword">let</code> <code class="identifier">optInline</code> = $1 || <code class="identifier">optInline</code> 
                   <code class="comment">// optional attributes are only applied to getters and setters</code>
                   <code class="comment">// the "top level" attrs will be applied to both</code>
                   <code class="keyword">let</code> <code class="identifier">optAttrs</code> =
                       <code class="identifier">optAttrs</code> |&gt; <code class="identifier">List</code>.<code class="identifier">map</code> (<code class="keyword">fun</code> <code class="identifier">attrList</code> -&gt;
                           { <code class="identifier">attrList</code> <code class="keyword">with</code> <code class="identifier">Attributes</code> = <code class="identifier">attrList</code>.<code class="identifier">Attributes</code> |&gt; <code class="identifier">List</code>.<code class="identifier">map</code> (<code class="keyword">fun</code> <code class="identifier">a</code> -&gt; { <code class="identifier">a</code> <code class="keyword">with</code> <code class="identifier">AppliesToGetterAndSetter</code> = <code class="keyword">true</code> } ) })

                   <code class="keyword">let</code> <code class="identifier">attrs</code> = <code class="identifier">attrs</code> @ <code class="identifier">optAttrs</code>
                   
                   <code class="keyword">let</code> <code class="identifier">binding</code> = <code class="identifier">bindingBuilder</code> (<code class="identifier">visNoLongerUsed</code>, <code class="identifier">optInline</code>, <code class="identifier">isMutable</code>, <code class="identifier">mBindLhs</code>, <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtInvisible</code>, <code class="identifier">optReturnType</code>, <code class="identifier">expr</code>, <code class="identifier">exprm</code>, [], <code class="identifier">attrs</code>, <code class="identifier">Some</code> (<code class="identifier">memFlagsBuilder</code> <code class="identifier">SynMemberKind</code>.<code class="identifier">Member</code>))
                   <code class="keyword">let</code> (<code class="identifier">SynBinding</code> (<code class="identifier">vis</code>, <code class="identifier">_</code>, <code class="identifier">isInline</code>, <code class="identifier">_</code>, <code class="identifier">attrs</code>, <code class="identifier">doc</code>, <code class="identifier">valSynData</code>, <code class="identifier">pv</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">mBindLhs</code>, <code class="identifier">spBind</code>)) = <code class="identifier">binding</code> 
                   <code class="keyword">let</code> <code class="identifier">memberKind</code> = 
                         <code class="keyword">let</code> <code class="identifier">getset</code> = 
                               <code class="keyword">let</code> <code class="keyword">rec</code> <code class="identifier">go</code> <code class="identifier">p</code> = 
                                   <code class="keyword">match</code> <code class="identifier">p</code> <code class="keyword">with</code> 
                                   | <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">LongIdentWithDots</code>([<code class="identifier">id</code>], <code class="identifier">_</code>), <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>) -&gt;  <code class="identifier">id</code>.<code class="identifier">idText</code>
                                   | <code class="identifier">SynPat</code>.<code class="identifier">Named</code> (<code class="identifier">_</code>, <code class="identifier">nm</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>) -&gt;  <code class="identifier">nm</code>.<code class="identifier">idText</code>
                                   | <code class="identifier">SynPat</code>.<code class="identifier">Typed</code> (<code class="identifier">p</code>, <code class="identifier">_</code>, <code class="identifier">_</code>) -&gt;  <code class="identifier">go</code> <code class="identifier">p</code>
                                   | <code class="identifier">SynPat</code>.<code class="identifier">Attrib</code> (<code class="identifier">p</code>, <code class="identifier">_</code>, <code class="identifier">_</code>) -&gt;  <code class="identifier">go</code> <code class="identifier">p</code>
                                   | <code class="identifier">_</code> -&gt; <code class="identifier">raiseParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidDeclarationSyntax</code>()) 
                               <code class="identifier">go</code> <code class="identifier">pv</code> 
                         <code class="keyword">if</code> <code class="identifier">getset</code> = <code class="string">"get"</code> <code class="keyword">then</code>
                             <code class="keyword">if</code> !<code class="identifier">hasGet</code> <code class="keyword">then</code> 
                                 <code class="identifier">reportParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsGetAndOrSetRequired</code>())
                                 <code class="identifier">None</code>
                             <code class="keyword">else</code>
                                 <code class="identifier">hasGet</code> := <code class="keyword">true</code>
                                 <code class="identifier">Some</code> <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertyGet</code>
                         <code class="keyword">else</code> <code class="keyword">if</code> <code class="identifier">getset</code> = <code class="string">"set"</code> <code class="keyword">then</code>
                             <code class="keyword">if</code> !<code class="identifier">hasSet</code> <code class="keyword">then</code> 
                                 <code class="identifier">reportParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsGetAndOrSetRequired</code>())
                                 <code class="identifier">None</code>
                             <code class="keyword">else</code>
                                 <code class="identifier">hasSet</code> := <code class="keyword">true</code>
                                 <code class="identifier">Some</code> <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertySet</code>
                         <code class="keyword">else</code>
                             <code class="identifier">raiseParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsGetAndOrSetRequired</code>())

                   <code class="keyword">match</code> <code class="identifier">memberKind</code> <code class="keyword">with</code>
                   | <code class="identifier">None</code> -&gt; <code class="identifier">None</code>
                   | <code class="identifier">Some</code> <code class="identifier">memberKind</code> -&gt;

                   <code class="comment">// REVIEW: It's hard not to ignore the optPropertyType type annotation for 'set' properties. To apply it,</code>
                   <code class="comment">// we should apply it to the last argument, but at this point we've already pushed the patterns that </code>
                   <code class="comment">// make up the arguments onto the RHS. So we just always give a warning. </code>

                   <code class="keyword">begin</code> <code class="keyword">match</code> <code class="identifier">optPropertyType</code> <code class="keyword">with</code> 
                   | <code class="identifier">Some</code> <code class="identifier">_</code> -&gt; <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsTypeAnnotationsOnGetSet</code>(), <code class="identifier">mBindLhs</code>))
                   | <code class="identifier">None</code> -&gt; ()
                   <code class="keyword">end</code>
                   
                   <code class="keyword">let</code> <code class="identifier">optReturnType</code> = 
                       <code class="keyword">match</code> (<code class="identifier">memberKind</code>, <code class="identifier">optReturnType</code>) <code class="keyword">with</code> 
                       | <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertySet</code>, <code class="identifier">_</code> -&gt; <code class="identifier">optReturnType</code>
                       | <code class="identifier">_</code>, <code class="identifier">None</code> -&gt; <code class="identifier">optPropertyType</code>
                       | <code class="identifier">_</code> -&gt; <code class="identifier">optReturnType</code> 

                   <code class="comment">// REDO with the correct member kind </code>
                   <code class="keyword">let</code> <code class="identifier">binding</code> = <code class="identifier">bindingBuilder</code>(<code class="identifier">vis</code>, <code class="identifier">isInline</code>, <code class="identifier">isMutable</code>, <code class="identifier">mBindLhs</code>, <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtInvisible</code>, <code class="identifier">optReturnType</code>, <code class="identifier">expr</code>, <code class="identifier">exprm</code>, [], <code class="identifier">attrs</code>, <code class="identifier">Some</code>(<code class="identifier">memFlagsBuilder</code> <code class="identifier">memberKind</code>)) 

                   <code class="keyword">let</code> (<code class="identifier">SynBinding</code> (<code class="identifier">vis</code>, <code class="identifier">_</code>, <code class="identifier">isInline</code>, <code class="identifier">_</code>, <code class="identifier">attrs</code>, <code class="identifier">doc</code>, <code class="identifier">valSynData</code>, <code class="identifier">pv</code>, <code class="identifier">rhsRetInfo</code>, <code class="identifier">rhsExpr</code>, <code class="identifier">mBindLhs</code>, <code class="identifier">spBind</code>)) = <code class="identifier">binding</code> 
                
                   <code class="keyword">let</code> (<code class="identifier">SynValData</code>(<code class="identifier">_</code>, <code class="identifier">valSynInfo</code>, <code class="identifier">_</code>)) = <code class="identifier">valSynData</code> 

                   <code class="comment">// Setters have all arguments tupled in their internal TAST form, though they don't appear to be </code>
                   <code class="comment">// tupled from the syntax</code>
                   <code class="keyword">let</code> <code class="identifier">memFlags</code> : <code class="identifier">SynMemberFlags</code> = <code class="identifier">memFlagsBuilder</code> <code class="identifier">memberKind</code>

                   <code class="keyword">let</code> <code class="identifier">valSynInfo</code> = 
                       <code class="keyword">let</code> <code class="identifier">adjustValueArg</code> <code class="identifier">valueArg</code> = 
                           <code class="keyword">match</code> <code class="identifier">valueArg</code> <code class="keyword">with</code>
                           | [<code class="identifier">_</code>] -&gt; <code class="identifier">valueArg</code>
                           | <code class="identifier">_</code> -&gt; <code class="identifier">SynInfo</code>.<code class="identifier">unnamedTopArg</code>

                       <code class="keyword">match</code> <code class="identifier">memberKind</code>, <code class="identifier">valSynInfo</code>, <code class="identifier">memFlags</code>.<code class="identifier">IsInstance</code> <code class="keyword">with</code> 
                       | <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertyGet</code>, <code class="identifier">SynValInfo</code> ([], <code class="identifier">_ret</code>), <code class="keyword">false</code>
                       | <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertyGet</code>, <code class="identifier">SynValInfo</code> ([<code class="identifier">_</code>], <code class="identifier">_ret</code>), <code class="keyword">true</code>  -&gt; 
                           <code class="identifier">raiseParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsGetterMustHaveAtLeastOneArgument</code>()) 

                       | <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertyGet</code>, <code class="identifier">SynValInfo</code> (<code class="identifier">thisArg</code> :: <code class="identifier">indexOrUnitArgs</code> :: <code class="identifier">rest</code>, <code class="identifier">ret</code>), <code class="keyword">true</code>  -&gt; 
                           <code class="keyword">if</code> <code class="keyword">not</code> <code class="identifier">rest</code>.<code class="identifier">IsEmpty</code> <code class="keyword">then</code>
                               <code class="identifier">reportParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsGetterAtMostOneArgument</code> ())
                           <code class="identifier">SynValInfo</code> ([<code class="identifier">thisArg</code>; <code class="identifier">indexOrUnitArgs</code>], <code class="identifier">ret</code>)

                       | <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertyGet</code>, <code class="identifier">SynValInfo</code> (<code class="identifier">indexOrUnitArgs</code> :: <code class="identifier">rest</code>, <code class="identifier">ret</code>), <code class="keyword">false</code> -&gt;
                           <code class="keyword">if</code> <code class="keyword">not</code> <code class="identifier">rest</code>.<code class="identifier">IsEmpty</code> <code class="keyword">then</code>
                               <code class="identifier">reportParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsGetterAtMostOneArgument</code> ())
                           <code class="identifier">SynValInfo</code> ([<code class="identifier">indexOrUnitArgs</code>], <code class="identifier">ret</code>)

                       | <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertySet</code>, <code class="identifier">SynValInfo</code> ([<code class="identifier">thisArg</code>;<code class="identifier">valueArg</code>], <code class="identifier">ret</code>), <code class="keyword">true</code>  -&gt; 
                           <code class="identifier">SynValInfo</code> ([<code class="identifier">thisArg</code>; <code class="identifier">adjustValueArg</code> <code class="identifier">valueArg</code>], <code class="identifier">ret</code>)

                       | <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertySet</code>, <code class="identifier">SynValInfo</code> (<code class="identifier">thisArg</code> :: <code class="identifier">indexArgs</code> :: <code class="identifier">valueArg</code> :: <code class="identifier">rest</code>, <code class="identifier">ret</code>), <code class="keyword">true</code>  -&gt; 
                           <code class="keyword">if</code> <code class="keyword">not</code> <code class="identifier">rest</code>.<code class="identifier">IsEmpty</code> <code class="keyword">then</code>
                               <code class="identifier">reportParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSetterAtMostTwoArguments</code> ())
                           <code class="identifier">SynValInfo</code> ([<code class="identifier">thisArg</code>; <code class="identifier">indexArgs</code> @ <code class="identifier">adjustValueArg</code> <code class="identifier">valueArg</code>], <code class="identifier">ret</code>)

                       | <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertySet</code>, <code class="identifier">SynValInfo</code> ([<code class="identifier">valueArg</code>], <code class="identifier">ret</code>), <code class="keyword">false</code> -&gt; 
                           <code class="identifier">SynValInfo</code> ([<code class="identifier">adjustValueArg</code> <code class="identifier">valueArg</code>], <code class="identifier">ret</code>)

                       | <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertySet</code>, <code class="identifier">SynValInfo</code> (<code class="identifier">indexArgs</code> :: <code class="identifier">valueArg</code> :: <code class="identifier">rest</code>, <code class="identifier">ret</code>), <code class="identifier">_</code> -&gt; 
                           <code class="keyword">if</code> <code class="keyword">not</code> <code class="identifier">rest</code>.<code class="identifier">IsEmpty</code> <code class="keyword">then</code>
                               <code class="identifier">reportParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSetterAtMostTwoArguments</code> ())
                           <code class="identifier">SynValInfo</code> ([<code class="identifier">indexArgs</code> @ <code class="identifier">adjustValueArg</code> <code class="identifier">valueArg</code>], <code class="identifier">ret</code>)

                       | <code class="identifier">_</code> -&gt; 
                           <code class="comment">// should be unreachable, cover just in case</code>
                           <code class="identifier">raiseParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidProperty</code> ())

                   <code class="keyword">let</code> <code class="identifier">valSynData</code> = <code class="identifier">SynValData</code>(<code class="identifier">Some</code>(<code class="identifier">memFlags</code>), <code class="identifier">valSynInfo</code>, <code class="identifier">None</code>) 

                   <code class="comment">// Fold together the information from the first lambda pattern and the get/set binding</code>
                   <code class="comment">// This uses the 'this' variable from the first and the patterns for the get/set binding,</code>
                   <code class="comment">// replacing the get/set identifier. A little gross. </code>

                   <code class="keyword">let</code> <code class="identifier">bindingPatAdjusted</code>, <code class="identifier">xmlDocAdjusted</code> = 

                       <code class="keyword">let</code> <code class="identifier">bindingOuter</code> = <code class="identifier">propertyNameBindingBuilder</code>(<code class="identifier">vis</code>, <code class="identifier">optInline</code>, <code class="identifier">isMutable</code>, <code class="identifier">mBindLhs</code>, <code class="identifier">spBind</code>, <code class="identifier">optReturnType</code>, <code class="identifier">expr</code>, <code class="identifier">exprm</code>, [], <code class="identifier">attrs</code>, <code class="identifier">Some</code>(<code class="identifier">memFlagsBuilder</code> <code class="identifier">SynMemberKind</code>.<code class="identifier">Member</code>))

                       <code class="keyword">let</code> (<code class="identifier">SynBinding</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">doc2</code>, <code class="identifier">_</code>, <code class="identifier">bindingPatOuter</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>)) = <code class="identifier">bindingOuter</code> 
                   
                       <code class="keyword">let</code> <code class="identifier">lidOuter</code>, <code class="identifier">lidVisOuter</code> = 
                           <code class="keyword">match</code> <code class="identifier">bindingPatOuter</code> <code class="keyword">with</code> 
                           | <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">lid</code>, <code class="identifier">None</code>, <code class="identifier">None</code>, <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> [], <code class="identifier">lidVisOuter</code>, <code class="identifier">m</code>) -&gt;  <code class="identifier">lid</code>, <code class="identifier">lidVisOuter</code>
                           | <code class="identifier">SynPat</code>.<code class="identifier">Named</code> (<code class="identifier">_</code>, <code class="identifier">id</code>, <code class="identifier">_</code>, <code class="identifier">visOuter</code>, <code class="identifier">m</code>) -&gt; <code class="identifier">LongIdentWithDots</code>([<code class="identifier">id</code>], []), <code class="identifier">visOuter</code>
                           | <code class="identifier">p</code> -&gt; <code class="identifier">raiseParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidDeclarationSyntax</code>()) 

                       <code class="comment">// Merge the visibility from the outer point with the inner point, e.g.</code>
                       <code class="comment">//    member &lt;VIS1&gt;  this.Size with &lt;VIS2&gt; get ()      = m_size</code>
                       
                       <code class="keyword">let</code> <code class="identifier">mergeLidVisOuter</code> <code class="identifier">lidVisInner</code> =
                           <code class="keyword">match</code> <code class="identifier">lidVisInner</code>, <code class="identifier">lidVisOuter</code> <code class="keyword">with</code> 
                           | <code class="identifier">None</code>, <code class="identifier">None</code> -&gt; <code class="identifier">None</code>
                           | <code class="identifier">Some</code> <code class="identifier">lidVisInner</code>, <code class="identifier">None</code> | <code class="identifier">None</code>, <code class="identifier">Some</code> <code class="identifier">lidVisInner</code> -&gt; <code class="identifier">Some</code> <code class="identifier">lidVisInner</code>
                           | <code class="identifier">Some</code> <code class="identifier">_</code>, <code class="identifier">Some</code> <code class="identifier">_</code> -&gt;  
                               <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMultipleAccessibilitiesForGetSet</code>(), <code class="identifier">mBindLhs</code>))
                               <code class="identifier">lidVisInner</code>
                   
                       <code class="comment">// Replace the "get" or the "set" with the right name</code>
                       <code class="keyword">let</code> <code class="keyword">rec</code> <code class="identifier">go</code> <code class="identifier">p</code> = 
                           <code class="keyword">match</code> <code class="identifier">p</code> <code class="keyword">with</code> 
                           | <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">LongIdentWithDots</code>([<code class="identifier">id</code>], <code class="identifier">_</code>), <code class="identifier">_</code>, <code class="identifier">tyargs</code>, <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> <code class="identifier">args</code>, <code class="identifier">lidVisInner</code>, <code class="identifier">m</code>) -&gt;  
                               <code class="comment">// Setters have all arguments tupled in their internal form, though they don't </code>
                               <code class="comment">// appear to be tupled from the syntax. Somewhat unfortunate</code>
                               <code class="keyword">let</code> <code class="identifier">args</code> = 
                                   <code class="keyword">if</code> <code class="identifier">id</code>.<code class="identifier">idText</code> = <code class="string">"set"</code> <code class="keyword">then</code> 
                                       <code class="keyword">match</code> <code class="identifier">args</code> <code class="keyword">with</code> 
                                       | [<code class="identifier">SynPat</code>.<code class="identifier">Paren</code>(<code class="identifier">SynPat</code>.<code class="identifier">Tuple</code> (<code class="keyword">false</code>, <code class="identifier">indexPats</code>, <code class="identifier">_</code>), <code class="identifier">indexPatRange</code>);<code class="identifier">valuePat</code>] <code class="keyword">when</code> <code class="identifier">id</code>.<code class="identifier">idText</code> = <code class="string">"set"</code> -&gt; 
                                           [<code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, <code class="identifier">indexPats</code>@[<code class="identifier">valuePat</code>], <code class="identifier">unionRanges</code> <code class="identifier">indexPatRange</code> <code class="identifier">valuePat</code>.<code class="identifier">Range</code>)] 
                                       | [<code class="identifier">indexPat</code>;<code class="identifier">valuePat</code>] -&gt; 
                                           [<code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, <code class="identifier">args</code>, <code class="identifier">unionRanges</code> <code class="identifier">indexPat</code>.<code class="identifier">Range</code> <code class="identifier">valuePat</code>.<code class="identifier">Range</code>)] 
                                       | [<code class="identifier">valuePat</code>] -&gt; 
                                           [<code class="identifier">valuePat</code>] 
                                       | <code class="identifier">_</code> -&gt; 
                                           <code class="identifier">raiseParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSetSyntax</code>())
                                   <code class="keyword">else</code> 
                                       <code class="identifier">args</code>
<code class="comment">//                               let idTool : Ident list = lidOuter |&gt; List.map (fun (li:Ident) -&gt; ident(li.idText, id.idRange)) |&gt; List.rev |&gt; List.take 1</code>
                               <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">lidOuter</code>, <code class="identifier">Some</code>(<code class="identifier">id</code>), <code class="identifier">tyargs</code>, <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> <code class="identifier">args</code>, <code class="identifier">mergeLidVisOuter</code> <code class="identifier">lidVisInner</code>, <code class="identifier">m</code>)
                           | <code class="identifier">SynPat</code>.<code class="identifier">Named</code> (<code class="identifier">_</code>, <code class="identifier">nm</code>, <code class="identifier">_</code>, <code class="identifier">lidVisInner</code>, <code class="identifier">m</code>) -&gt;  <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">lidOuter</code>, <code class="identifier">None</code>, <code class="identifier">None</code>, <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> [], <code class="identifier">mergeLidVisOuter</code> <code class="identifier">lidVisInner</code>, <code class="identifier">m</code>)
                           | <code class="identifier">SynPat</code>.<code class="identifier">Typed</code> (<code class="identifier">p</code>, <code class="identifier">ty</code>, <code class="identifier">m</code>) -&gt;  <code class="identifier">SynPat</code>.<code class="identifier">Typed</code>(<code class="identifier">go</code> <code class="identifier">p</code>, <code class="identifier">ty</code>, <code class="identifier">m</code>)
                           | <code class="identifier">SynPat</code>.<code class="identifier">Attrib</code> (<code class="identifier">p</code>, <code class="identifier">attribs</code>, <code class="identifier">m</code>) -&gt;  <code class="identifier">SynPat</code>.<code class="identifier">Attrib</code>(<code class="identifier">go</code> <code class="identifier">p</code>, <code class="identifier">attribs</code>, <code class="identifier">m</code>)
                           | <code class="identifier">SynPat</code>.<code class="identifier">Wild</code>(<code class="identifier">m</code>) -&gt;  <code class="identifier">SynPat</code>.<code class="identifier">Wild</code>(<code class="identifier">m</code>)
                           | <code class="identifier">_</code> -&gt; <code class="identifier">raiseParseErrorAt</code> <code class="identifier">mBindLhs</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidDeclarationSyntax</code>()) 

                       <code class="identifier">go</code> <code class="identifier">pv</code>, <code class="identifier">PreXmlDoc</code>.<code class="identifier">Merge</code> <code class="identifier">doc2</code> <code class="identifier">doc</code>

                   <code class="keyword">let</code> <code class="identifier">binding</code> = <code class="identifier">SynBinding</code> (<code class="identifier">vis</code>, <code class="identifier">SynBindingKind</code>.<code class="identifier">Normal</code>, <code class="identifier">isInline</code>, <code class="identifier">isMutable</code>, <code class="identifier">attrs</code>, <code class="identifier">xmlDocAdjusted</code>, <code class="identifier">valSynData</code>, <code class="identifier">bindingPatAdjusted</code>, <code class="identifier">rhsRetInfo</code>, <code class="identifier">rhsExpr</code>, <code class="identifier">mBindLhs</code>, <code class="identifier">spBind</code>)
                   <code class="keyword">let</code> <code class="identifier">memberRange</code> = <code class="identifier">unionRanges</code> <code class="identifier">rangeStart</code> <code class="identifier">mWhole</code>
                   <code class="identifier">Some</code> (<code class="identifier">SynMemberDefn</code>.<code class="identifier">Member</code> (<code class="identifier">binding</code>, <code class="identifier">memberRange</code>))))
       }


<code class="identifier">abstractMemberFlags</code>: 
  | <code class="identifier">ABSTRACT</code> {} 
  | <code class="identifier">ABSTRACT</code> <code class="identifier">MEMBER</code> {} 


<code class="comment">/* A member definition */</code>
<code class="identifier">classDefnMember</code>:
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">classDefnBindings</code>
     { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       [<code class="identifier">mkClassMemberLocalBindings</code>(<code class="keyword">false</code>, <code class="identifier">None</code>, $1, $2, $3)] }
       
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">STATIC</code> <code class="identifier">classDefnBindings</code>  
     { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       [<code class="identifier">mkClassMemberLocalBindings</code>(<code class="keyword">true</code>, <code class="identifier">Some</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3), $1, $2, $4)] }
              
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">memberFlags</code> <code class="identifier">memberCore</code> <code class="identifier">opt_ODECLEND</code>
     { <code class="keyword">let</code> <code class="identifier">rangeStart</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code>
           <code class="identifier">errorR</code> (<code class="identifier">Error</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code> (), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       <code class="keyword">let</code> <code class="identifier">_</code>, <code class="identifier">flags</code> = $3
       $4 $2 <code class="identifier">flags</code> $1 <code class="identifier">rangeStart</code> }
       
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">interfaceMember</code> <code class="identifier">appType</code> <code class="identifier">opt_interfaceImplDefn</code>  
     {  <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAttributesAreNotPermittedOnInterfaceImplementations</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
        <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInterfacesHaveSameVisibilityAsEnclosingType</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3))
        <code class="keyword">let</code> <code class="identifier">members</code> = <code class="identifier">Option</code>.<code class="identifier">map</code> <code class="identifier">fst</code> $5
        <code class="keyword">let</code> <code class="identifier">mWhole</code> =
            <code class="keyword">match</code> $5 <code class="keyword">with</code>
            | <code class="identifier">None</code> -&gt; <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4
            | <code class="identifier">Some</code> (<code class="identifier">_</code>, <code class="identifier">m</code>) -&gt; <code class="identifier">unionRanges</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4) <code class="identifier">m</code>
        [ <code class="identifier">SynMemberDefn</code>.<code class="identifier">Interface</code> ($4, <code class="identifier">members</code>, <code class="identifier">mWhole</code>) ] }
        
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">abstractMemberFlags</code> <code class="identifier">opt_inline</code> <code class="identifier">nameop</code> <code class="identifier">opt_explicitValTyparDecls</code> <code class="identifier">COLON</code> <code class="identifier">topTypeWithTypeConstraints</code> <code class="identifier">classMemberSpfnGetSet</code>  <code class="identifier">opt_ODECLEND</code>
     { <code class="keyword">let</code> <code class="identifier">ty</code>, <code class="identifier">arity</code> = $8
       <code class="keyword">let</code> <code class="identifier">isInline</code>, <code class="identifier">doc</code>, <code class="identifier">id</code>, <code class="identifier">explicitValTyparDecls</code> = $4, <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 3), $5, $6
       <code class="keyword">let</code> <code class="identifier">getSetRangeOpt</code>, <code class="identifier">getSet</code> = $9
       <code class="keyword">let</code> <code class="identifier">getSetAdjuster</code> <code class="identifier">arity</code> = <code class="keyword">match</code> <code class="identifier">arity</code>, <code class="identifier">getSet</code> <code class="keyword">with</code> <code class="identifier">SynValInfo</code>([], <code class="identifier">_</code>), <code class="identifier">SynMemberKind</code>.<code class="identifier">Member</code> -&gt; <code class="identifier">SynMemberKind</code>.<code class="identifier">PropertyGet</code> | <code class="identifier">_</code> -&gt; <code class="identifier">getSet</code>
       <code class="keyword">let</code> <code class="identifier">wholeRange</code> = 
           <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
           <code class="keyword">match</code> <code class="identifier">getSetRangeOpt</code> <code class="keyword">with</code> 
           | <code class="identifier">None</code> -&gt; <code class="identifier">unionRanges</code> <code class="identifier">m</code> <code class="identifier">ty</code>.<code class="identifier">Range</code>
           | <code class="identifier">Some</code> <code class="identifier">m2</code> -&gt; <code class="identifier">unionRanges</code> <code class="identifier">m</code> <code class="identifier">m2</code>
       <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAccessibilityModsIllegalForAbstract</code>(), <code class="identifier">wholeRange</code>))
       <code class="keyword">let</code> <code class="identifier">valSpfn</code> = <code class="identifier">SynValSig</code>($1, <code class="identifier">id</code>, <code class="identifier">explicitValTyparDecls</code>, <code class="identifier">ty</code>, <code class="identifier">arity</code>, <code class="identifier">isInline</code>, <code class="keyword">false</code>, <code class="identifier">doc</code>, <code class="identifier">None</code>, <code class="identifier">None</code>, <code class="identifier">wholeRange</code>)
       [ <code class="identifier">SynMemberDefn</code>.<code class="identifier">AbstractSlot</code>(<code class="identifier">valSpfn</code>, <code class="identifier">AbstractMemberFlags</code> (<code class="identifier">getSetAdjuster</code> <code class="identifier">arity</code>), <code class="identifier">wholeRange</code>) ] }
       
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">inheritsDefn</code>
     {  <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAttributesIllegalOnInherit</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
        <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityIllegalOnInherit</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
        [ $3 ] }
        
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">valDefnDecl</code> <code class="identifier">opt_ODECLEND</code>
     {  <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> <code class="identifier">rangeStart</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
        $3 <code class="identifier">rangeStart</code> $1 <code class="keyword">false</code> }
        
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">STATIC</code> <code class="identifier">valDefnDecl</code> <code class="identifier">opt_ODECLEND</code>
     {  <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> <code class="identifier">rangeStart</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
        $4 <code class="identifier">rangeStart</code> $1 <code class="keyword">true</code>  }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">memberFlags</code> <code class="identifier">autoPropsDefnDecl</code> <code class="identifier">opt_ODECLEND</code>
     { <code class="keyword">let</code> <code class="identifier">rangeStart</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
       <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code>
           <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       <code class="keyword">let</code> <code class="identifier">isStatic</code>, <code class="identifier">flags</code> = $3
       $4 $1 <code class="identifier">isStatic</code> <code class="identifier">flags</code> <code class="identifier">rangeStart</code> }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">NEW</code>  <code class="identifier">atomicPattern</code> <code class="identifier">optAsSpec</code> <code class="identifier">EQUALS</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">opt_ODECLEND</code>
     {  <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 6) $7.<code class="identifier">Range</code> 
        <code class="keyword">let</code> <code class="identifier">expr</code> = $7
        <code class="keyword">let</code> <code class="identifier">valSynData</code> = <code class="identifier">SynValData</code> (<code class="identifier">Some</code> <code class="identifier">CtorMemberFlags</code>, <code class="identifier">SynValInfo</code>([<code class="identifier">SynInfo</code>.<code class="identifier">InferSynArgInfoFromPat</code> $4], <code class="identifier">SynInfo</code>.<code class="identifier">unnamedRetVal</code>), $5) 
        <code class="keyword">let</code> <code class="identifier">vis</code> = $2 
        <code class="keyword">let</code> <code class="identifier">declPat</code> = <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">LongIdentWithDots</code>([<code class="identifier">mkSynId</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) <code class="string">"new"</code>], []), <code class="identifier">None</code>, <code class="identifier">Some</code> <code class="identifier">noInferredTypars</code>, <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> [$4], <code class="identifier">vis</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3)
        <code class="comment">// Check that 'SynPatForConstructorDecl' matches this correctly</code>
        <code class="keyword">assert</code> (<code class="keyword">match</code> <code class="identifier">declPat</code> <code class="keyword">with</code> <code class="identifier">SynPatForConstructorDecl</code> <code class="identifier">_</code> -&gt; <code class="keyword">true</code> | <code class="identifier">_</code> -&gt; <code class="keyword">false</code>)
        [ <code class="identifier">SynMemberDefn</code>.<code class="identifier">Member</code>(<code class="identifier">SynBinding</code> (<code class="identifier">None</code>, <code class="identifier">SynBindingKind</code>.<code class="identifier">Normal</code>, <code class="keyword">false</code>, <code class="keyword">false</code>, $1, <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 3), <code class="identifier">valSynData</code>, <code class="identifier">declPat</code>, <code class="identifier">None</code>, <code class="identifier">expr</code>, <code class="identifier">m</code>, <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtInvisible</code>), <code class="identifier">m</code>) ] }
        
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">STATIC</code> <code class="identifier">typeKeyword</code> <code class="identifier">tyconDefn</code> 
     {  <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsVisibilityDeclarationsShouldComePriorToIdentifier</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        [ <code class="identifier">SynMemberDefn</code>.<code class="identifier">NestedType</code>($5, <code class="identifier">None</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5) ] }


<code class="comment">/* A 'val' definition in an object type definition */</code>
<code class="identifier">valDefnDecl</code>:
  | <code class="identifier">VAL</code> <code class="identifier">opt_mutable</code> <code class="identifier">opt_access</code> <code class="identifier">ident</code> <code class="identifier">COLON</code>  <code class="identifier">typ</code> 
     {  <code class="keyword">let</code> <code class="identifier">mRhs</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 4 6
        <code class="keyword">let</code> <code class="identifier">doc</code> = <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 4)
        <code class="keyword">let</code> <code class="identifier">mValDecl</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 6
        (<code class="keyword">fun</code> <code class="identifier">rangeStart</code> <code class="identifier">attribs</code> <code class="identifier">isStatic</code> -&gt; 
            <code class="keyword">let</code> <code class="identifier">mValDecl</code> = <code class="identifier">unionRanges</code> <code class="identifier">rangeStart</code> <code class="identifier">mValDecl</code>
            <code class="keyword">let</code> <code class="identifier">fld</code> = <code class="identifier">SynField</code>(<code class="identifier">attribs</code>, <code class="identifier">isStatic</code>, <code class="identifier">Some</code> $4, $6, $2, <code class="identifier">doc</code>, $3, <code class="identifier">mRhs</code>)
            [ <code class="identifier">SynMemberDefn</code>.<code class="identifier">ValField</code>(<code class="identifier">fld</code>, <code class="identifier">mValDecl</code>) ]) }


<code class="comment">/* An auto-property definition in an object type definition */</code>
<code class="identifier">autoPropsDefnDecl</code>:
  | <code class="identifier">VAL</code> <code class="identifier">opt_mutable</code> <code class="identifier">opt_access</code> <code class="identifier">ident</code> <code class="identifier">opt_typ</code> <code class="identifier">EQUALS</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">classMemberSpfnGetSet</code>
     { <code class="keyword">let</code> <code class="identifier">doc</code> = <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 5)
       <code class="keyword">let</code> <code class="identifier">mGetSetOpt</code>, <code class="identifier">getSet</code> = $8
       <code class="keyword">if</code> $2 <code class="keyword">then</code>
           <code class="identifier">errorR</code> (<code class="identifier">Error</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMutableOnAutoPropertyShouldBeGetSet</code> (), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3))
       (<code class="keyword">fun</code> <code class="identifier">attribs</code> <code class="identifier">isStatic</code> <code class="identifier">flags</code> <code class="identifier">rangeStart</code> -&gt;
           <code class="keyword">let</code> <code class="identifier">memberRange</code> = <code class="identifier">unionRanges</code> <code class="identifier">rangeStart</code> $7.<code class="identifier">Range</code>
           [ <code class="identifier">SynMemberDefn</code>.<code class="identifier">AutoProperty</code>(<code class="identifier">attribs</code>, <code class="identifier">isStatic</code>, $4, $5, <code class="identifier">getSet</code>, <code class="identifier">flags</code>, <code class="identifier">doc</code>, $3, $7, <code class="identifier">mGetSetOpt</code>, <code class="identifier">memberRange</code>) ]) }


<code class="comment">/* An optional type on an auto-property definition */</code>
<code class="identifier">opt_typ</code>:
   | <code class="comment">/* EMPTY */</code> { <code class="identifier">None</code> } 
   | <code class="identifier">COLON</code> <code class="identifier">typ</code> { <code class="identifier">Some</code> $2 }


<code class="identifier">atomicPatternLongIdent</code>:
  | <code class="identifier">UNDERSCORE</code> <code class="identifier">DOT</code> <code class="identifier">pathOp</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">parseState</code>.<code class="identifier">LexBuffer</code>.<code class="identifier">SupportsFeature</code> <code class="identifier">LanguageFeature</code>.<code class="identifier">SingleUnderscorePattern</code>) <code class="keyword">then</code>
          <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedSymbolDot</code>())
       <code class="keyword">let</code> (<code class="identifier">LongIdentWithDots</code>(<code class="identifier">lid</code>, <code class="identifier">dotms</code>)) = $3
       (<code class="identifier">None</code>, <code class="identifier">LongIdentWithDots</code>(<code class="identifier">ident</code>(<code class="string">"_"</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)::<code class="identifier">lid</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2::<code class="identifier">dotms</code>)) }

  | <code class="identifier">GLOBAL</code> <code class="identifier">DOT</code> <code class="identifier">pathOp</code>
     { <code class="keyword">let</code> (<code class="identifier">LongIdentWithDots</code>(<code class="identifier">lid</code>, <code class="identifier">dotms</code>)) = $3
       (<code class="identifier">None</code>, <code class="identifier">LongIdentWithDots</code>(<code class="identifier">ident</code>(<code class="identifier">MangledGlobalName</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) :: <code class="identifier">lid</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2 :: <code class="identifier">dotms</code>)) }

  | <code class="identifier">pathOp</code>
     { (<code class="identifier">None</code>, $1) }

  | <code class="identifier">access</code> <code class="identifier">UNDERSCORE</code> <code class="identifier">DOT</code> <code class="identifier">pathOp</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">parseState</code>.<code class="identifier">LexBuffer</code>.<code class="identifier">SupportsFeature</code> <code class="identifier">LanguageFeature</code>.<code class="identifier">SingleUnderscorePattern</code>) <code class="keyword">then</code>
          <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedSymbolDot</code>())
       <code class="keyword">let</code> (<code class="identifier">LongIdentWithDots</code>(<code class="identifier">lid</code>, <code class="identifier">dotms</code>)) = $4
       (<code class="identifier">Some</code>($1), <code class="identifier">LongIdentWithDots</code>(<code class="identifier">ident</code>(<code class="string">"_"</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)::<code class="identifier">lid</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3::<code class="identifier">dotms</code>)) }  

  | <code class="identifier">access</code> <code class="identifier">pathOp</code>
     { (<code class="identifier">Some</code>($1), $2) }


<code class="identifier">opt_access</code>:
  | <code class="comment">/* EMPTY */</code>
     { <code class="identifier">None</code> }

  | <code class="identifier">access</code>
     { <code class="identifier">Some</code>($1) } 


<code class="identifier">access</code>:
  | <code class="identifier">PRIVATE</code>
     { <code class="identifier">SynAccess</code>.<code class="identifier">Private</code> }

  | <code class="identifier">PUBLIC</code>
     { <code class="identifier">SynAccess</code>.<code class="identifier">Public</code> }

  | <code class="identifier">INTERNAL</code>
     { <code class="identifier">SynAccess</code>.<code class="identifier">Internal</code> }

<code class="comment">/* only valid on 'NEW' */</code>
<code class="identifier">opt_declVisibility</code>:
  | <code class="identifier">access</code>
     { <code class="identifier">Some</code>($1) } 

  | <code class="comment">/* EMPTY */</code>
     { <code class="identifier">None</code> }
  

<code class="identifier">opt_interfaceImplDefn</code>:
  | <code class="identifier">WITH</code> <code class="identifier">objectImplementationBlock</code> <code class="identifier">declEnd</code>
     { <code class="keyword">let</code> <code class="identifier">members</code> = $2
       <code class="keyword">let</code> <code class="identifier">m</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, <code class="identifier">members</code>) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> (<code class="identifier">mem</code>:<code class="identifier">SynMemberDefn</code>) -&gt; <code class="identifier">mem</code>.<code class="identifier">Range</code>)
       <code class="identifier">Some</code> (<code class="identifier">members</code>, <code class="identifier">m</code>) }

  | <code class="identifier">WITH</code>
     { <code class="identifier">Some</code> ([], <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) }

  | <code class="comment">/* EMPTY */</code>
     { <code class="identifier">None</code> }


<code class="identifier">opt_classDefn</code>: 
  | <code class="identifier">WITH</code> <code class="identifier">classDefnBlock</code> <code class="identifier">declEnd</code>
     { $2 } 

  | <code class="comment">/* EMPTY */</code>
     { [] }


<code class="comment">/* An 'inherits' definition in an object type definition */</code>
<code class="identifier">inheritsDefn</code>: 
  | <code class="identifier">INHERIT</code> <code class="identifier">atomTypeNonAtomicDeprecated</code> <code class="identifier">optBaseSpec</code>
     { <code class="keyword">let</code> <code class="identifier">mDecl</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (($2): <code class="identifier">SynType</code>).<code class="identifier">Range</code> 
       <code class="identifier">SynMemberDefn</code>.<code class="identifier">Inherit</code>($2, $3, <code class="identifier">mDecl</code>) }

  | <code class="identifier">INHERIT</code> <code class="identifier">atomTypeNonAtomicDeprecated</code> <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="identifier">atomicExprAfterType</code> <code class="identifier">optBaseSpec</code>
     { <code class="keyword">let</code> <code class="identifier">mDecl</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code> 
       <code class="identifier">SynMemberDefn</code>.<code class="identifier">ImplicitInherit</code>($2, $4, $5, <code class="identifier">mDecl</code>) }

  | <code class="identifier">INHERIT</code> <code class="identifier">ends_coming_soon_or_recover</code>
     { <code class="keyword">let</code> <code class="identifier">mDecl</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
       <code class="keyword">if</code> <code class="keyword">not</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsTypeNameCannotBeEmpty</code>(), <code class="identifier">mDecl</code>))
       <code class="identifier">SynMemberDefn</code>.<code class="identifier">Inherit</code>(<code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>(<code class="identifier">LongIdentWithDots</code>([], [])), <code class="identifier">None</code>, <code class="identifier">mDecl</code>) }

<code class="identifier">optAsSpec</code>: 
  | <code class="identifier">asSpec</code>
      { <code class="identifier">Some</code>($1) } 

  | <code class="comment">/* EMPTY */</code>
      { <code class="identifier">None</code> }

<code class="identifier">asSpec</code>: 
  | <code class="identifier">AS</code> <code class="identifier">ident</code>
     { $2 } 

<code class="identifier">optBaseSpec</code>: 
  | <code class="identifier">baseSpec</code>
     { <code class="identifier">Some</code>($1) } 

  | <code class="comment">/* EMPTY */</code>
     { <code class="identifier">None</code> }

<code class="identifier">baseSpec</code>: 
  | <code class="identifier">AS</code> <code class="identifier">ident</code> 
      { <code class="keyword">if</code> ($2).<code class="identifier">idText</code> &lt;&gt; <code class="string">"base"</code> <code class="keyword">then</code> 
             <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInheritDeclarationsCannotHaveAsBindings</code>(), <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2)) 
        <code class="identifier">ident</code>(<code class="string">"base"</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) } 
        
  | <code class="identifier">AS</code> <code class="identifier">BASE</code> 
      { <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInheritDeclarationsCannotHaveAsBindings</code>(), <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2)) 
        <code class="identifier">ident</code>(<code class="string">"base"</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) } 


<code class="comment">/* The members in an object expression or interface implementation */</code>
<code class="identifier">objectImplementationBlock</code>:
  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">objectImplementationMembers</code> <code class="identifier">oblockend</code>  
      { $2 }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">objectImplementationMembers</code> <code class="identifier">recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileObjectMembers</code>())
        $2 }

  | <code class="identifier">objectImplementationMembers</code> 
      { $1 }


<code class="comment">/* The members in an object expression or interface implementation */</code>
<code class="identifier">objectImplementationMembers</code>:  
  | <code class="identifier">objectImplementationMember</code> <code class="identifier">opt_seps</code> <code class="identifier">objectImplementationMembers</code> 
      { $1 @  $3 }

  | <code class="identifier">objectImplementationMember</code> <code class="identifier">opt_seps</code> 
      { $1 }


<code class="comment">/* One member in an object expression or interface implementation */</code>
<code class="identifier">objectImplementationMember</code>: 
  | <code class="identifier">opt_attributes</code> <code class="identifier">memberOrOverride</code> <code class="identifier">memberCore</code> <code class="identifier">opt_ODECLEND</code>
     { <code class="keyword">let</code> <code class="identifier">rangeStart</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       $3 <code class="identifier">None</code> <code class="identifier">OverrideMemberFlags</code> $1 <code class="identifier">rangeStart</code> }

  | <code class="identifier">opt_attributes</code> <code class="identifier">memberOrOverride</code> <code class="identifier">autoPropsDefnDecl</code> <code class="identifier">opt_ODECLEND</code>
     { <code class="keyword">let</code> <code class="identifier">rangeStart</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       $3 $1 <code class="keyword">false</code> <code class="identifier">OverrideMemberFlags</code> <code class="identifier">rangeStart</code> }

  | <code class="identifier">opt_attributes</code> <code class="identifier">memberOrOverride</code> <code class="keyword">error</code> 
      { [] } 

  | <code class="identifier">opt_attributes</code> <code class="keyword">error</code> <code class="identifier">memberCore</code> <code class="identifier">opt_ODECLEND</code> 
      { [] }


<code class="identifier">memberOrOverride</code>: 
  | <code class="identifier">MEMBER</code> {   } 
  | <code class="identifier">OVERRIDE</code> {   }


<code class="comment">/* The core of the right-hand-side of a simple type definition */</code>
<code class="identifier">tyconDefnOrSpfnSimpleRepr</code>: 

  <code class="comment">/* type MyAlias = SomeTypeProvider&lt;@"foo"&gt;    is a common error, special-case it */</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">path</code> <code class="identifier">LQUOTE</code> <code class="identifier">STRING</code> <code class="identifier">recover</code>     
     { <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 4)) 
       <code class="identifier">SynTypeDefnSimpleRepr</code>.<code class="identifier">TypeAbbrev</code> (<code class="identifier">ParserDetail</code>.<code class="identifier">ErrorRecovery</code>, <code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>($3), <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $3.<code class="identifier">Range</code>)  }

  <code class="comment">/* A type abbreviation */</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">typ</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAttributesIllegalHere</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
       <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsTypeAbbreviationsCannotHaveVisibilityDeclarations</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       <code class="identifier">SynTypeDefnSimpleRepr</code>.<code class="identifier">TypeAbbrev</code> (<code class="identifier">ParserDetail</code>.<code class="identifier">Ok</code>, $3, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $3.<code class="identifier">Range</code>) }

  <code class="comment">/* A union type definition */</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">unionTypeRepr</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAttributesIllegalHere</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
       <code class="keyword">let</code> <code class="identifier">rangesOf3</code> = $3 |&gt; <code class="identifier">List</code>.<code class="identifier">map</code> (<code class="keyword">function</code> |<code class="identifier">Choice1Of2</code>(<code class="identifier">ec</code>)-&gt;<code class="identifier">ec</code>.<code class="identifier">Range</code> | <code class="identifier">Choice2Of2</code>(<code class="identifier">uc</code>)-&gt;<code class="identifier">uc</code>.<code class="identifier">Range</code>)
       <code class="keyword">let</code> <code class="identifier">mWhole</code> = (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2, <code class="identifier">rangesOf3</code>) ||&gt; <code class="identifier">List</code>.<code class="identifier">fold</code> <code class="identifier">unionRanges</code> 
       <code class="keyword">if</code> $3 |&gt; <code class="identifier">List</code>.<code class="identifier">exists</code> (<code class="keyword">function</code> <code class="identifier">Choice1Of2</code> <code class="identifier">_</code> -&gt; <code class="keyword">true</code> | <code class="identifier">_</code> -&gt; <code class="keyword">false</code>) <code class="keyword">then</code> (
           <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEnumTypesCannotHaveVisibilityDeclarations</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2));
           <code class="identifier">SynTypeDefnSimpleRepr</code>.<code class="identifier">Enum</code> ($3 |&gt; <code class="identifier">List</code>.<code class="identifier">choose</code> (<code class="keyword">function</code> 
                                              | <code class="identifier">Choice1Of2</code> <code class="identifier">data</code> -&gt;  
                                                <code class="identifier">Some</code>(<code class="identifier">data</code>) 
                                              | <code class="identifier">Choice2Of2</code>(<code class="identifier">SynUnionCase</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">m</code>)) -&gt; 
                                                <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAllEnumFieldsRequireValues</code>(), <code class="identifier">m</code>)); <code class="identifier">None</code>),
                           <code class="identifier">mWhole</code>)
       ) <code class="keyword">else</code> 
           <code class="identifier">SynTypeDefnSimpleRepr</code>.<code class="identifier">Union</code> ($2,
                            $3 |&gt; <code class="identifier">List</code>.<code class="identifier">choose</code> (<code class="keyword">function</code> <code class="identifier">Choice2Of2</code> <code class="identifier">data</code> -&gt; <code class="identifier">Some</code>(<code class="identifier">data</code>) | <code class="identifier">Choice1Of2</code> <code class="identifier">_</code> -&gt; <code class="identifier">failwith</code> <code class="string">"huh?"</code>),
                            <code class="identifier">mWhole</code>) }

  <code class="comment">/* A record type definition */</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">braceFieldDeclList</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAttributesIllegalHere</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
       <code class="identifier">SynTypeDefnSimpleRepr</code>.<code class="identifier">Record</code> ($2, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  <code class="comment">/* An inline-assembly type definition, for FSharp.Core library only */</code>
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_declVisibility</code> <code class="identifier">LPAREN</code> <code class="identifier">inlineAssemblyTyconRepr</code> <code class="identifier">rparen</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNil</code> $1) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAttributesIllegalHere</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
       <code class="identifier">libraryOnlyError</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>)
       <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInlineAssemblyCannotHaveVisibilityDeclarations</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       $4 }


<code class="comment">/* The core of a record type definition */</code>
<code class="identifier">braceFieldDeclList</code>:
  | <code class="identifier">LBRACE</code>  <code class="identifier">recdFieldDeclList</code> <code class="identifier">rbrace</code>
     { $2 }

  | <code class="identifier">LBRACE</code>  <code class="identifier">recdFieldDeclList</code> <code class="identifier">recover</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBrace</code>()) 
       $2 }

  | <code class="identifier">LBRACE</code>  <code class="keyword">error</code> <code class="identifier">rbrace</code>
     { [] }

<code class="identifier">anonRecdType</code>:
    | <code class="identifier">STRUCT</code> <code class="identifier">braceBarFieldDeclListCore</code>
        { $2, <code class="keyword">true</code> }
    | <code class="identifier">braceBarFieldDeclListCore</code>
        { $1, <code class="keyword">false</code> }

<code class="comment">/* The core of a record type definition */</code>
<code class="identifier">braceBarFieldDeclListCore</code>:
  | <code class="identifier">LBRACE_BAR</code>  <code class="identifier">recdFieldDeclList</code> <code class="identifier">bar_rbrace</code>
     { $2 }

  | <code class="identifier">LBRACE_BAR</code>  <code class="identifier">recdFieldDeclList</code> <code class="identifier">recover</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBraceBar</code>()) 
       $2 }

  | <code class="identifier">LBRACE_BAR</code> <code class="keyword">error</code> <code class="identifier">bar_rbrace</code>
     { [] }

<code class="identifier">inlineAssemblyTyconRepr</code>:
  | <code class="identifier">HASH</code> <code class="identifier">stringOrKeywordString</code> <code class="identifier">HASH</code> 
     { <code class="identifier">libraryOnlyError</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>)
       <code class="keyword">let</code> <code class="identifier">lhsm</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code>
       <code class="keyword">let</code> <code class="identifier">s</code>, <code class="identifier">_</code> = $2
       <code class="keyword">let</code> <code class="identifier">ilType</code> = <code class="identifier">ParseAssemblyCodeType</code> <code class="identifier">s</code> <code class="identifier">parseState</code>.<code class="identifier">LexBuffer</code>.<code class="identifier">SupportsFeature</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)
       <code class="identifier">SynTypeDefnSimpleRepr</code>.<code class="identifier">LibraryOnlyILAssembly</code> (<code class="identifier">box</code> <code class="identifier">ilType</code>, <code class="identifier">lhsm</code>) }

<code class="identifier">classOrInterfaceOrStruct</code>: 
  | <code class="identifier">CLASS</code> 
     { <code class="identifier">SynTypeDefnKind</code>.<code class="identifier">Class</code> } 

  | <code class="identifier">INTERFACE</code>
     { <code class="identifier">SynTypeDefnKind</code>.<code class="identifier">Interface</code> } 

  | <code class="identifier">STRUCT</code>
     { <code class="identifier">SynTypeDefnKind</code>.<code class="identifier">Struct</code> }

<code class="identifier">interfaceMember</code>: 
  | <code class="identifier">INTERFACE</code> { } 
  | <code class="identifier">OINTERFACE_MEMBER</code>    { }

<code class="identifier">tyconNameAndTyparDecls</code>:  
  | <code class="identifier">opt_access</code> <code class="identifier">path</code> 
      { [], $2.<code class="identifier">Lid</code>, <code class="keyword">false</code>, [], $1, <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 2) }

  | <code class="identifier">opt_access</code> <code class="identifier">prefixTyparDecls</code>  <code class="identifier">path</code>
      { $2, $3.<code class="identifier">Lid</code>, <code class="keyword">false</code>, [], $1, <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 2) }

  | <code class="identifier">opt_access</code> <code class="identifier">path</code> <code class="identifier">postfixTyparDecls</code> 
      { <code class="keyword">let</code> <code class="identifier">tps</code>, <code class="identifier">tpcs</code> = $3 
        <code class="identifier">tps</code>, $2.<code class="identifier">Lid</code>, <code class="keyword">true</code>, <code class="identifier">tpcs</code>, $1, <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 2) }

<code class="identifier">prefixTyparDecls</code>:
  | <code class="identifier">typar</code> { [ <code class="identifier">SynTyparDecl</code>([], $1) ] }
  | <code class="identifier">LPAREN</code> <code class="identifier">typarDeclList</code> <code class="identifier">rparen</code> {  <code class="identifier">List</code>.<code class="identifier">rev</code> $2 }

<code class="identifier">typarDeclList</code>: 
  | <code class="identifier">typarDeclList</code> <code class="identifier">COMMA</code> <code class="identifier">typarDecl</code> { $3 :: $1 } 
  | <code class="identifier">typarDecl</code> { [$1] }

<code class="identifier">typarDecl</code> : 
  | <code class="identifier">opt_attributes</code> <code class="identifier">typar</code> 
      { <code class="identifier">SynTyparDecl</code>($1, $2) }

<code class="comment">/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */</code>
<code class="comment">/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */</code>
<code class="identifier">postfixTyparDecls</code>: 
  | <code class="identifier">opt_HIGH_PRECEDENCE_TYAPP</code> <code class="identifier">LESS</code> <code class="identifier">typarDeclList</code> <code class="identifier">opt_typeConstraints</code> <code class="identifier">GREATER</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $2 <code class="keyword">then</code> <code class="identifier">warning</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsNonAdjacentTypars</code>(), <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 2 5))
        <code class="identifier">List</code>.<code class="identifier">rev</code> $3, $4 }

<code class="comment">/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */</code>
<code class="comment">/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */</code>
<code class="identifier">explicitValTyparDeclsCore</code>: 
  | <code class="identifier">typarDeclList</code> <code class="identifier">COMMA</code> <code class="identifier">DOT_DOT</code> 
      { (<code class="identifier">List</code>.<code class="identifier">rev</code> $1, <code class="keyword">true</code>) }

  | <code class="identifier">typarDeclList</code> 
      { (<code class="identifier">List</code>.<code class="identifier">rev</code> $1, <code class="keyword">false</code>) }

  | <code class="comment">/* EMPTY */</code>
      { ([], <code class="keyword">false</code>) }

<code class="identifier">explicitValTyparDecls</code>: 
  | <code class="identifier">opt_HIGH_PRECEDENCE_TYAPP</code> <code class="identifier">LESS</code> <code class="identifier">explicitValTyparDeclsCore</code> <code class="identifier">opt_typeConstraints</code> <code class="identifier">GREATER</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $2 <code class="keyword">then</code> <code class="identifier">warning</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsNonAdjacentTypars</code>(), <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 2 5))
        <code class="keyword">let</code> <code class="identifier">tps</code>, <code class="identifier">flex</code> = $3 
        <code class="identifier">SynValTyparDecls</code>(<code class="identifier">tps</code>, <code class="identifier">flex</code>, $4) }

<code class="identifier">opt_explicitValTyparDecls</code>: 
  | <code class="identifier">explicitValTyparDecls</code> 
      { $1 } 
  |       
      { <code class="identifier">SynValTyparDecls</code>([], <code class="keyword">true</code>, []) }

<code class="identifier">opt_explicitValTyparDecls2</code>: 
  | <code class="identifier">explicitValTyparDecls</code> 
      { <code class="identifier">Some</code> $1 } 

  | <code class="comment">/* EMPTY */</code>      
      { <code class="identifier">None</code> }

<code class="comment">/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */</code>
<code class="comment">/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */</code>
<code class="identifier">opt_typeConstraints</code>:
  | <code class="comment">/* EMPTY */</code>
     { [] }

  | <code class="identifier">WHEN</code> <code class="identifier">typeConstraints</code> 
     { <code class="identifier">List</code>.<code class="identifier">rev</code> $2 }

<code class="comment">/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */</code>
<code class="comment">/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */</code>
<code class="identifier">typeConstraints</code>: 
  | <code class="identifier">typeConstraints</code> <code class="identifier">AND</code> <code class="identifier">typeConstraint</code>
     { $3 :: $1 } 

  | <code class="identifier">typeConstraint</code>
     { [$1] }

<code class="comment">/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */</code>
<code class="comment">/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */</code>
<code class="identifier">typeConstraint</code>: 
  | <code class="identifier">DEFAULT</code> <code class="identifier">typar</code> <code class="identifier">COLON</code> <code class="identifier">typ</code> 
     { <code class="identifier">libraryOnlyError</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>); <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparDefaultsToType</code>($2, $4, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">typar</code> <code class="identifier">COLON_GREATER</code> <code class="identifier">typ</code> 
     { <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparSubtypeOfType</code>($1, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">typar</code> <code class="identifier">COLON</code> <code class="identifier">STRUCT</code> 
     { <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparIsValueType</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">typar</code> <code class="identifier">COLON</code> <code class="identifier">IDENT</code> <code class="identifier">STRUCT</code> 
     { <code class="keyword">if</code> $3 &lt;&gt; <code class="string">"not"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedIdentifier</code>($3))  
       <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparIsReferenceType</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">typar</code> <code class="identifier">COLON</code> <code class="identifier">NULL</code> 
     { <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparSupportsNull</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">typar</code> <code class="identifier">COLON</code> <code class="identifier">LPAREN</code> <code class="identifier">classMemberSpfn</code> <code class="identifier">rparen</code> 
     { <code class="keyword">let</code> <code class="identifier">tp</code> = $1
       <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparSupportsMember</code>([ <code class="identifier">SynType</code>.<code class="identifier">Var</code>(<code class="identifier">tp</code>, <code class="identifier">tp</code>.<code class="identifier">Range</code>) ], $4, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">typarAlts</code> <code class="identifier">rparen</code> <code class="identifier">COLON</code> <code class="identifier">LPAREN</code> <code class="identifier">classMemberSpfn</code> <code class="identifier">rparen</code> 
     { <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparSupportsMember</code>(<code class="identifier">List</code>.<code class="identifier">rev</code>($2), $6, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">typar</code> <code class="identifier">COLON</code> <code class="identifier">DELEGATE</code> <code class="identifier">typeArgsNoHpaDeprecated</code>
     { <code class="keyword">let</code> <code class="identifier">_ltm</code>, <code class="identifier">_gtm</code>, <code class="identifier">args</code>, <code class="identifier">_commas</code>, <code class="identifier">mWhole</code> = $4
       <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparIsDelegate</code>($1, <code class="identifier">args</code>, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> <code class="identifier">mWhole</code>) }

  | <code class="identifier">typar</code> <code class="identifier">COLON</code> <code class="identifier">IDENT</code> <code class="identifier">typeArgsNoHpaDeprecated</code>
     { <code class="keyword">match</code> $3 <code class="keyword">with</code> 
       | <code class="string">"enum"</code> -&gt;
           <code class="keyword">let</code> <code class="identifier">_ltm</code>, <code class="identifier">_gtm</code>, <code class="identifier">args</code>, <code class="identifier">_commas</code>, <code class="identifier">mWhole</code> = $4
           <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparIsEnum</code>($1, <code class="identifier">args</code>, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> <code class="identifier">mWhole</code>)
       | <code class="identifier">nm</code> -&gt; <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedIdentifier</code>(<code class="identifier">nm</code>)) }

  | <code class="identifier">typar</code> <code class="identifier">COLON</code> <code class="identifier">IDENT</code> 
     { <code class="keyword">match</code> $3 <code class="keyword">with</code> 
       | <code class="string">"comparison"</code> -&gt; <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparIsComparable</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>)
       | <code class="string">"equality"</code> -&gt; <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparIsEquatable</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>)
       | <code class="string">"unmanaged"</code> -&gt; <code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparIsUnmanaged</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>)
       | <code class="identifier">nm</code> -&gt; <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedIdentifier</code>(<code class="identifier">nm</code>)) }

<code class="identifier">typarAlts</code>:
  | <code class="identifier">typarAlts</code> <code class="identifier">OR</code> <code class="identifier">appType</code>
     { $3 :: $1 }

  | <code class="identifier">appType</code>
     { [$1] }	

<code class="comment">/* The core of a union type definition */</code>
<code class="identifier">unionTypeRepr</code>:
  <code class="comment">/* Note the next three rules are required to disambiguate this from type x = y */</code>
  <code class="comment">/* Attributes can only appear on a single constructor if you've used a | */</code>
  | <code class="identifier">barAndgrabXmlDoc</code> <code class="identifier">attrUnionCaseDecls</code>  
     { $2 $1 }

  | <code class="identifier">firstUnionCaseDeclOfMany</code> <code class="identifier">barAndgrabXmlDoc</code> <code class="identifier">attrUnionCaseDecls</code>  
     { $1 :: $3 $2 }

  | <code class="identifier">firstUnionCaseDecl</code> 
     { [$1] } 

<code class="identifier">barAndgrabXmlDoc</code> : 
  | <code class="identifier">BAR</code>
     { <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 1) }

<code class="identifier">attrUnionCaseDecls</code>: 
  | <code class="identifier">attrUnionCaseDecl</code> <code class="identifier">barAndgrabXmlDoc</code> <code class="identifier">attrUnionCaseDecls</code>
     { (<code class="keyword">fun</code> <code class="identifier">xmlDoc</code> -&gt; $1 <code class="identifier">xmlDoc</code>  :: $3 $2) } 

  | <code class="identifier">attrUnionCaseDecl</code>
     { (<code class="keyword">fun</code> <code class="identifier">xmlDoc</code> -&gt; [ $1 <code class="identifier">xmlDoc</code> ]) }

<code class="comment">/* The core of a union case definition */</code>
<code class="identifier">attrUnionCaseDecl</code>:
  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_access</code> <code class="identifier">unionCaseName</code>
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnionCasesCannotHaveVisibilityDeclarations</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> <code class="identifier">mDecl</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3
        (<code class="keyword">fun</code> <code class="identifier">xmlDoc</code> -&gt; <code class="identifier">Choice2Of2</code> (<code class="identifier">SynUnionCase</code> ( $1, $3, <code class="identifier">SynUnionCaseKind</code>.<code class="identifier">Fields</code> [], <code class="identifier">xmlDoc</code>, <code class="identifier">None</code>, <code class="identifier">mDecl</code>))) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_access</code> <code class="identifier">unionCaseName</code> <code class="identifier">OF</code> <code class="identifier">unionCaseRepr</code>
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnionCasesCannotHaveVisibilityDeclarations</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> <code class="identifier">mDecl</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5
        (<code class="keyword">fun</code> <code class="identifier">xmlDoc</code> -&gt; <code class="identifier">Choice2Of2</code> (<code class="identifier">SynUnionCase</code> ( $1, $3, <code class="identifier">SynUnionCaseKind</code>.<code class="identifier">Fields</code> $5, <code class="identifier">xmlDoc</code>, <code class="identifier">None</code>, <code class="identifier">mDecl</code>))) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_access</code> <code class="identifier">unionCaseName</code> <code class="identifier">OF</code> <code class="identifier">recover</code>
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnionCasesCannotHaveVisibilityDeclarations</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> <code class="identifier">mDecl</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4
        (<code class="keyword">fun</code> <code class="identifier">xmlDoc</code> -&gt; <code class="identifier">Choice2Of2</code> (<code class="identifier">SynUnionCase</code> ( $1, $3, <code class="identifier">SynUnionCaseKind</code>.<code class="identifier">Fields</code> [], <code class="identifier">xmlDoc</code>, <code class="identifier">None</code>, <code class="identifier">mDecl</code>))) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_access</code> <code class="identifier">unionCaseName</code> <code class="identifier">COLON</code> <code class="identifier">topType</code>
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnionCasesCannotHaveVisibilityDeclarations</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="identifier">libraryOnlyWarning</code>(<code class="identifier">lhs</code> <code class="identifier">parseState</code>)
        <code class="keyword">let</code> <code class="identifier">mDecl</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5
        (<code class="keyword">fun</code> <code class="identifier">xmlDoc</code> -&gt; <code class="identifier">Choice2Of2</code> (<code class="identifier">SynUnionCase</code> ( $1, $3, <code class="identifier">SynUnionCaseKind</code>.<code class="identifier">FullType</code> $5, <code class="identifier">xmlDoc</code>, <code class="identifier">None</code>, <code class="identifier">mDecl</code>))) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">opt_access</code> <code class="identifier">unionCaseName</code> <code class="identifier">EQUALS</code> <code class="identifier">constant</code>
      { <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEnumFieldsCannotHaveVisibilityDeclarations</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
        <code class="keyword">let</code> <code class="identifier">mDecl</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5
        (<code class="keyword">fun</code> <code class="identifier">xmlDoc</code> -&gt; <code class="identifier">Choice1Of2</code> (<code class="identifier">SynEnumCase</code> ( $1, $3, <code class="identifier">fst</code> $5, <code class="identifier">snd</code> $5, <code class="identifier">xmlDoc</code>, <code class="identifier">mDecl</code>))) } 

<code class="comment">/* The name of a union case */</code>
<code class="identifier">unionCaseName</code>: 
  | <code class="identifier">nameop</code>  
      { $1 } 

  | <code class="identifier">LPAREN</code> <code class="identifier">COLON_COLON</code> <code class="identifier">rparen</code>  
      {  <code class="identifier">ident</code>(<code class="identifier">opNameCons</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) }  

  | <code class="identifier">LPAREN</code> <code class="identifier">LBRACK</code> <code class="identifier">RBRACK</code>  <code class="identifier">rparen</code>  
      {  <code class="identifier">ident</code>(<code class="identifier">opNameNil</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 2 3) }  

<code class="identifier">firstUnionCaseDeclOfMany</code>: 
  | <code class="identifier">ident</code> <code class="identifier">opt_OBLOCKSEP</code>
      { <code class="identifier">Choice2Of2</code> (<code class="identifier">SynUnionCase</code> ( [], $1, <code class="identifier">SynUnionCaseKind</code>.<code class="identifier">Fields</code> [], <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>, <code class="identifier">None</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)) } 

  | <code class="identifier">ident</code> <code class="identifier">EQUALS</code> <code class="identifier">constant</code> <code class="identifier">opt_OBLOCKSEP</code>
      { <code class="identifier">Choice1Of2</code> (<code class="identifier">SynEnumCase</code> ([], $1, <code class="identifier">fst</code> $3, <code class="identifier">snd</code> $3, <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3)) }

  | <code class="identifier">firstUnionCaseDecl</code> <code class="identifier">opt_OBLOCKSEP</code>
      { $1 }

<code class="identifier">firstUnionCaseDecl</code>: 
  | <code class="identifier">ident</code> <code class="identifier">OF</code> <code class="identifier">unionCaseRepr</code>  
     { <code class="identifier">Choice2Of2</code> (<code class="identifier">SynUnionCase</code> ( [], $1, <code class="identifier">SynUnionCaseKind</code>.<code class="identifier">Fields</code> $3, <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>, <code class="identifier">None</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3)) } 

  | <code class="identifier">ident</code> <code class="identifier">EQUALS</code> <code class="identifier">constant</code> <code class="identifier">opt_OBLOCKSEP</code>
      { <code class="identifier">Choice1Of2</code> (<code class="identifier">SynEnumCase</code> ([], $1, <code class="identifier">fst</code> $3, <code class="identifier">snd</code> $3, <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3))  }

<code class="identifier">unionCaseReprElements</code>:
  | <code class="identifier">unionCaseReprElement</code> <code class="identifier">STAR</code> <code class="identifier">unionCaseReprElements</code>
     { $1 :: $3 }

  | <code class="identifier">unionCaseReprElement</code> <code class="keyword">%prec</code> <code class="identifier">prec_toptuptyptail_prefix</code>
     { [$1] }

<code class="identifier">unionCaseReprElement</code>:
  | <code class="identifier">ident</code> <code class="identifier">COLON</code> <code class="identifier">appType</code>
     { <code class="keyword">let</code> <code class="identifier">wholeRange</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
       <code class="identifier">mkSynNamedField</code>($1, $3, <code class="identifier">wholeRange</code>) }

  | <code class="identifier">appType</code>
     { <code class="identifier">mkSynAnonField</code> $1 }

<code class="identifier">unionCaseRepr</code>:
  | <code class="identifier">braceFieldDeclList</code>
     { <code class="identifier">errorR</code>(<code class="identifier">Deprecated</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsConsiderUsingSeparateRecordType</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>)) 
       $1 }

  | <code class="identifier">unionCaseReprElements</code> 
     { $1 }

<code class="comment">/* A list of field declarations in a record type */</code>
<code class="identifier">recdFieldDeclList</code>: 
  | <code class="identifier">recdFieldDecl</code> <code class="identifier">seps</code> <code class="identifier">recdFieldDeclList</code> 
     { $1 :: $3 } 

  | <code class="identifier">recdFieldDecl</code> <code class="identifier">opt_seps</code>           
     { [$1] }

<code class="comment">/* A field declaration in a record type */</code>
<code class="identifier">recdFieldDecl</code>: 
  | <code class="identifier">opt_attributes</code> <code class="identifier">fieldDecl</code>
     { <code class="keyword">let</code> <code class="identifier">wholeRange</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2
       <code class="keyword">let</code> <code class="identifier">fld</code> = $2 $1 <code class="keyword">false</code> <code class="identifier">wholeRange</code>
       <code class="keyword">let</code> (<code class="identifier">SynField</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">e</code>, <code class="identifier">f</code>, <code class="identifier">vis</code>, <code class="identifier">wholeRange</code>)) = <code class="identifier">fld</code>
       <code class="keyword">if</code> <code class="identifier">Option</code>.<code class="identifier">isSome</code> <code class="identifier">vis</code> <code class="keyword">then</code> <code class="identifier">errorR</code> (<code class="identifier">Error</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsRecordFieldsCannotHaveVisibilityDeclarations</code> (), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))
       <code class="identifier">SynField</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">e</code>, <code class="identifier">f</code>, <code class="identifier">None</code>, <code class="identifier">wholeRange</code>) }

<code class="comment">/* Part of a field or val declaration in a record type or object type */</code>
<code class="identifier">fieldDecl</code>: 
  | <code class="identifier">opt_mutable</code> <code class="identifier">opt_access</code> <code class="identifier">ident</code> <code class="identifier">COLON</code>  <code class="identifier">typ</code> 
     { <code class="keyword">let</code> <code class="identifier">xmlDoc</code> = <code class="identifier">grabXmlDoc</code> (<code class="identifier">parseState</code>, 3)
       <code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">stat</code> <code class="identifier">wholeRange</code> -&gt; <code class="identifier">SynField</code>(<code class="identifier">attrs</code>, <code class="identifier">stat</code>, <code class="identifier">Some</code> $3, $5, $1, <code class="identifier">xmlDoc</code>, $2, <code class="identifier">wholeRange</code>) }

<code class="comment">/* An exception definition */</code>
<code class="identifier">exconDefn</code>: 
  | <code class="identifier">exconCore</code> <code class="identifier">opt_classDefn</code> 
     { <code class="identifier">SynExceptionDefn</code>($1, $2, ($1.<code class="identifier">Range</code>, $2) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> <code class="identifier">cd</code> -&gt; <code class="identifier">cd</code>.<code class="identifier">Range</code>) ) }

<code class="comment">/* Part of an exception definition */</code>
<code class="identifier">exceptionAndGrabDoc</code>:
  | <code class="identifier">EXCEPTION</code>
     { <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 1) }
  
<code class="comment">/* Part of an exception definition */</code>
<code class="identifier">exconCore</code>: 
  | <code class="identifier">exceptionAndGrabDoc</code> <code class="identifier">opt_attributes</code> <code class="identifier">opt_access</code> <code class="identifier">exconIntro</code> <code class="identifier">exconRepr</code> 
     { <code class="identifier">SynExceptionDefnRepr</code>($2, $4, $5, $1, $3, (<code class="keyword">match</code> $5 <code class="keyword">with</code> <code class="identifier">None</code> -&gt; <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4 | <code class="identifier">Some</code> <code class="identifier">p</code> -&gt; <code class="identifier">unionRanges</code> (<code class="identifier">rangeOfLongIdent</code> <code class="identifier">p</code>) (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4))) }
  
<code class="comment">/* Part of an exception definition */</code>
<code class="identifier">exconIntro</code>:
  | <code class="identifier">ident</code>
      { <code class="identifier">SynUnionCase</code>([], $1, <code class="identifier">SynUnionCaseKind</code>.<code class="identifier">Fields</code> [], <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>, <code class="identifier">None</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">ident</code> <code class="identifier">OF</code> <code class="identifier">unionCaseRepr</code>
      { <code class="identifier">SynUnionCase</code>([], $1, <code class="identifier">SynUnionCaseKind</code>.<code class="identifier">Fields</code> $3, <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>, <code class="identifier">None</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">ident</code> <code class="identifier">OF</code> <code class="identifier">recover</code>
      { <code class="identifier">SynUnionCase</code>([], $1, <code class="identifier">SynUnionCaseKind</code>.<code class="identifier">Fields</code> [], <code class="identifier">PreXmlDoc</code>.<code class="identifier">Empty</code>, <code class="identifier">None</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

<code class="identifier">exconRepr</code>: 
  | <code class="comment">/* EMPTY */</code>
     { <code class="identifier">None</code> }

  | <code class="identifier">EQUALS</code> <code class="identifier">path</code>
     { <code class="identifier">Some</code> ($2.<code class="identifier">Lid</code>) }

<code class="comment">/*-------------------------------------------------------------------------*/</code>
<code class="comment">/* F# Definitions, Types, Patterns and Expressions  */</code>

<code class="comment">/* A 'let ...' or 'do ...' statement in the non-#light syntax */</code>
<code class="identifier">defnBindings</code>: 
  | <code class="identifier">LET</code> <code class="identifier">opt_rec</code> <code class="identifier">localBindings</code> 
      { <code class="keyword">let</code> <code class="identifier">mLetKwd</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
        <code class="keyword">let</code> <code class="identifier">isUse</code> = $1
        <code class="keyword">let</code> <code class="identifier">isRec</code> = $2 
        <code class="keyword">let</code> <code class="identifier">localBindingsLastRangeOpt</code>, <code class="identifier">localBindingsBuilder</code> = $3
        
        <code class="comment">// Calculate the precise range of the binding set, up to the end of the last r.h.s. expression</code>
        <code class="keyword">let</code> <code class="identifier">bindingSetRange</code> = 
            <code class="keyword">match</code> <code class="identifier">localBindingsLastRangeOpt</code> <code class="keyword">with</code> 
            | <code class="identifier">None</code> -&gt; <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2 <code class="comment">(* there was some error - this will be an approximate range *)</code>
            | <code class="identifier">Some</code> <code class="identifier">lastRange</code> -&gt; <code class="identifier">unionRanges</code> <code class="identifier">mLetKwd</code> <code class="identifier">lastRange</code>

        <code class="comment">// The first binding swallows any attributes prior to the 'let'</code>
        <code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">mLetKwd</code>, <code class="identifier">isRec</code>, <code class="identifier">isUse</code>,
            (<code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> -&gt; 
                <code class="comment">// apply the builder</code>
                <code class="keyword">let</code> <code class="identifier">binds</code> = <code class="identifier">localBindingsBuilder</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> <code class="identifier">mLetKwd</code>
                <code class="keyword">if</code> <code class="keyword">not</code> <code class="identifier">isRec</code> &amp;&amp; <code class="keyword">not</code> (<code class="identifier">isNilOrSingleton</code> <code class="identifier">binds</code>) <code class="keyword">then</code> 
                      <code class="identifier">reportParseErrorAt</code> <code class="identifier">mLetKwd</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsLetAndForNonRecBindings</code>())
                [], <code class="identifier">binds</code>),
            <code class="identifier">bindingSetRange</code>) }

  | <code class="identifier">cPrototype</code>
      { <code class="keyword">let</code> <code class="identifier">bindRange</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code>
        <code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">bindRange</code>, <code class="keyword">false</code>, <code class="keyword">false</code>, $1, <code class="identifier">bindRange</code>)  }


<code class="comment">/* A 'do ...' statement in the non-#light syntax */</code>
<code class="identifier">doBinding</code>:
  | <code class="identifier">DO</code> <code class="identifier">typedSeqExprBlock</code> 
      { <code class="keyword">let</code> <code class="identifier">mDoKwd</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
        <code class="keyword">let</code> <code class="identifier">mWhole</code> = <code class="identifier">unionRanges</code> <code class="identifier">mDoKwd</code> $2.<code class="identifier">Range</code>
        <code class="comment">// any attributes prior to the 'let' are left free, e.g. become top-level attributes </code>
        <code class="comment">// associated with the module, 'main' function or assembly depending on their target </code>
        <code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">mDoKwd</code>, <code class="keyword">false</code>, <code class="keyword">false</code>, (<code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> -&gt; <code class="identifier">attrs</code>, [<code class="identifier">mkSynDoBinding</code> (<code class="identifier">vis</code>, <code class="keyword">true</code>, $2, <code class="identifier">mWhole</code>)]), <code class="identifier">mWhole</code>) }


<code class="comment">/* A 'let ....' binding in the #light syntax */</code>
<code class="identifier">hardwhiteLetBindings</code>: 
  | <code class="identifier">OLET</code> <code class="identifier">opt_rec</code> <code class="identifier">localBindings</code> <code class="identifier">hardwhiteDefnBindingsTerminator</code>
      { <code class="keyword">let</code> <code class="identifier">mLetKwd</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
        <code class="keyword">let</code> <code class="identifier">isUse</code> = $1
        <code class="keyword">let</code> <code class="identifier">isRec</code> = $2
        $4 (<code class="keyword">if</code> <code class="identifier">isUse</code> <code class="keyword">then</code> <code class="string">"use"</code> <code class="keyword">else</code> <code class="string">"let"</code>) <code class="identifier">mLetKwd</code>  <code class="comment">// report unterminated error </code>
        
        <code class="keyword">let</code> <code class="identifier">localBindingsLastRangeOpt</code>, <code class="identifier">localBindingsBuilder</code> = $3
        
        <code class="comment">// Calculate the precise range of the binding set, up to the end of the last r.h.s. expression</code>
        <code class="keyword">let</code> <code class="identifier">bindingSetRange</code> = 
            <code class="keyword">match</code> <code class="identifier">localBindingsLastRangeOpt</code> <code class="keyword">with</code> 
            | <code class="identifier">None</code> -&gt; <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 <code class="comment">(* there was some error - this will be an approximate range *)</code>
            | <code class="identifier">Some</code> <code class="identifier">lastRange</code> -&gt; <code class="identifier">unionRanges</code> <code class="identifier">mLetKwd</code> <code class="identifier">lastRange</code>

        <code class="comment">// the first binding swallow any attributes prior to the 'let' </code>
        <code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">mLetKwd</code>, <code class="identifier">isRec</code>, <code class="identifier">isUse</code>,
          (<code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> -&gt;
            <code class="keyword">let</code> <code class="identifier">binds</code> = <code class="identifier">localBindingsBuilder</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> <code class="identifier">mLetKwd</code>
            <code class="keyword">if</code> <code class="keyword">not</code> <code class="identifier">isRec</code> &amp;&amp; <code class="keyword">not</code> (<code class="identifier">isNilOrSingleton</code> <code class="identifier">binds</code>) <code class="keyword">then</code>
                <code class="identifier">reportParseErrorAt</code> <code class="identifier">mLetKwd</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsLetAndForNonRecBindings</code>())
            [], <code class="identifier">binds</code>),
          <code class="identifier">bindingSetRange</code>), (<code class="identifier">unionRanges</code> <code class="identifier">mLetKwd</code> <code class="identifier">bindingSetRange</code>) }


<code class="comment">/* A 'do ...' statement */</code>
<code class="identifier">hardwhiteDoBinding</code>: 
  | <code class="identifier">ODO</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">hardwhiteDefnBindingsTerminator</code>          
      { <code class="keyword">let</code> <code class="identifier">mLetKwd</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
        <code class="keyword">let</code> <code class="identifier">bindingSetRange</code> = <code class="identifier">unionRanges</code> <code class="identifier">mLetKwd</code> $2.<code class="identifier">Range</code> 
        <code class="keyword">let</code> <code class="identifier">seqPt</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtDo</code> 
        <code class="comment">// any attributes prior to the 'let' are left free, e.g. become top-level attributes </code>
        <code class="comment">// associated with the module, 'main' function or assembly depending on their target </code>
        <code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">mLetKwd</code>, <code class="keyword">false</code>, <code class="keyword">false</code>, (<code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> -&gt; <code class="identifier">attrs</code>, [<code class="identifier">mkSynDoBinding</code> (<code class="identifier">vis</code>, <code class="keyword">true</code>, $2, <code class="identifier">bindingSetRange</code>)]), <code class="identifier">bindingSetRange</code>), $2 }


<code class="comment">/* The bindings in a class type definition */</code>
<code class="identifier">classDefnBindings</code>: 
  | <code class="identifier">defnBindings</code>
     { $1 }

  | <code class="identifier">doBinding</code>
     { $1 }

  | <code class="identifier">hardwhiteLetBindings</code>
     { <code class="keyword">let</code> <code class="identifier">b</code>, <code class="identifier">m</code> = $1 <code class="keyword">in</code> <code class="identifier">b</code> } 

  | <code class="identifier">hardwhiteDoBinding</code>
     { <code class="identifier">fst</code> $1 }


<code class="comment">/* The terminator for a 'let ....' binding in the #light syntax */</code>
<code class="identifier">hardwhiteDefnBindingsTerminator</code>:
  |  <code class="identifier">ODECLEND</code>
     { (<code class="keyword">fun</code> <code class="identifier">_</code> <code class="identifier">m</code> -&gt; ()) }

  |  <code class="identifier">recover</code> 
     { (<code class="keyword">fun</code> <code class="identifier">kwd</code> <code class="identifier">m</code> -&gt;
         <code class="keyword">let</code> <code class="identifier">msg</code> = 
             <code class="keyword">match</code> <code class="identifier">kwd</code> <code class="keyword">with</code> 
             | <code class="string">"let!"</code> -&gt; <code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedLetBang</code>() 
             | <code class="string">"use!"</code> -&gt; <code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedUseBang</code>() 
             | <code class="string">"use"</code> -&gt; <code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedUse</code>() 
             | <code class="identifier">_</code> <code class="comment">(*"let" *)</code> -&gt; <code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedLet</code>()
         <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> <code class="identifier">msg</code>) }

<code class="comment">/* An 'extern' DllImport function definition in C-style syntax */</code>
<code class="identifier">cPrototype</code>: 
  | <code class="identifier">EXTERN</code> <code class="identifier">cRetType</code> <code class="identifier">opt_access</code> <code class="identifier">ident</code> <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="identifier">LPAREN</code> <code class="identifier">cArgs</code> <code class="identifier">rparen</code> 
      { <code class="keyword">let</code> <code class="identifier">rty</code>, <code class="identifier">vis</code>, <code class="identifier">nm</code>, <code class="identifier">args</code>  = $2, $3, $4, $7 
        <code class="keyword">let</code> <code class="identifier">xmlDoc</code> = <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 1) 
        <code class="keyword">let</code> <code class="identifier">nmm</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3 
        <code class="keyword">let</code> <code class="identifier">argsm</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 6 
        <code class="keyword">let</code> <code class="identifier">mBindLhs</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code>
        <code class="keyword">let</code> <code class="identifier">mWhole</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code>
        <code class="keyword">let</code> <code class="identifier">mRhs</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
        <code class="keyword">let</code> <code class="identifier">rhsExpr</code> = <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">ExprAtomicFlag</code>.<code class="identifier">NonAtomic</code>,
                                  <code class="keyword">false</code>,
                                  <code class="identifier">SynExpr</code>.<code class="identifier">Ident</code> (<code class="identifier">ident</code>(<code class="string">"failwith"</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 6)),
                                  <code class="identifier">SynExpr</code>.<code class="identifier">Const</code> (<code class="identifier">SynConst</code>.<code class="identifier">String</code>(<code class="string">"extern was not given a DllImport attribute"</code>, <code class="identifier">SynStringKind</code>.<code class="identifier">Regular</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 8), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 8),
                                  <code class="identifier">mRhs</code>)
        (<code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">_</code> -&gt; 
            <code class="keyword">let</code> <code class="identifier">bindingId</code> = <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">LongIdentWithDots</code>([<code class="identifier">nm</code>], []), <code class="identifier">None</code>, <code class="identifier">Some</code> <code class="identifier">noInferredTypars</code>, <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> [<code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, <code class="identifier">args</code>, <code class="identifier">argsm</code>)], <code class="identifier">vis</code>, <code class="identifier">nmm</code>)
            <code class="keyword">let</code> <code class="identifier">binding</code> = <code class="identifier">mkSynBinding</code> 
                              (<code class="identifier">xmlDoc</code>, <code class="identifier">bindingId</code>) 
                              (<code class="identifier">vis</code>, <code class="keyword">false</code>, <code class="keyword">false</code>, <code class="identifier">mBindLhs</code>, <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtInvisible</code>, <code class="identifier">Some</code> <code class="identifier">rty</code>, <code class="identifier">rhsExpr</code>, <code class="identifier">mRhs</code>, [], <code class="identifier">attrs</code>, <code class="identifier">None</code>)
            [], [<code class="identifier">binding</code>]) }

<code class="comment">/* A list of arguments in an 'extern' DllImport function definition */</code>
<code class="identifier">cArgs</code>: 
  | <code class="identifier">cMoreArgs</code> 
     { <code class="identifier">List</code>.<code class="identifier">rev</code> $1 }

  | <code class="identifier">cArg</code> 
     { [$1] }
  |       
     { [] }
  

<code class="comment">/* Part of the list of arguments in an 'extern' DllImport function definition */</code>
<code class="identifier">cMoreArgs</code>: 
  | <code class="identifier">cMoreArgs</code> <code class="identifier">COMMA</code> <code class="identifier">cArg</code> 
     { $3 :: $1 }

  | <code class="identifier">cArg</code> <code class="identifier">COMMA</code> <code class="identifier">cArg</code> 
     { [$3; $1] }


<code class="comment">/* A single argument in an 'extern' DllImport function definition */</code>
<code class="identifier">cArg</code>: 
  | <code class="identifier">opt_attributes</code> <code class="identifier">cType</code>       
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> <code class="keyword">in</code> <code class="identifier">SynPat</code>.<code class="identifier">Typed</code>(<code class="identifier">SynPat</code>.<code class="identifier">Wild</code> <code class="identifier">m</code>, $2, <code class="identifier">m</code>) |&gt; <code class="identifier">addAttribs</code> $1 }

  | <code class="identifier">opt_attributes</code> <code class="identifier">cType</code> <code class="identifier">ident</code> 
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> <code class="keyword">in</code> <code class="identifier">SynPat</code>.<code class="identifier">Typed</code>(<code class="identifier">SynPat</code>.<code class="identifier">Named</code> (<code class="identifier">SynPat</code>.<code class="identifier">Wild</code> <code class="identifier">m</code>, $3, <code class="keyword">false</code>, <code class="identifier">None</code>, <code class="identifier">m</code>), $2, <code class="identifier">m</code>) |&gt; <code class="identifier">addAttribs</code> $1 }

<code class="comment">/* An type in an 'extern' DllImport function definition */</code>
<code class="identifier">cType</code>: 
  | <code class="identifier">path</code>      
     { <code class="keyword">let</code> <code class="identifier">m</code> = $1.<code class="identifier">Range</code>
       <code class="identifier">SynType</code>.<code class="identifier">App</code>(<code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>($1), <code class="identifier">None</code>, [], [], <code class="identifier">None</code>, <code class="keyword">false</code>, <code class="identifier">m</code>) } 

  | <code class="identifier">cType</code> <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="identifier">LBRACK</code> <code class="identifier">RBRACK</code> 
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
       <code class="identifier">SynType</code>.<code class="identifier">App</code>(<code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>(<code class="identifier">LongIdentWithDots</code>([<code class="identifier">ident</code>(<code class="string">"[]"</code>, <code class="identifier">m</code>)], [])), <code class="identifier">None</code>, [$1], [], <code class="identifier">None</code>, <code class="keyword">true</code>, <code class="identifier">m</code>) } 

  | <code class="identifier">cType</code> <code class="identifier">STAR</code> 
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
       <code class="identifier">SynType</code>.<code class="identifier">App</code>(<code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>(<code class="identifier">LongIdentWithDots</code>([<code class="identifier">ident</code>(<code class="string">"nativeptr"</code>, <code class="identifier">m</code>)], [])), <code class="identifier">None</code>, [$1], [], <code class="identifier">None</code>, <code class="keyword">true</code>, <code class="identifier">m</code>) } 

  | <code class="identifier">cType</code> <code class="identifier">AMP</code>  
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
       <code class="identifier">SynType</code>.<code class="identifier">App</code>(<code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>(<code class="identifier">LongIdentWithDots</code>([<code class="identifier">ident</code>(<code class="string">"byref"</code>, <code class="identifier">m</code>)], [])), <code class="identifier">None</code>, [$1], [], <code class="identifier">None</code>, <code class="keyword">true</code>, <code class="identifier">m</code>) } 

  | <code class="identifier">VOID</code> <code class="identifier">STAR</code> 
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
       <code class="identifier">SynType</code>.<code class="identifier">App</code>(<code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>(<code class="identifier">LongIdentWithDots</code>([<code class="identifier">ident</code>(<code class="string">"nativeint"</code>, <code class="identifier">m</code>)], [])), <code class="identifier">None</code>, [], [], <code class="identifier">None</code>, <code class="keyword">true</code>, <code class="identifier">m</code>) } 


<code class="comment">/* A return type in an 'extern' DllImport function definition */</code>
<code class="identifier">cRetType</code>: 
  | <code class="identifier">opt_attributes</code> <code class="identifier">cType</code> 
     { <code class="identifier">SynReturnInfo</code>(($2, <code class="identifier">SynArgInfo</code>($1, <code class="keyword">false</code>, <code class="identifier">None</code>)), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) }

  | <code class="identifier">opt_attributes</code> <code class="identifier">VOID</code>  
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2 
       <code class="identifier">SynReturnInfo</code>((<code class="identifier">SynType</code>.<code class="identifier">App</code>(<code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>(<code class="identifier">LongIdentWithDots</code>([<code class="identifier">ident</code>(<code class="string">"unit"</code>, <code class="identifier">m</code>)], [])), <code class="identifier">None</code>, [], [], <code class="identifier">None</code>, <code class="keyword">false</code>, <code class="identifier">m</code>), <code class="identifier">SynArgInfo</code>($1, <code class="keyword">false</code>, <code class="identifier">None</code>)), <code class="identifier">m</code>) } 


<code class="identifier">localBindings</code>: 
  | <code class="identifier">attr_localBinding</code> <code class="identifier">moreLocalBindings</code> 
      { <code class="keyword">let</code> (<code class="identifier">moreBindings</code>, <code class="identifier">moreBindingRanges</code>) = <code class="identifier">List</code>.<code class="identifier">unzip</code> $2
        <code class="keyword">let</code> <code class="identifier">moreLocalBindingsLastRange</code> = <code class="keyword">if</code> <code class="identifier">moreBindingRanges</code>.<code class="identifier">IsEmpty</code> <code class="keyword">then</code> <code class="identifier">None</code> <code class="keyword">else</code> <code class="identifier">Some</code> (<code class="identifier">List</code>.<code class="identifier">last</code> <code class="identifier">moreBindingRanges</code>)
        <code class="keyword">match</code> $1 <code class="keyword">with</code> 
        | <code class="identifier">Some</code> (<code class="identifier">localBindingRange</code>, <code class="identifier">attrLocalBindingBuilder</code>) -&gt; 
           <code class="keyword">let</code> <code class="identifier">lastRange</code> = 
               <code class="keyword">match</code> <code class="identifier">moreLocalBindingsLastRange</code> <code class="keyword">with</code> 
               | <code class="identifier">None</code> -&gt; <code class="identifier">localBindingRange</code> 
               | <code class="identifier">Some</code> <code class="identifier">m</code> -&gt; <code class="identifier">m</code>
           <code class="identifier">Some</code> <code class="identifier">lastRange</code>, (<code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> <code class="identifier">mLetKwd</code> -&gt; <code class="identifier">attrLocalBindingBuilder</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> <code class="identifier">mLetKwd</code> <code class="keyword">true</code> ::  <code class="identifier">moreBindings</code>)
        | <code class="identifier">None</code> -&gt; 
           <code class="identifier">moreLocalBindingsLastRange</code>, (<code class="keyword">fun</code> <code class="identifier">_attrs</code> <code class="identifier">_vis</code> <code class="identifier">_letm</code> -&gt; <code class="identifier">moreBindings</code>) }


<code class="identifier">moreLocalBindings</code>: 
  | <code class="identifier">AND</code> <code class="identifier">attr_localBinding</code> <code class="identifier">moreLocalBindings</code> 
      { <code class="keyword">let</code> <code class="identifier">mLetKwd</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
        (<code class="keyword">match</code> $2 <code class="keyword">with</code> 
         | <code class="identifier">Some</code> (<code class="identifier">localBindingRange</code>, <code class="identifier">attrLocalBindingBuilder</code>) -&gt; (<code class="identifier">attrLocalBindingBuilder</code> [] <code class="identifier">None</code> <code class="identifier">mLetKwd</code> <code class="keyword">false</code>, <code class="identifier">localBindingRange</code>) :: $3 
         | <code class="identifier">None</code> -&gt; $3) }

  | <code class="keyword">%prec</code> <code class="identifier">prec_no_more_attr_bindings</code> 
      { [] }


<code class="comment">/* A single binding, possibly with custom attributes */</code>
<code class="identifier">attr_localBinding</code>: 
  | <code class="identifier">opt_attributes</code> <code class="identifier">localBinding</code> 
      { <code class="keyword">let</code> <code class="identifier">attrs2</code> = $1
        <code class="keyword">let</code> <code class="identifier">localBindingRange</code>, <code class="identifier">localBindingBuilder</code> = $2
        <code class="keyword">let</code> <code class="identifier">attrLocalBindingBuilder</code> = (<code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> <code class="identifier">mLetKwd</code> <code class="identifier">_</code> -&gt; <code class="identifier">localBindingBuilder</code> (<code class="identifier">attrs</code>@<code class="identifier">attrs2</code>) <code class="identifier">vis</code> <code class="identifier">mLetKwd</code>)
        <code class="identifier">Some</code>(<code class="identifier">localBindingRange</code>, <code class="identifier">attrLocalBindingBuilder</code>) }

  | <code class="keyword">error</code> 
      { <code class="identifier">None</code> }


<code class="comment">/* A single binding in an expression or definition */</code>
<code class="identifier">localBinding</code>: 
  | <code class="identifier">opt_inline</code> <code class="identifier">opt_mutable</code> <code class="identifier">bindingPattern</code> <code class="identifier">opt_topReturnTypeWithTypeConstraints</code> <code class="identifier">EQUALS</code> <code class="identifier">typedExprWithStaticOptimizationsBlock</code> 
      { <code class="keyword">let</code> (<code class="identifier">expr</code>:<code class="identifier">SynExpr</code>), <code class="identifier">opts</code> = $6
        <code class="keyword">let</code> <code class="identifier">eqm</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 5 
        <code class="keyword">let</code> <code class="identifier">mRhs</code> = <code class="identifier">expr</code>.<code class="identifier">Range</code> 
        <code class="keyword">let</code> <code class="identifier">optReturnType</code> = $4 
        <code class="keyword">let</code> <code class="identifier">bindingBuilder</code>, <code class="identifier">mBindLhs</code> = $3 
        <code class="keyword">let</code> <code class="identifier">localBindingRange</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5) <code class="identifier">mRhs</code>
        <code class="keyword">let</code> <code class="identifier">localBindingBuilder</code> = 
          (<code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> <code class="identifier">mLetKwd</code> -&gt; 
            <code class="keyword">let</code> <code class="identifier">mWhole</code> = <code class="identifier">unionRanges</code> <code class="identifier">mLetKwd</code> <code class="identifier">mRhs</code>
            <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="keyword">if</code> <code class="identifier">IsControlFlowExpression</code> <code class="identifier">expr</code> <code class="keyword">then</code> <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtLet</code> <code class="keyword">else</code> <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code> <code class="identifier">mWhole</code>
            <code class="identifier">bindingBuilder</code> (<code class="identifier">vis</code>, $1, $2, <code class="identifier">mBindLhs</code>, <code class="identifier">spBind</code>, <code class="identifier">optReturnType</code>, <code class="identifier">expr</code>, <code class="identifier">mRhs</code>, <code class="identifier">opts</code>, <code class="identifier">attrs</code>, <code class="identifier">None</code>))
        <code class="identifier">localBindingRange</code>, <code class="identifier">localBindingBuilder</code> }

  | <code class="identifier">opt_inline</code> <code class="identifier">opt_mutable</code> <code class="identifier">bindingPattern</code>  <code class="identifier">opt_topReturnTypeWithTypeConstraints</code> <code class="identifier">EQUALS</code>  <code class="keyword">error</code>
      { <code class="keyword">let</code> <code class="identifier">mWhole</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5 
        <code class="keyword">let</code> <code class="identifier">mRhs</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 5
        <code class="keyword">let</code> <code class="identifier">optReturnType</code> = $4 
        <code class="keyword">let</code> <code class="identifier">bindingBuilder</code>, <code class="identifier">mBindLhs</code> = $3 
        <code class="keyword">let</code> <code class="identifier">localBindingBuilder</code> = 
          (<code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> <code class="identifier">mLetKwd</code> -&gt; 
            <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code> (<code class="identifier">unionRanges</code> <code class="identifier">mLetKwd</code> <code class="identifier">mRhs</code>)
            <code class="keyword">let</code> <code class="identifier">eqm</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 5
            <code class="keyword">let</code> <code class="identifier">zeroWidthAtEnd</code> = <code class="identifier">eqm</code>.<code class="identifier">EndRange</code>
            <code class="identifier">bindingBuilder</code> (<code class="identifier">vis</code>, $1, $2, <code class="identifier">mBindLhs</code>, <code class="identifier">spBind</code>, <code class="identifier">optReturnType</code>, <code class="identifier">arbExpr</code>(<code class="string">"localBinding1"</code>, <code class="identifier">zeroWidthAtEnd</code>), <code class="identifier">mRhs</code>, [], <code class="identifier">attrs</code>, <code class="identifier">None</code>))  
        <code class="identifier">mWhole</code>, <code class="identifier">localBindingBuilder</code> }

  | <code class="identifier">opt_inline</code> <code class="identifier">opt_mutable</code> <code class="identifier">bindingPattern</code>  <code class="identifier">opt_topReturnTypeWithTypeConstraints</code> <code class="identifier">recover</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> $5 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 5) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileDefinition</code>())
        <code class="keyword">let</code> <code class="identifier">optReturnType</code> = $4 
        <code class="keyword">let</code> <code class="identifier">mWhole</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 (<code class="keyword">match</code> <code class="identifier">optReturnType</code> <code class="keyword">with</code> <code class="identifier">None</code> -&gt; 3 | <code class="identifier">_</code> -&gt; 4)
        <code class="keyword">let</code> <code class="identifier">mRhs</code> = <code class="identifier">mWhole</code>.<code class="identifier">EndRange</code>  <code class="comment">// zero-width range at end of last good token</code>
        <code class="keyword">let</code> <code class="identifier">bindingBuilder</code>, <code class="identifier">mBindLhs</code> = $3 
        <code class="keyword">let</code> <code class="identifier">localBindingBuilder</code> = 
          (<code class="keyword">fun</code> <code class="identifier">attrs</code> <code class="identifier">vis</code> <code class="identifier">mLetKwd</code> -&gt; 
            <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code> (<code class="identifier">unionRanges</code> <code class="identifier">mLetKwd</code> <code class="identifier">mRhs</code>)
            <code class="identifier">bindingBuilder</code> (<code class="identifier">vis</code>, $1, $2, <code class="identifier">mBindLhs</code>, <code class="identifier">spBind</code>, <code class="identifier">optReturnType</code>, <code class="identifier">arbExpr</code>(<code class="string">"localBinding2"</code>, <code class="identifier">mRhs</code>), <code class="identifier">mRhs</code>, [], <code class="identifier">attrs</code>, <code class="identifier">None</code>))  
        <code class="identifier">mWhole</code>, <code class="identifier">localBindingBuilder</code> }


<code class="comment">/* A single expression with an optional type annotation, and an optional static optimization block */</code>
<code class="identifier">typedExprWithStaticOptimizationsBlock</code>: 
  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">typedExprWithStaticOptimizations</code> <code class="identifier">oblockend</code> 
      { $2 }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">typedExprWithStaticOptimizations</code> <code class="identifier">recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFile</code>())
        <code class="keyword">let</code> <code class="identifier">a</code>, <code class="identifier">b</code> = $2
        (<code class="identifier">exprFromParseError</code> <code class="identifier">a</code>, <code class="identifier">b</code>) }

  | <code class="identifier">typedExprWithStaticOptimizations</code> 
      { $1 }

<code class="identifier">typedExprWithStaticOptimizations</code> : 
  | <code class="identifier">typedSeqExpr</code> <code class="identifier">opt_staticOptimizations</code>
      { $1, <code class="identifier">List</code>.<code class="identifier">rev</code> $2 }

<code class="identifier">opt_staticOptimizations</code>: 
  | <code class="identifier">opt_staticOptimizations</code> <code class="identifier">staticOptimization</code>
      { $2 :: $1 } 

  | <code class="comment">/* EMPTY */</code>
      { [] }

<code class="identifier">staticOptimization</code>: 
  | <code class="identifier">WHEN</code> <code class="identifier">staticOptimizationConditions</code> <code class="identifier">EQUALS</code> <code class="identifier">typedSeqExprBlock</code>
      { ($2, $4) }

<code class="identifier">staticOptimizationConditions</code>: 
  | <code class="identifier">staticOptimizationConditions</code> <code class="identifier">AND</code> <code class="identifier">staticOptimizationCondition</code>
      { $3 :: $1 } 

  | <code class="identifier">staticOptimizationCondition</code>
      { [$1 ] }

<code class="identifier">staticOptimizationCondition</code>: 
  | <code class="identifier">typar</code> <code class="identifier">COLON</code> <code class="identifier">typ</code>
      { <code class="identifier">SynStaticOptimizationConstraint</code>.<code class="identifier">WhenTyparTyconEqualsTycon</code>($1, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">typar</code> <code class="identifier">STRUCT</code>
      { <code class="identifier">SynStaticOptimizationConstraint</code>.<code class="identifier">WhenTyparIsStruct</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

<code class="identifier">rawConstant</code>: 
  | <code class="identifier">INT8</code>
    { <code class="keyword">if</code> <code class="identifier">snd</code> $1 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexOutsideEightBitSigned</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
      <code class="identifier">SynConst</code>.<code class="identifier">SByte</code> (<code class="identifier">fst</code> $1) } 

  | <code class="identifier">UINT8</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">Byte</code> $1 } 

  | <code class="identifier">INT16</code>
    { <code class="keyword">if</code> <code class="identifier">snd</code> $1 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexOutsideSixteenBitSigned</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
      <code class="identifier">SynConst</code>.<code class="identifier">Int16</code> (<code class="identifier">fst</code> $1) } 

  | <code class="identifier">UINT16</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">UInt16</code> $1 } 

  | <code class="identifier">INT32</code>
    { <code class="keyword">if</code> <code class="identifier">snd</code> $1 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexOutsideThirtyTwoBitSigned</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
      <code class="identifier">SynConst</code>.<code class="identifier">Int32</code> (<code class="identifier">fst</code> $1) } 

  | <code class="identifier">UINT32</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">UInt32</code> $1 } 

  | <code class="identifier">INT64</code>
    { <code class="keyword">if</code> <code class="identifier">snd</code> $1 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexOutsideSixtyFourBitSigned</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
      <code class="identifier">SynConst</code>.<code class="identifier">Int64</code> (<code class="identifier">fst</code> $1) } 

  | <code class="identifier">UINT64</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">UInt64</code> $1 } 

  | <code class="identifier">NATIVEINT</code>
    { <code class="keyword">if</code> <code class="identifier">snd</code> $1 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexOutsideNativeSigned</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
      <code class="identifier">SynConst</code>.<code class="identifier">IntPtr</code> (<code class="identifier">fst</code> $1) } 

  | <code class="identifier">UNATIVEINT</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">UIntPtr</code> $1 } 

  | <code class="identifier">IEEE32</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">Single</code> $1 } 

  | <code class="identifier">IEEE64</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">Double</code> $1 } 

  | <code class="identifier">CHAR</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">Char</code> $1 } 

  | <code class="identifier">DECIMAL</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">Decimal</code> $1 } 

  | <code class="identifier">BIGNUM</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">UserNum</code> $1 } 

  | <code class="identifier">stringOrKeywordString</code>
    { <code class="keyword">let</code> <code class="identifier">s</code>, <code class="identifier">synStringKind</code> = $1
      <code class="identifier">SynConst</code>.<code class="identifier">String</code> (<code class="identifier">s</code>, <code class="identifier">synStringKind</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

  | <code class="identifier">BYTEARRAY</code>
    { <code class="keyword">let</code> (<code class="identifier">v</code>, <code class="identifier">synByteStringKind</code>, <code class="identifier">_</code>) = $1
      <code class="identifier">SynConst</code>.<code class="identifier">Bytes</code> (<code class="identifier">v</code>, <code class="identifier">synByteStringKind</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

<code class="identifier">rationalConstant</code>:
  | <code class="identifier">INT32</code> <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> <code class="identifier">INT32</code>
    { <code class="keyword">if</code> $2 &lt;&gt; <code class="string">"/"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedOperatorForUnitOfMeasure</code>())
      <code class="keyword">if</code> <code class="identifier">fst</code> $3 = 0 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIllegalDenominatorForMeasureExponent</code>())
      <code class="keyword">if</code> (<code class="identifier">snd</code> $1) || (<code class="identifier">snd</code> $3) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexOutsideThirtyTwoBitSigned</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
      <code class="identifier">SynRationalConst</code>.<code class="identifier">Rational</code>(<code class="identifier">fst</code> $1, <code class="identifier">fst</code> $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">MINUS</code> <code class="identifier">INT32</code> <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> <code class="identifier">INT32</code> 
    { <code class="keyword">if</code> $3 &lt;&gt; <code class="string">"/"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedOperatorForUnitOfMeasure</code>())
      <code class="keyword">if</code> <code class="identifier">fst</code> $4 = 0 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 4) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIllegalDenominatorForMeasureExponent</code>())
      <code class="keyword">if</code> (<code class="identifier">snd</code> $2) || (<code class="identifier">snd</code> $4) <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexOutsideThirtyTwoBitSigned</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
      <code class="identifier">SynRationalConst</code>.<code class="identifier">Negate</code>(<code class="identifier">SynRationalConst</code>.<code class="identifier">Rational</code>(<code class="identifier">fst</code> $2, <code class="identifier">fst</code> $4, <code class="identifier">lhs</code> <code class="identifier">parseState</code>)) }

  | <code class="identifier">INT32</code>
    { <code class="keyword">if</code> <code class="identifier">snd</code> $1 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexOutsideThirtyTwoBitSigned</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
      <code class="identifier">SynRationalConst</code>.<code class="identifier">Integer</code>(<code class="identifier">fst</code> $1) }

  | <code class="identifier">MINUS</code> <code class="identifier">INT32</code>
    { <code class="keyword">if</code> <code class="identifier">snd</code> $2 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexOutsideThirtyTwoBitSigned</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
      <code class="identifier">SynRationalConst</code>.<code class="identifier">Negate</code>(<code class="identifier">SynRationalConst</code>.<code class="identifier">Integer</code>(<code class="identifier">fst</code> $2)) }

<code class="identifier">atomicUnsignedRationalConstant</code>:
  | <code class="identifier">INT32</code> { <code class="keyword">if</code> <code class="identifier">snd</code> $1 <code class="keyword">then</code> <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">lexOutsideThirtyTwoBitSigned</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
            <code class="identifier">SynRationalConst</code>.<code class="identifier">Integer</code>(<code class="identifier">fst</code> $1) }

  | <code class="identifier">LPAREN</code> <code class="identifier">rationalConstant</code> <code class="identifier">rparen</code>
    { $2 }

<code class="identifier">atomicRationalConstant</code>:
  | <code class="identifier">atomicUnsignedRationalConstant</code> { $1 }

  | <code class="identifier">MINUS</code> <code class="identifier">atomicUnsignedRationalConstant</code>
    { <code class="identifier">SynRationalConst</code>.<code class="identifier">Negate</code>($2) }

<code class="identifier">constant</code>: 
  | <code class="identifier">rawConstant</code>
    { $1, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 }

  | <code class="identifier">rawConstant</code> <code class="identifier">HIGH_PRECEDENCE_TYAPP</code> <code class="identifier">measureTypeArg</code>
    { <code class="identifier">SynConst</code>.<code class="identifier">Measure</code>($1, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, $3), <code class="identifier">lhs</code> <code class="identifier">parseState</code> }

<code class="identifier">bindingPattern</code>:
  | <code class="identifier">headBindingPattern</code>
     
      { <code class="comment">// Adds a grab point at the start of the binding, so as not to include XML doc comments on the arguments</code>
        <code class="keyword">let</code> <code class="identifier">xmlDoc</code> = <code class="identifier">LexbufLocalXmlDocStore</code>.<code class="identifier">GrabXmlDocBeforeMarker</code>(<code class="identifier">parseState</code>.<code class="identifier">LexBuffer</code>, (<code class="identifier">lhs</code> <code class="identifier">parseState</code>).<code class="identifier">StartRange</code>)
        <code class="comment">// Adds grab point at the end of the binding head, so subsequent types don't erroneously include argument doc comemnts</code>
        <code class="identifier">grabXmlDoc</code>(<code class="identifier">parseState</code>, 1) |&gt; <code class="identifier">ignore</code>
     
        <code class="identifier">mkSynBinding</code> (<code class="identifier">xmlDoc</code>, $1), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 }

<code class="comment">// Subset of patterns allowed to be used in implicit ctors.</code>
<code class="comment">// For a better error recovery we could replace these rules with the actual SynPat parsing</code>
<code class="comment">// and use allowed patterns only at a later analysis stage reporting errors along the way.</code>
<code class="identifier">simplePattern</code>:
  | <code class="identifier">ident</code>
      { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
        <code class="identifier">SynPat</code>.<code class="identifier">Named</code>(<code class="identifier">SynPat</code>.<code class="identifier">Wild</code> <code class="identifier">m</code>, $1, <code class="keyword">false</code>, <code class="identifier">None</code>, <code class="identifier">m</code>) }

  | <code class="identifier">QMARK</code> <code class="identifier">ident</code>
      { <code class="identifier">SynPat</code>.<code class="identifier">OptionalVal</code>($2, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) }

  | <code class="identifier">simplePattern</code> <code class="identifier">COLON</code> <code class="identifier">typeWithTypeConstraints</code>
      { <code class="identifier">SynPat</code>.<code class="identifier">Typed</code>($1, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">attributes</code> <code class="identifier">simplePattern</code> <code class="keyword">%prec</code> <code class="identifier">paren_pat_attribs</code>
      { <code class="identifier">SynPat</code>.<code class="identifier">Attrib</code>($2, $1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

<code class="identifier">simplePatternCommaList</code>:
  | <code class="identifier">simplePattern</code>
      { $1 }

  | <code class="identifier">simplePattern</code> <code class="identifier">COMMA</code> <code class="identifier">simplePatternCommaList</code>
      { <code class="keyword">match</code> $3 <code class="keyword">with</code>
        | <code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="identifier">_</code>, <code class="identifier">pats</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, $1 :: <code class="identifier">pats</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3)
        | <code class="identifier">_</code> -&gt; <code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, [$1; $3], <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

<code class="identifier">simplePatterns</code>:
  | <code class="identifier">LPAREN</code> <code class="identifier">simplePatternCommaList</code> <code class="identifier">rparen</code>
      { <code class="keyword">let</code> <code class="identifier">parenPat</code> = <code class="identifier">SynPat</code>.<code class="identifier">Paren</code>($2, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3)
        <code class="keyword">let</code> <code class="identifier">simplePats</code>, <code class="identifier">_</code> = <code class="identifier">SimplePatsOfPat</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="identifier">parenPat</code>
        <code class="identifier">simplePats</code> }

  | <code class="identifier">LPAREN</code> <code class="identifier">rparen</code>
      { <code class="keyword">let</code> <code class="identifier">pat</code> = <code class="identifier">SynPat</code>.<code class="identifier">Const</code>(<code class="identifier">SynConst</code>.<code class="identifier">Unit</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2)
        <code class="keyword">let</code> <code class="identifier">simplePats</code>, <code class="identifier">_</code> = <code class="identifier">SimplePatsOfPat</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="identifier">pat</code>
        <code class="identifier">simplePats</code> }

  | <code class="identifier">LPAREN</code> <code class="identifier">simplePatternCommaList</code> <code class="identifier">recover</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>())
        <code class="keyword">let</code> <code class="identifier">parenPat</code> = <code class="identifier">SynPat</code>.<code class="identifier">Paren</code>(<code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, [], <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2), <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2) <code class="comment">// todo: report parsed pats anyway?</code>
        <code class="keyword">let</code> <code class="identifier">simplePats</code>, <code class="identifier">_</code> = <code class="identifier">SimplePatsOfPat</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="identifier">parenPat</code>
        <code class="identifier">simplePats</code> }

  | <code class="identifier">LPAREN</code> <code class="keyword">error</code> <code class="identifier">rparen</code>
      { <code class="keyword">let</code> <code class="identifier">parenPat</code> = <code class="identifier">SynPat</code>.<code class="identifier">Paren</code>(<code class="identifier">SynPat</code>.<code class="identifier">Wild</code>(<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2), <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) <code class="comment">// silent recovery</code>
        <code class="keyword">let</code> <code class="identifier">simplePats</code>, <code class="identifier">_</code> = <code class="identifier">SimplePatsOfPat</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="identifier">parenPat</code>
        <code class="identifier">simplePats</code> }

  | <code class="identifier">LPAREN</code> <code class="identifier">recover</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>())
        <code class="keyword">let</code> <code class="identifier">pat</code> = <code class="identifier">SynPat</code>.<code class="identifier">Wild</code>(<code class="identifier">lhs</code> <code class="identifier">parseState</code>)
        <code class="keyword">let</code> <code class="identifier">simplePats</code>, <code class="identifier">_</code> = <code class="identifier">SimplePatsOfPat</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="identifier">pat</code>
        <code class="identifier">simplePats</code> }


<code class="identifier">headBindingPattern</code>:
  | <code class="identifier">headBindingPattern</code> <code class="identifier">AS</code> <code class="identifier">ident</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">Named</code> ($1, $3, <code class="keyword">false</code>, <code class="identifier">None</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

  | <code class="identifier">headBindingPattern</code> <code class="identifier">BAR</code> <code class="identifier">headBindingPattern</code>  
      { <code class="identifier">SynPat</code>.<code class="identifier">Or</code>($1, $3, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

  | <code class="identifier">headBindingPattern</code> <code class="identifier">COLON_COLON</code>  <code class="identifier">headBindingPattern</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">LongIdentWithDots</code>(<code class="identifier">mkSynCaseName</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) <code class="identifier">opNameCons</code>, []), <code class="identifier">None</code>, <code class="identifier">None</code>, <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> [<code class="identifier">SynPat</code>.<code class="identifier">Tuple</code> (<code class="keyword">false</code>, [$1;$3], <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3)], <code class="identifier">None</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">tuplePatternElements</code>  <code class="keyword">%prec</code> <code class="identifier">pat_tuple</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> $1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">conjPatternElements</code>   <code class="keyword">%prec</code> <code class="identifier">pat_conj</code>
      { <code class="identifier">SynPat</code>.<code class="identifier">Ands</code>(<code class="identifier">List</code>.<code class="identifier">rev</code> $1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">constrPattern</code> 
      { $1 }

<code class="identifier">tuplePatternElements</code>: 
  | <code class="identifier">tuplePatternElements</code> <code class="identifier">COMMA</code> <code class="identifier">headBindingPattern</code> 
      { $3 :: $1 }

  | <code class="identifier">headBindingPattern</code> <code class="identifier">COMMA</code> <code class="identifier">headBindingPattern</code> 
      { $3 :: $1 :: [] }

<code class="identifier">conjPatternElements</code>: 
  | <code class="identifier">conjPatternElements</code> <code class="identifier">AMP</code> <code class="identifier">headBindingPattern</code> 
     { $3 :: $1 }

  | <code class="identifier">headBindingPattern</code> <code class="identifier">AMP</code> <code class="identifier">headBindingPattern</code> 
     { $3 :: $1 :: [] }

<code class="identifier">namePatPairs</code>:
   | <code class="identifier">namePatPair</code> <code class="identifier">opt_seps</code>
     { [$1], <code class="identifier">lhs</code> <code class="identifier">parseState</code> }

   | <code class="identifier">namePatPair</code> <code class="identifier">seps</code> <code class="identifier">namePatPairs</code>
     { <code class="keyword">let</code> (<code class="identifier">rs</code>, <code class="identifier">_</code>) = $3 <code class="keyword">in</code> ($1 :: <code class="identifier">rs</code>), <code class="identifier">lhs</code> <code class="identifier">parseState</code> }

<code class="identifier">namePatPair</code>:
   | <code class="identifier">ident</code> <code class="identifier">EQUALS</code> <code class="identifier">parenPattern</code>
     { ($1, $3) }

<code class="identifier">constrPattern</code>:
  | <code class="identifier">atomicPatternLongIdent</code> <code class="identifier">explicitValTyparDecls</code>                                                          
      { <code class="keyword">let</code> <code class="identifier">vis</code>, <code class="identifier">lid</code> = $1 <code class="keyword">in</code> <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">lid</code>, <code class="identifier">None</code>, <code class="identifier">Some</code> $2, <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> [], <code class="identifier">vis</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">atomicPatternLongIdent</code> <code class="identifier">opt_explicitValTyparDecls2</code>                     <code class="identifier">atomicPatsOrNamePatPairs</code>    <code class="keyword">%prec</code> <code class="identifier">pat_app</code> 
      { <code class="keyword">let</code> <code class="identifier">vis</code>, <code class="identifier">lid</code> = $1 <code class="keyword">in</code> <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">lid</code>, <code class="identifier">None</code>, $2, $3, <code class="identifier">vis</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">atomicPatternLongIdent</code> <code class="identifier">opt_explicitValTyparDecls2</code> <code class="identifier">HIGH_PRECEDENCE_PAREN_APP</code> <code class="identifier">atomicPatsOrNamePatPairs</code>                  
      { <code class="keyword">let</code> <code class="identifier">vis</code>, <code class="identifier">lid</code> = $1 <code class="keyword">in</code> <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">lid</code>, <code class="identifier">None</code>, $2, $4, <code class="identifier">vis</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">atomicPatternLongIdent</code> <code class="identifier">opt_explicitValTyparDecls2</code> <code class="identifier">HIGH_PRECEDENCE_BRACK_APP</code> <code class="identifier">atomicPatsOrNamePatPairs</code>                  
      { <code class="keyword">let</code> <code class="identifier">vis</code>, <code class="identifier">lid</code> = $1 <code class="keyword">in</code> <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">lid</code>, <code class="identifier">None</code>, $2, $4, <code class="identifier">vis</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">COLON_QMARK</code> <code class="identifier">atomTypeOrAnonRecdType</code>  <code class="keyword">%prec</code> <code class="identifier">pat_isinst</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">IsInst</code>($2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">atomicPattern</code> 
      { $1 }

<code class="identifier">atomicPatsOrNamePatPairs</code>:
  | <code class="identifier">LPAREN</code> <code class="identifier">namePatPairs</code> <code class="identifier">rparen</code>
      { <code class="identifier">SynArgPats</code>.<code class="identifier">NamePatPairs</code> $2 }

  | <code class="identifier">atomicPatterns</code>
      { <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> $1 }

<code class="identifier">atomicPatterns</code>: 
  | <code class="identifier">atomicPattern</code> <code class="identifier">atomicPatterns</code> <code class="keyword">%prec</code> <code class="identifier">pat_args</code> 
      { $1 :: $2 } 

  | <code class="identifier">atomicPattern</code> <code class="identifier">HIGH_PRECEDENCE_BRACK_APP</code> <code class="identifier">atomicPatterns</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSuccessivePatternsShouldBeSpacedOrTupled</code>())
        $1 :: $3 } 

  | <code class="identifier">atomicPattern</code> <code class="identifier">HIGH_PRECEDENCE_PAREN_APP</code> <code class="identifier">atomicPatterns</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSuccessivePatternsShouldBeSpacedOrTupled</code>())
        $1 :: $3 } 

  | <code class="identifier">atomicPattern</code>
      { [$1] }


<code class="identifier">atomicPattern</code>:
  | <code class="identifier">quoteExpr</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">QuoteExpr</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

  | <code class="identifier">CHAR</code> <code class="identifier">DOT_DOT</code> <code class="identifier">CHAR</code>
      { <code class="identifier">SynPat</code>.<code class="identifier">DeprecatedCharRange</code> ($1, $3, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

  | <code class="identifier">LBRACE</code> <code class="identifier">recordPatternElementsAux</code> <code class="identifier">rbrace</code>
      { <code class="keyword">let</code> <code class="identifier">rs</code>, <code class="identifier">m</code> = $2 <code class="keyword">in</code> <code class="identifier">SynPat</code>.<code class="identifier">Record</code> (<code class="identifier">rs</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

  | <code class="identifier">LBRACK</code> <code class="identifier">listPatternElements</code> <code class="identifier">RBRACK</code>
      { <code class="identifier">SynPat</code>.<code class="identifier">ArrayOrList</code>(<code class="keyword">false</code>, $2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">LBRACK_BAR</code> <code class="identifier">listPatternElements</code>  <code class="identifier">BAR_RBRACK</code>
      { <code class="identifier">SynPat</code>.<code class="identifier">ArrayOrList</code>(<code class="keyword">true</code>, $2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">UNDERSCORE</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">Wild</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">QMARK</code> <code class="identifier">ident</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">OptionalVal</code>($2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

  | <code class="identifier">atomicPatternLongIdent</code> <code class="keyword">%prec</code> <code class="identifier">prec_atompat_pathop</code> 
      { <code class="keyword">let</code> <code class="identifier">vis</code>, <code class="identifier">lidwd</code> = $1 
        <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">isNilOrSingleton</code> <code class="identifier">lidwd</code>.<code class="identifier">Lid</code>) || <code class="identifier">String</code>.<code class="identifier">isLeadingIdentifierCharacterUpperCase</code> (<code class="identifier">List</code>.<code class="identifier">head</code> <code class="identifier">lidwd</code>.<code class="identifier">Lid</code>).<code class="identifier">idText</code>
        <code class="keyword">then</code> <code class="identifier">mkSynPatMaybeVar</code> <code class="identifier">lidwd</code> <code class="identifier">vis</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>)
        <code class="keyword">else</code> <code class="identifier">mkSynPatVar</code> <code class="identifier">vis</code> (<code class="identifier">List</code>.<code class="identifier">head</code> <code class="identifier">lidwd</code>.<code class="identifier">Lid</code>) }

  | <code class="identifier">constant</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">Const</code> (<code class="identifier">fst</code> $1, <code class="identifier">snd</code> $1) }

  | <code class="identifier">FALSE</code>  
      { <code class="identifier">SynPat</code>.<code class="identifier">Const</code>(<code class="identifier">SynConst</code>.<code class="identifier">Bool</code> <code class="keyword">false</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

  | <code class="identifier">TRUE</code>  
      { <code class="identifier">SynPat</code>.<code class="identifier">Const</code>(<code class="identifier">SynConst</code>.<code class="identifier">Bool</code> <code class="keyword">true</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

  | <code class="identifier">NULL</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">Null</code>(<code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">parenPatternBody</code> <code class="identifier">rparen</code> 
      { <code class="keyword">let</code> <code class="identifier">m</code> = (<code class="identifier">lhs</code> <code class="identifier">parseState</code>)
        <code class="identifier">SynPat</code>.<code class="identifier">Paren</code>($2 <code class="identifier">m</code>, <code class="identifier">m</code>) } 

  | <code class="identifier">LPAREN</code> <code class="identifier">parenPatternBody</code> <code class="identifier">recover</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>()) 
        <code class="identifier">patFromParseError</code> ($2 (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2)) }

  | <code class="identifier">LPAREN</code> <code class="keyword">error</code> <code class="identifier">rparen</code> 
      { <code class="comment">(* silent recovery *)</code> <code class="identifier">SynPat</code>.<code class="identifier">Wild</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">recover</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>()) 
        <code class="identifier">SynPat</code>.<code class="identifier">Wild</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>)}  

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="identifier">tupleParenPatternElements</code> <code class="identifier">rparen</code>
      { <code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="keyword">true</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="identifier">tupleParenPatternElements</code> <code class="identifier">recover</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>()); 
        <code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="keyword">true</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="keyword">error</code> <code class="identifier">rparen</code> 
      { <code class="comment">(* silent recovery *)</code> <code class="identifier">SynPat</code>.<code class="identifier">Wild</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="identifier">recover</code> 
      {  <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>()); 
         <code class="identifier">SynPat</code>.<code class="identifier">Wild</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>)}  

<code class="identifier">parenPatternBody</code>: 
  | <code class="identifier">parenPattern</code> 
      { (<code class="keyword">fun</code> <code class="identifier">m</code> -&gt; $1) } 

  | <code class="comment">/* EMPTY */</code>
      { (<code class="keyword">fun</code> <code class="identifier">m</code> -&gt; <code class="identifier">SynPat</code>.<code class="identifier">Const</code>(<code class="identifier">SynConst</code>.<code class="identifier">Unit</code>, <code class="identifier">m</code>)) } 

<code class="comment">/* This duplicates out 'patterns' in order to give type annotations */</code>
<code class="comment">/* the desired precedence w.r.t. patterns, tuple patterns in particular. */</code>
<code class="comment">/* Duplication requried to minimize the disturbance to the grammar, */</code>
<code class="comment">/* in particular the expected property that "pat" parses the same as */</code>
<code class="comment">/* "(pat)"!  Here are some examples: */</code>
<code class="comment">/*    a, b                  parses as (a, b) */</code>
<code class="comment">/*    (a, b)           also parses as (a, b) */</code>
<code class="comment">/*    (a, b : t)            parses as (a, (b:t)) */</code>
<code class="comment">/*    a, b as t             parses as ((a, b) as t) */</code>
<code class="comment">/*    (a, b as t)      also parses as ((a, b) as t) */</code>
<code class="comment">/*    a, b | c, d            parses as ((a, b) | (c, d)) */</code>
<code class="comment">/*    (a, b | c, d)     also parses as ((a, b) | (c, d)) */</code>
<code class="comment">/*    (a : t, b)            parses as ((a:t), b) */</code>
<code class="comment">/*    (a : t1, b : t2)      parses as ((a:t), (b:t2)) */</code>
<code class="comment">/*    (a, b as nm : t)      parses as (((a, b) as nm) : t) */</code>
<code class="comment">/*    (a, b :: c : t)       parses as (((a, b) :: c) : t) */</code>
<code class="comment">/* */</code>
<code class="comment">/* Probably the most unexpected thing here is that 'as nm' binds the */</code>
<code class="comment">/* whole pattern to the left, whereas ': t' binds only the pattern */</code>
<code class="comment">/* immediately preceding in the tuple. */</code>
<code class="comment">/* */</code>
<code class="comment">/* Also, it is unexpected that '(a, b : t)' in a pattern binds differently to */</code>
<code class="comment">/* '(a, b : t)' in an expression. It's not that easy to solve that without */</code>
<code class="comment">/* duplicating the entire expression grammar, or making a fairly severe breaking change */</code>
<code class="comment">/* to the language. */</code>
<code class="identifier">parenPattern</code>:
  | <code class="identifier">parenPattern</code> <code class="identifier">AS</code> <code class="identifier">ident</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">Named</code> ($1, $3, <code class="keyword">false</code>, <code class="identifier">None</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

  | <code class="identifier">parenPattern</code> <code class="identifier">BAR</code> <code class="identifier">parenPattern</code>  
      { <code class="identifier">SynPat</code>.<code class="identifier">Or</code>($1, $3, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

  | <code class="identifier">tupleParenPatternElements</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> $1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">conjParenPatternElements</code>
      { <code class="identifier">SynPat</code>.<code class="identifier">Ands</code>(<code class="identifier">List</code>.<code class="identifier">rev</code> $1, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

  | <code class="identifier">parenPattern</code> <code class="identifier">COLON</code>  <code class="identifier">typeWithTypeConstraints</code> <code class="keyword">%prec</code> <code class="identifier">paren_pat_colon</code>
      { <code class="keyword">let</code> <code class="identifier">lhsm</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
        <code class="identifier">SynPat</code>.<code class="identifier">Typed</code>($1, $3, <code class="identifier">lhsm</code>) } 

  | <code class="identifier">attributes</code> <code class="identifier">parenPattern</code>  <code class="keyword">%prec</code> <code class="identifier">paren_pat_attribs</code>
      { <code class="keyword">let</code> <code class="identifier">lhsm</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
        <code class="identifier">SynPat</code>.<code class="identifier">Attrib</code>($2, $1, <code class="identifier">lhsm</code>) } 

  | <code class="identifier">parenPattern</code> <code class="identifier">COLON_COLON</code>  <code class="identifier">parenPattern</code> 
      { <code class="identifier">SynPat</code>.<code class="identifier">LongIdent</code> (<code class="identifier">LongIdentWithDots</code>(<code class="identifier">mkSynCaseName</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) <code class="identifier">opNameCons</code>, []), <code class="identifier">None</code>, <code class="identifier">None</code>, <code class="identifier">SynArgPats</code>.<code class="identifier">Pats</code> [ <code class="identifier">SynPat</code>.<code class="identifier">Tuple</code> (<code class="keyword">false</code>, [$1;$3], <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) ], <code class="identifier">None</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">constrPattern</code> { $1 }

<code class="identifier">tupleParenPatternElements</code>:
  | <code class="identifier">tupleParenPatternElements</code> <code class="identifier">COMMA</code> <code class="identifier">parenPattern</code>  
      { $3 :: $1 }

  | <code class="identifier">parenPattern</code> <code class="identifier">COMMA</code> <code class="identifier">parenPattern</code>  
      { $3 :: $1 :: [] }
  
<code class="identifier">conjParenPatternElements</code>: 
  | <code class="identifier">conjParenPatternElements</code> <code class="identifier">AMP</code> <code class="identifier">parenPattern</code> 
      { $3 :: $1 }

  | <code class="identifier">parenPattern</code> <code class="identifier">AMP</code> <code class="identifier">parenPattern</code> 
      { $3 :: $1 :: [] }

<code class="identifier">recordPatternElementsAux</code>: <code class="comment">/* Fix 1190 */</code>
  | <code class="identifier">recordPatternElement</code> <code class="identifier">opt_seps</code>                      
      { [$1], <code class="identifier">lhs</code> <code class="identifier">parseState</code> }

  | <code class="identifier">recordPatternElement</code> <code class="identifier">seps</code> <code class="identifier">recordPatternElementsAux</code> 
      { <code class="keyword">let</code> <code class="identifier">r</code> = $1 <code class="keyword">in</code> <code class="keyword">let</code> (<code class="identifier">rs</code>, <code class="identifier">dropMark</code>) = $3 <code class="keyword">in</code> (<code class="identifier">r</code> :: <code class="identifier">rs</code>), <code class="identifier">lhs</code> <code class="identifier">parseState</code> }

<code class="identifier">recordPatternElement</code>:  
  | <code class="identifier">path</code> <code class="identifier">EQUALS</code> <code class="identifier">parenPattern</code> { (<code class="identifier">List</code>.<code class="identifier">frontAndBack</code> $1.<code class="identifier">Lid</code>, $3) }

<code class="identifier">listPatternElements</code>:
  | <code class="comment">/* EMPTY */</code>                                      
      { [] }

  | <code class="identifier">parenPattern</code> <code class="identifier">opt_seps</code>                 
      { [$1] }

  | <code class="identifier">parenPattern</code> <code class="identifier">seps</code> <code class="identifier">listPatternElements</code> 
      { $1 :: $3 }

<code class="comment">/* The lexfilter likes to insert OBLOCKBEGIN/OBLOCKEND pairs */</code>
<code class="identifier">typedSeqExprBlock</code>: 
  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">oblockend</code> 
      { $2 }

  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileExpression</code>())
        <code class="identifier">exprFromParseError</code> $2 }

  | <code class="identifier">typedSeqExpr</code> 
      { $1 }

<code class="comment">/* The lexfilter likes to insert OBLOCKBEGIN/OBLOCKEND pairs */</code>
<code class="identifier">declExprBlock</code>: 
  | <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">oblockend</code> 
      { $2 }

  | <code class="identifier">declExpr</code> 
      { $1 }

<code class="comment">/* For some constructs the lex filter can't be sure to insert a matching OBLOCKEND, e.g. "function a -&gt; b | c -&gt; d" all in one line */</code>
<code class="comment">/* for these it only inserts a trailing ORIGHT_BLOCK_END */</code>
<code class="identifier">typedSeqExprBlockR</code>: 
  | <code class="identifier">typedSeqExpr</code> <code class="identifier">ORIGHT_BLOCK_END</code>
    { $1 }

  | <code class="identifier">typedSeqExpr</code>
    { $1 }

<code class="identifier">typedSeqExpr</code>: 
  | <code class="identifier">seqExpr</code> <code class="identifier">COLON</code> <code class="identifier">typeWithTypeConstraints</code>
    { <code class="identifier">SynExpr</code>.<code class="identifier">Typed</code> ($1, $3, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code>) }

  | <code class="identifier">seqExpr</code>
    { $1 }

<code class="identifier">typedSeqExprEOF</code>:
  | <code class="identifier">typedSeqExpr</code> <code class="identifier">EOF</code>
    { <code class="identifier">checkEndOfFileError</code> $2; $1 }

<code class="identifier">seqExpr</code>:
  | <code class="identifier">declExpr</code> <code class="identifier">seps</code> <code class="identifier">seqExpr</code>
      { <code class="identifier">SynExpr</code>.<code class="identifier">Sequential</code> (<code class="identifier">DebugPointAtSequential</code>.<code class="identifier">Both</code>, <code class="keyword">true</code>, $1, $3, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code>) } 

  | <code class="identifier">declExpr</code> <code class="identifier">seps</code>                         
      { $1 }  

  | <code class="identifier">declExpr</code>             <code class="keyword">%prec</code> <code class="identifier">SEMICOLON</code> 
      { $1 } 

  | <code class="identifier">declExpr</code> <code class="identifier">THEN</code> <code class="identifier">seqExpr</code> <code class="keyword">%prec</code> <code class="identifier">prec_then_before</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">Sequential</code> (<code class="identifier">DebugPointAtSequential</code>.<code class="identifier">Both</code>, <code class="keyword">false</code>, $1, $3, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code> ) }

  | <code class="identifier">declExpr</code> <code class="identifier">OTHEN</code> <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">oblockend</code> <code class="keyword">%prec</code> <code class="identifier">prec_then_before</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">Sequential</code> (<code class="identifier">DebugPointAtSequential</code>.<code class="identifier">Both</code>, <code class="keyword">false</code>, $1, $4, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $4.<code class="identifier">Range</code>) }

  | <code class="identifier">hardwhiteLetBindings</code> <code class="keyword">%prec</code> <code class="identifier">prec_args_error</code>
     { <code class="keyword">let</code> <code class="identifier">hwlb</code>, <code class="identifier">m</code> = $1
       <code class="keyword">let</code> <code class="identifier">mLetKwd</code>, <code class="identifier">isUse</code> = <code class="keyword">match</code> <code class="identifier">hwlb</code> <code class="keyword">with</code> (<code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">m</code>, <code class="identifier">_</code>, <code class="identifier">isUse</code>, <code class="identifier">_</code>, <code class="identifier">_</code>))  -&gt; <code class="identifier">m</code>, <code class="identifier">isUse</code>
       <code class="keyword">let</code> <code class="identifier">usedKeyword</code> = <code class="keyword">if</code> <code class="identifier">isUse</code> <code class="keyword">then</code> <code class="string">"use"</code> <code class="keyword">else</code> <code class="string">"let"</code>
       <code class="identifier">reportParseErrorAt</code> <code class="identifier">mLetKwd</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsExpectedExpressionAfterLet</code>(<code class="identifier">usedKeyword</code>, <code class="identifier">usedKeyword</code>))
       <code class="keyword">let</code> <code class="identifier">fauxRange</code> = <code class="identifier">m</code>.<code class="identifier">EndRange</code> <code class="comment">// zero width range at end of m</code>
       <code class="identifier">mkLocalBindings</code> (<code class="identifier">m</code>, <code class="identifier">hwlb</code>, <code class="identifier">arbExpr</code>(<code class="string">"seqExpr"</code>, <code class="identifier">fauxRange</code>)) }

<code class="comment">/* Use this as the last terminal when performing error recovery */</code>
<code class="comment">/* The contract for using this is that (a) if EOF occurs then the */</code>
<code class="comment">/* the using production must report an error and (b) the using production */</code>
<code class="comment">/* can report an error anyway if it is helpful, e.g. "unclosed '('" (giving two errors) */</code>
<code class="identifier">recover</code>: 
   | <code class="keyword">error</code>
      { <code class="identifier">debugPrint</code>(<code class="string">"recovering via error"</code>); <code class="keyword">true</code> }  

   | <code class="identifier">EOF</code>
      { <code class="identifier">debugPrint</code>(<code class="string">"recovering via EOF"</code>); <code class="keyword">false</code> }

<code class="identifier">moreBinders</code>:
  | <code class="identifier">AND_BANG</code> <code class="identifier">headBindingPattern</code> <code class="identifier">EQUALS</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">IN</code> <code class="identifier">moreBinders</code> <code class="keyword">%prec</code> <code class="identifier">expr_let</code>
     { <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code>(<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5) <code class="comment">(* TODO Pretty sure this is wrong *)</code>
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 <code class="comment">(* TODO Pretty sure this is wrong *)</code>
       (<code class="identifier">spBind</code>, $1, <code class="keyword">true</code>, $2, $4, <code class="identifier">m</code>) :: $6 }

  | <code class="identifier">OAND_BANG</code> <code class="identifier">headBindingPattern</code> <code class="identifier">EQUALS</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">hardwhiteDefnBindingsTerminator</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="identifier">moreBinders</code> <code class="keyword">%prec</code> <code class="identifier">expr_let</code>
     { $5 <code class="string">"and!"</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)  <code class="comment">// report unterminated error</code>
       <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code>(<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5) <code class="comment">(* TODO Pretty sure this is wrong *)</code>
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 <code class="comment">(* TODO Pretty sure this is wrong *)</code>
       (<code class="identifier">spBind</code>, $1, <code class="keyword">true</code>, $2, $4, <code class="identifier">m</code>) :: $7 }

  | <code class="keyword">%prec</code> <code class="identifier">prec_no_more_attr_bindings</code>
      { [] }

<code class="identifier">declExpr</code>:
  | <code class="identifier">defnBindings</code> <code class="identifier">IN</code> <code class="identifier">typedSeqExpr</code>  <code class="keyword">%prec</code> <code class="identifier">expr_let</code> 
     { <code class="identifier">mkLocalBindings</code> (<code class="identifier">unionRanges</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2) $3.<code class="identifier">Range</code>, $1, $3) }

  | <code class="identifier">defnBindings</code> <code class="identifier">IN</code> <code class="keyword">error</code>        <code class="keyword">%prec</code> <code class="identifier">expr_let</code>
     { <code class="identifier">mkLocalBindings</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2, $1, <code class="identifier">arbExpr</code>(<code class="string">"declExpr1"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3))) }
<code class="comment">/*
    FSComp.SR.parsNoMatchingInForLet() -- leave this in for now - it's an unused error string
*/</code>

  | <code class="identifier">hardwhiteLetBindings</code> <code class="identifier">typedSeqExprBlock</code>  <code class="keyword">%prec</code> <code class="identifier">expr_let</code> 
     { <code class="keyword">let</code> <code class="identifier">hwlb</code>, <code class="identifier">m</code> = $1
       <code class="identifier">mkLocalBindings</code> (<code class="identifier">unionRanges</code> <code class="identifier">m</code> $2.<code class="identifier">Range</code>, <code class="identifier">hwlb</code>, $2) }

  | <code class="identifier">hardwhiteLetBindings</code> <code class="keyword">error</code>        <code class="keyword">%prec</code> <code class="identifier">expr_let</code>
     { <code class="keyword">let</code> <code class="identifier">hwlb</code>, <code class="identifier">m</code> = $1
       <code class="identifier">reportParseErrorAt</code> (<code class="keyword">match</code> <code class="identifier">hwlb</code> <code class="keyword">with</code> (<code class="identifier">BindingSetPreAttrs</code>(<code class="identifier">m</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>))  -&gt; <code class="identifier">m</code>) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsErrorInReturnForLetIncorrectIndentation</code>())
       <code class="identifier">mkLocalBindings</code> (<code class="identifier">m</code>, <code class="identifier">hwlb</code>, <code class="identifier">arbExpr</code>(<code class="string">"declExpr2"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2))) }

  | <code class="identifier">hardwhiteLetBindings</code> <code class="identifier">OBLOCKSEP</code> <code class="identifier">typedSeqExprBlock</code>  <code class="keyword">%prec</code> <code class="identifier">expr_let</code> 
     { <code class="keyword">let</code> <code class="identifier">hwlb</code>, <code class="identifier">m</code> = $1
       <code class="identifier">mkLocalBindings</code> (<code class="identifier">unionRanges</code> <code class="identifier">m</code> $3.<code class="identifier">Range</code>, <code class="identifier">hwlb</code>, $3) }

  | <code class="identifier">hardwhiteLetBindings</code> <code class="identifier">OBLOCKSEP</code> <code class="keyword">error</code>        <code class="keyword">%prec</code> <code class="identifier">expr_let</code>
     { <code class="keyword">let</code> <code class="identifier">hwlb</code>, <code class="identifier">m</code> = $1
       <code class="comment">//reportParseErrorAt (match hwlb with (BindingSetPreAttrs(m, _, _, _, _))  -&gt; m) (FSComp.SR.parsErrorInReturnForLetIncorrectIndentation())</code>
       <code class="identifier">mkLocalBindings</code> (<code class="identifier">unionRanges</code> <code class="identifier">m</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3), <code class="identifier">hwlb</code>, <code class="identifier">arbExpr</code>(<code class="string">"declExpr3"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3))) }

  | <code class="identifier">hardwhiteDoBinding</code> <code class="keyword">%prec</code> <code class="identifier">expr_let</code>
     { <code class="keyword">let</code> <code class="identifier">e</code> = <code class="identifier">snd</code> $1
       <code class="identifier">SynExpr</code>.<code class="identifier">Do</code> (<code class="identifier">e</code>, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1).<code class="identifier">StartRange</code> <code class="identifier">e</code>.<code class="identifier">Range</code>) }

  | <code class="identifier">anonMatchingExpr</code> <code class="keyword">%prec</code> <code class="identifier">expr_function</code>
      { $1 }

  | <code class="identifier">anonLambdaExpr</code>  <code class="keyword">%prec</code> <code class="identifier">expr_fun</code> 
      { $1 }

  | <code class="identifier">MATCH</code> <code class="identifier">typedSeqExpr</code>     <code class="identifier">withClauses</code>              <code class="keyword">%prec</code> <code class="identifier">expr_match</code> 
      { <code class="keyword">let</code> <code class="identifier">mMatch</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
        <code class="keyword">let</code> <code class="identifier">mWith</code>, (<code class="identifier">clauses</code>, <code class="identifier">mLast</code>) = $3 
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code>(<code class="identifier">unionRanges</code> <code class="identifier">mMatch</code> <code class="identifier">mWith</code>) 
        <code class="identifier">SynExpr</code>.<code class="identifier">Match</code> (<code class="identifier">spBind</code>, $2, <code class="identifier">clauses</code>, <code class="identifier">unionRanges</code> <code class="identifier">mMatch</code> <code class="identifier">mLast</code>) }

  | <code class="identifier">MATCH</code> <code class="identifier">typedSeqExpr</code>     <code class="identifier">recover</code>               <code class="keyword">%prec</code> <code class="identifier">expr_match</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileMatch</code>())
        <code class="comment">// Produce approximate expression during error recovery </code>
        <code class="identifier">exprFromParseError</code> $2 }

  | <code class="identifier">MATCH_BANG</code> <code class="identifier">typedSeqExpr</code>     <code class="identifier">withClauses</code>              <code class="keyword">%prec</code> <code class="identifier">expr_match</code> 
      { <code class="keyword">let</code> <code class="identifier">mMatch</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
        <code class="keyword">let</code> <code class="identifier">mWith</code>, (<code class="identifier">clauses</code>, <code class="identifier">mLast</code>) = $3 
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code>(<code class="identifier">unionRanges</code> <code class="identifier">mMatch</code> <code class="identifier">mWith</code>) 
        <code class="identifier">SynExpr</code>.<code class="identifier">MatchBang</code> (<code class="identifier">spBind</code>, $2, <code class="identifier">clauses</code>, <code class="identifier">unionRanges</code> <code class="identifier">mMatch</code> <code class="identifier">mLast</code>) }

  | <code class="identifier">MATCH_BANG</code> <code class="identifier">typedSeqExpr</code>     <code class="identifier">recover</code>               <code class="keyword">%prec</code> <code class="identifier">expr_match</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileMatch</code>())
        <code class="comment">// Produce approximate expression during error recovery </code>
        <code class="identifier">exprFromParseError</code> $2 }
      
  | <code class="identifier">TRY</code> <code class="identifier">typedSeqExprBlockR</code> <code class="identifier">withClauses</code>              <code class="keyword">%prec</code> <code class="identifier">expr_try</code> 
      { <code class="keyword">let</code> <code class="identifier">mTry</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
        <code class="keyword">let</code> <code class="identifier">spTry</code> = <code class="identifier">DebugPointAtTry</code>.<code class="identifier">Yes</code> <code class="identifier">mTry</code>
        <code class="keyword">let</code> <code class="identifier">mWith</code>, (<code class="identifier">clauses</code>, <code class="identifier">mLast</code>) = $3 
        <code class="keyword">let</code> <code class="identifier">spWith</code> = <code class="identifier">DebugPointAtWith</code>.<code class="identifier">Yes</code> <code class="identifier">mWith</code>
        <code class="keyword">let</code> <code class="identifier">mTryToWith</code> = <code class="identifier">unionRanges</code> <code class="identifier">mTry</code> <code class="identifier">mWith</code> 
        <code class="keyword">let</code> <code class="identifier">mWithToLast</code> = <code class="identifier">unionRanges</code> <code class="identifier">mWith</code> <code class="identifier">mLast</code> 
        <code class="keyword">let</code> <code class="identifier">mTryToLast</code> = <code class="identifier">unionRanges</code> <code class="identifier">mTry</code> <code class="identifier">mLast</code>
        <code class="identifier">SynExpr</code>.<code class="identifier">TryWith</code> ($2, <code class="identifier">mTryToWith</code>, <code class="identifier">clauses</code>, <code class="identifier">mWithToLast</code>, <code class="identifier">mTryToLast</code>, <code class="identifier">spTry</code>, <code class="identifier">spWith</code>) }

  | <code class="identifier">TRY</code> <code class="identifier">typedSeqExprBlockR</code> <code class="identifier">recover</code>              <code class="keyword">%prec</code> <code class="identifier">expr_try</code> 
      { <code class="comment">// Produce approximate expression during error recovery </code>
        <code class="comment">// Include any expressions to make sure they gets type checked in case that generates useful results for intellisense </code>
        <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileTry</code>())
        <code class="identifier">exprFromParseError</code> $2 }

  | <code class="identifier">TRY</code> <code class="identifier">typedSeqExprBlockR</code> <code class="identifier">FINALLY</code> <code class="identifier">typedSeqExprBlock</code> <code class="keyword">%prec</code> <code class="identifier">expr_try</code> 
      { <code class="keyword">let</code> <code class="identifier">mTry</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
        <code class="keyword">let</code> <code class="identifier">spTry</code> = <code class="identifier">DebugPointAtTry</code>.<code class="identifier">Yes</code> <code class="identifier">mTry</code>
        <code class="keyword">let</code> <code class="identifier">spFinally</code> = <code class="identifier">DebugPointAtFinally</code>.<code class="identifier">Yes</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) 
        <code class="keyword">let</code> <code class="identifier">mTryToLast</code> = <code class="identifier">unionRanges</code> <code class="identifier">mTry</code> $4.<code class="identifier">Range</code> 
        <code class="identifier">SynExpr</code>.<code class="identifier">TryFinally</code> ($2, $4, <code class="identifier">mTryToLast</code>, <code class="identifier">spTry</code>, <code class="identifier">spFinally</code>) }

  | <code class="identifier">IF</code> <code class="identifier">declExpr</code> <code class="identifier">ifExprCases</code> <code class="keyword">%prec</code> <code class="identifier">expr_if</code> 
      { <code class="keyword">let</code> <code class="identifier">mIf</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
        $3 $2 <code class="identifier">mIf</code> }

  | <code class="identifier">IF</code> <code class="identifier">declExpr</code> <code class="identifier">recover</code> <code class="keyword">%prec</code> <code class="identifier">expr_if</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIncompleteIf</code>()) 
        <code class="comment">// Produce an approximate expression during error recovery. </code>
        <code class="comment">// Include expressions to make sure they get type checked in case that generates useful results for intellisense. </code>
        <code class="comment">// Generate a throwAway for the expression so it isn't forced to have a type 'bool' </code>
        <code class="comment">// from the context it is used in. </code>
        <code class="identifier">exprFromParseError</code> $2 }

  | <code class="identifier">IF</code> <code class="identifier">recover</code> <code class="keyword">%prec</code> <code class="identifier">expr_if</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIncompleteIf</code>())
        <code class="comment">// Produce an approximate expression during error recovery. There can still be value in doing this even</code>
        <code class="comment">// for this pathological case.</code>
        <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
        <code class="keyword">let</code> <code class="identifier">mEnd</code> = <code class="identifier">m</code>.<code class="identifier">EndRange</code>
        <code class="keyword">let</code> <code class="identifier">spIfToThen</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code> <code class="identifier">mEnd</code>
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">IfThenElse</code> (<code class="identifier">arbExpr</code>(<code class="string">"ifGuard1"</code>, <code class="identifier">mEnd</code>), <code class="identifier">arbExpr</code>(<code class="string">"thenBody1"</code>, <code class="identifier">mEnd</code>), <code class="identifier">None</code>, <code class="identifier">spIfToThen</code>, <code class="keyword">true</code>, <code class="identifier">m</code>, <code class="identifier">m</code>)) }

  | <code class="identifier">LAZY</code> <code class="identifier">declExpr</code> <code class="keyword">%prec</code> <code class="identifier">expr_lazy</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">Lazy</code> ($2, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) }

  | <code class="identifier">ASSERT</code> <code class="identifier">declExpr</code> <code class="keyword">%prec</code> <code class="identifier">expr_assert</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">Assert</code> ($2, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) }

  | <code class="identifier">ASSERT</code> <code class="keyword">%prec</code> <code class="identifier">expr_assert</code> 
      { <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAssertIsNotFirstClassValue</code>()) }

  | <code class="identifier">OLAZY</code> <code class="identifier">declExprBlock</code> <code class="keyword">%prec</code> <code class="identifier">expr_lazy</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">Lazy</code> ($2, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) }

  | <code class="identifier">OASSERT</code> <code class="identifier">declExprBlock</code> <code class="keyword">%prec</code> <code class="identifier">expr_assert</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">Assert</code> ($2, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) }

  | <code class="identifier">OASSERT</code> <code class="keyword">%prec</code> <code class="identifier">expr_assert</code> 
      { <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsAssertIsNotFirstClassValue</code>()) }

  | <code class="identifier">WHILE</code> <code class="identifier">declExpr</code> <code class="identifier">doToken</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">doneDeclEnd</code> 
      { <code class="keyword">let</code> <code class="identifier">mWhileHeader</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>
        <code class="keyword">let</code> <code class="identifier">spWhile</code> = <code class="identifier">DebugPointAtWhile</code>.<code class="identifier">Yes</code> <code class="identifier">mWhileHeader</code> 
        <code class="keyword">let</code> <code class="identifier">mWhileAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>
        <code class="identifier">SynExpr</code>.<code class="identifier">While</code> (<code class="identifier">spWhile</code>, $2, $4, <code class="identifier">mWhileAll</code>) }
      
  | <code class="identifier">WHILE</code> <code class="identifier">declExpr</code> <code class="identifier">doToken</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $5 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileWhile</code>())
        <code class="keyword">let</code> <code class="identifier">mWhileHeader</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>
        <code class="keyword">let</code> <code class="identifier">spWhile</code> = <code class="identifier">DebugPointAtWhile</code>.<code class="identifier">Yes</code> <code class="identifier">mWhileHeader</code> 
        <code class="keyword">let</code> <code class="identifier">mWhileAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">While</code> (<code class="identifier">spWhile</code>, $2, $4, <code class="identifier">mWhileAll</code>)) }

  | <code class="identifier">WHILE</code> <code class="identifier">declExpr</code> <code class="identifier">doToken</code> <code class="keyword">error</code> <code class="identifier">doneDeclEnd</code> 
      { <code class="comment">// silent recovery </code>
        <code class="keyword">let</code> <code class="identifier">mWhileHeader</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>
        <code class="keyword">let</code> <code class="identifier">spWhile</code> = <code class="identifier">DebugPointAtWhile</code>.<code class="identifier">Yes</code> <code class="identifier">mWhileHeader</code> 
        <code class="keyword">let</code> <code class="identifier">mWhileBodyArb</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 4) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 5)
        <code class="keyword">let</code> <code class="identifier">mWhileAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 5)
        <code class="identifier">SynExpr</code>.<code class="identifier">While</code> (<code class="identifier">spWhile</code>, $2, <code class="identifier">arbExpr</code>(<code class="string">"whileBody1"</code>, <code class="identifier">mWhileBodyArb</code>), <code class="identifier">mWhileAll</code>) }

  | <code class="identifier">WHILE</code> <code class="identifier">declExpr</code> <code class="identifier">recover</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsWhileDoExpected</code>())
        <code class="keyword">let</code> <code class="identifier">mWhileHeader</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>
        <code class="keyword">let</code> <code class="identifier">spWhile</code> = <code class="identifier">DebugPointAtWhile</code>.<code class="identifier">Yes</code> <code class="identifier">mWhileHeader</code> 
        <code class="keyword">let</code> <code class="identifier">mWhileBodyArb</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3
        <code class="keyword">let</code> <code class="identifier">mWhileAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3)
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">While</code> (<code class="identifier">spWhile</code>, $2, <code class="identifier">arbExpr</code>(<code class="string">"whileBody2"</code>, <code class="identifier">mWhileBodyArb</code>), <code class="identifier">mWhileAll</code>))  }

  | <code class="identifier">WHILE</code> <code class="identifier">recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $2 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileWhile</code>())
        <code class="identifier">arbExpr</code>(<code class="string">"whileLoop1"</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)  }

  | <code class="identifier">WHILE</code> <code class="keyword">error</code> <code class="identifier">doneDeclEnd</code> 
      { <code class="comment">//silent recovery</code>
        <code class="keyword">let</code> <code class="identifier">mWhileHeader</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
        <code class="keyword">let</code> <code class="identifier">spWhile</code> = <code class="identifier">DebugPointAtWhile</code>.<code class="identifier">Yes</code> <code class="identifier">mWhileHeader</code> 
        <code class="keyword">let</code> <code class="identifier">mWhileBodyArb</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3
        <code class="keyword">let</code> <code class="identifier">mWhileAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3)
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">While</code> (<code class="identifier">spWhile</code>, <code class="identifier">arbExpr</code>(<code class="string">"whileGuard1"</code>, <code class="identifier">mWhileHeader</code>), <code class="identifier">arbExpr</code>(<code class="string">"whileBody3"</code>, <code class="identifier">mWhileBodyArb</code>), <code class="identifier">mWhileAll</code>))  }

  | <code class="identifier">FOR</code> <code class="identifier">forLoopBinder</code> <code class="identifier">doToken</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">doneDeclEnd</code> 
      { <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">_</code>) = $2 
        <code class="identifier">SynExpr</code>.<code class="identifier">ForEach</code> (<code class="identifier">spBind</code>, <code class="identifier">SeqExprOnly</code> <code class="keyword">false</code>, <code class="keyword">true</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, $4, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>) }

  | <code class="identifier">FOR</code> <code class="identifier">forLoopBinder</code> <code class="identifier">doToken</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">ends_coming_soon_or_recover</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> $5 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileFor</code>())
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">_</code>) = $2 
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>
        <code class="identifier">SynExpr</code>.<code class="identifier">ForEach</code> (<code class="identifier">spBind</code>, <code class="identifier">SeqExprOnly</code> <code class="keyword">false</code>, <code class="keyword">true</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, $4, <code class="identifier">mForLoopAll</code>) }  

  | <code class="identifier">FOR</code> <code class="identifier">forLoopBinder</code> <code class="identifier">doToken</code> <code class="keyword">error</code> <code class="identifier">doneDeclEnd</code> 
      { <code class="comment">// Silent recovery</code>
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">_</code>) = $2 
        <code class="keyword">let</code> <code class="identifier">mForLoopBodyArb</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 5
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5
        <code class="identifier">SynExpr</code>.<code class="identifier">ForEach</code> (<code class="identifier">spBind</code>, <code class="identifier">SeqExprOnly</code> <code class="keyword">false</code>, <code class="keyword">true</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">arbExpr</code>(<code class="string">"forLoopBody2a"</code>, <code class="identifier">mForLoopBodyArb</code>), <code class="identifier">mForLoopAll</code>) }

  | <code class="identifier">FOR</code> <code class="identifier">forLoopBinder</code> <code class="identifier">doToken</code> <code class="identifier">ends_coming_soon_or_recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $4 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsExpectedExpressionAfterToken</code>())
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">_</code>) = $2 
        <code class="keyword">let</code> <code class="identifier">mForLoopBodyArb</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="identifier">SynExpr</code>.<code class="identifier">ForEach</code> (<code class="identifier">spBind</code>, <code class="identifier">SeqExprOnly</code> <code class="keyword">false</code>, <code class="keyword">true</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">arbExpr</code>(<code class="string">"forLoopBody2"</code>, <code class="identifier">mForLoopBodyArb</code>), <code class="identifier">mForLoopAll</code>) }

  | <code class="identifier">FOR</code> <code class="identifier">forLoopBinder</code> <code class="identifier">ends_coming_soon_or_recover</code>
      { <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">ok</code>) = $2 
        <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsForDoExpected</code>())
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> <code class="identifier">mForLoopBodyArb</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="identifier">SynExpr</code>.<code class="identifier">ForEach</code> (<code class="identifier">spBind</code>, <code class="identifier">SeqExprOnly</code> <code class="keyword">false</code>, <code class="keyword">true</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">arbExpr</code>(<code class="string">"forLoopBody1"</code>, <code class="identifier">mForLoopBodyArb</code>), <code class="identifier">mForLoopAll</code>) }

  | <code class="identifier">FOR</code> <code class="identifier">forLoopRange</code>  <code class="identifier">doToken</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">doneDeclEnd</code> 
      { <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>) = $2 
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>
        <code class="identifier">SynExpr</code>.<code class="identifier">For</code> (<code class="identifier">spBind</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, $4, <code class="identifier">mForLoopAll</code>) }

  | <code class="identifier">FOR</code> <code class="identifier">forLoopRange</code>  <code class="identifier">doToken</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $5 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileFor</code>())
        <code class="comment">// Still produce an expression</code>
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>) = $2 
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">For</code> (<code class="identifier">spBind</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, $4, <code class="identifier">mForLoopAll</code>)) }

  | <code class="identifier">FOR</code> <code class="identifier">forLoopRange</code>  <code class="identifier">doToken</code> <code class="keyword">error</code> <code class="identifier">doneDeclEnd</code> 
      { <code class="comment">// silent recovery </code>
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>) = $2 
        <code class="keyword">let</code> <code class="identifier">mForLoopBodyArb</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 5
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5
        <code class="identifier">SynExpr</code>.<code class="identifier">For</code> (<code class="identifier">spBind</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">arbExpr</code>(<code class="string">"declExpr11"</code>, <code class="identifier">mForLoopBodyArb</code>), <code class="identifier">mForLoopAll</code>) }

  | <code class="identifier">FOR</code> <code class="identifier">forLoopRange</code>  <code class="identifier">doToken</code> <code class="identifier">recover</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> $4 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileFor</code>())
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>) = $2 
        <code class="keyword">let</code> <code class="identifier">mForLoopBodyArb</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">For</code> (<code class="identifier">spBind</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">arbExpr</code>(<code class="string">"declExpr11"</code>, <code class="identifier">mForLoopBodyArb</code>), <code class="identifier">mForLoopAll</code>)) }

  | <code class="identifier">FOR</code> <code class="identifier">forLoopRange</code> <code class="identifier">recover</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileFor</code>())
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>) = $2 
        <code class="keyword">let</code> <code class="identifier">mForLoopBodyArb</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2).<code class="identifier">EndRange</code>
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">For</code> (<code class="identifier">spBind</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">arbExpr</code>(<code class="string">"declExpr11"</code>, <code class="identifier">mForLoopBodyArb</code>), <code class="identifier">mForLoopAll</code>)) }


  | <code class="identifier">FOR</code> <code class="keyword">error</code> <code class="identifier">doToken</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">doneDeclEnd</code> 
      { <code class="comment">// silent recovery </code>
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="identifier">SynExpr</code>.<code class="identifier">For</code> (<code class="identifier">spBind</code>, <code class="identifier">mkSynId</code> <code class="identifier">mForLoopHeader</code> <code class="string">"_loopVar"</code>, <code class="identifier">arbExpr</code>(<code class="string">"startLoopRange1"</code>, <code class="identifier">mForLoopHeader</code>), <code class="keyword">true</code>, <code class="identifier">arbExpr</code>(<code class="string">"endLoopRange1"</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3), $4, <code class="identifier">mForLoopAll</code>) }

  | <code class="identifier">FOR</code> <code class="identifier">ends_coming_soon_or_recover</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIdentifierExpected</code>())
        <code class="identifier">arbExpr</code>(<code class="string">"declExpr12"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)) }

  | <code class="identifier">FOR</code> <code class="identifier">parenPattern</code> <code class="keyword">error</code> <code class="identifier">doneDeclEnd</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInOrEqualExpected</code>())
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> <code class="identifier">mForLoopBodyArb</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 4
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4
        <code class="identifier">SynExpr</code>.<code class="identifier">ForEach</code> (<code class="identifier">spBind</code>, <code class="identifier">SeqExprOnly</code> <code class="keyword">false</code>, <code class="keyword">true</code>, $2, <code class="identifier">arbExpr</code>(<code class="string">"forLoopCollection"</code>, <code class="identifier">mForLoopHeader</code>), <code class="identifier">arbExpr</code>(<code class="string">"forLoopBody3"</code>, <code class="identifier">mForLoopBodyArb</code>), <code class="identifier">mForLoopAll</code>) }

  | <code class="identifier">FOR</code> <code class="identifier">parenPattern</code> <code class="identifier">recover</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileFor</code>())
        <code class="keyword">let</code> <code class="identifier">mForLoopHeader</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2
        <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> <code class="identifier">mForLoopHeader</code>
        <code class="keyword">let</code> <code class="identifier">mForLoopBodyArb</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2).<code class="identifier">EndRange</code>
        <code class="keyword">let</code> <code class="identifier">mForLoopAll</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">ForEach</code> (<code class="identifier">spBind</code>, <code class="identifier">SeqExprOnly</code> <code class="keyword">false</code>, <code class="keyword">true</code>, $2, <code class="identifier">arbExpr</code>(<code class="string">"forLoopCollection"</code>, <code class="identifier">mForLoopHeader</code>), <code class="identifier">arbExpr</code>(<code class="string">"forLoopBody3"</code>, <code class="identifier">mForLoopBodyArb</code>), <code class="identifier">mForLoopAll</code>)) }

  | <code class="identifier">YIELD</code> <code class="identifier">declExpr</code>
     { <code class="identifier">SynExpr</code>.<code class="identifier">YieldOrReturn</code> (($1, <code class="keyword">not</code> $1), $2, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) } 

  | <code class="identifier">YIELD_BANG</code> <code class="identifier">declExpr</code>
     { <code class="identifier">SynExpr</code>.<code class="identifier">YieldOrReturnFrom</code> (($1, <code class="keyword">not</code> $1), $2, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) } 

  | <code class="identifier">YIELD</code> <code class="identifier">recover</code>
     { <code class="keyword">let</code> <code class="identifier">mYieldAll</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       <code class="identifier">SynExpr</code>.<code class="identifier">YieldOrReturn</code> (($1, <code class="keyword">not</code> $1), <code class="identifier">arbExpr</code>(<code class="string">"yield"</code>, <code class="identifier">mYieldAll</code>), <code class="identifier">mYieldAll</code>) } 

  | <code class="identifier">YIELD_BANG</code> <code class="identifier">recover</code>
     { <code class="keyword">let</code> <code class="identifier">mYieldAll</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       <code class="identifier">SynExpr</code>.<code class="identifier">YieldOrReturnFrom</code> (($1, <code class="keyword">not</code> $1), <code class="identifier">arbExpr</code>(<code class="string">"yield!"</code>, <code class="identifier">mYieldAll</code>), <code class="identifier">mYieldAll</code>) } 

  | <code class="identifier">BINDER</code> <code class="identifier">headBindingPattern</code> <code class="identifier">EQUALS</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">IN</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="identifier">moreBinders</code> <code class="identifier">typedSeqExprBlock</code> <code class="keyword">%prec</code> <code class="identifier">expr_let</code>
     { <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code>(<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 5)
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $8.<code class="identifier">Range</code>
       <code class="identifier">SynExpr</code>.<code class="identifier">LetOrUseBang</code>(<code class="identifier">spBind</code>, ($1 = <code class="string">"use"</code>), <code class="keyword">true</code>, $2, $4, $7, $8, <code class="identifier">m</code>) }

  | <code class="identifier">OBINDER</code> <code class="identifier">headBindingPattern</code> <code class="identifier">EQUALS</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">hardwhiteDefnBindingsTerminator</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="identifier">moreBinders</code> <code class="identifier">typedSeqExprBlock</code> <code class="keyword">%prec</code> <code class="identifier">expr_let</code>
     { $5 (<code class="keyword">if</code> $1 = <code class="string">"use"</code> <code class="keyword">then</code> <code class="string">"use!"</code> <code class="keyword">else</code> <code class="string">"let!"</code>) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)  <code class="comment">// report unterminated error </code>
       <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code>(<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>)
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $8.<code class="identifier">Range</code>
       <code class="identifier">SynExpr</code>.<code class="identifier">LetOrUseBang</code>(<code class="identifier">spBind</code>, ($1 = <code class="string">"use"</code>), <code class="keyword">true</code>, $2, $4, $7, $8, <code class="identifier">m</code>) }

  | <code class="identifier">OBINDER</code> <code class="identifier">headBindingPattern</code> <code class="identifier">EQUALS</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">hardwhiteDefnBindingsTerminator</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="keyword">error</code> <code class="keyword">%prec</code> <code class="identifier">expr_let</code> 
     { <code class="comment">// error recovery that allows intellisense when writing incomplete computation expressions </code>
       <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code>(<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>) 
       <code class="keyword">let</code> <code class="identifier">mAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 7)
       <code class="keyword">let</code> <code class="identifier">m</code> = $4.<code class="identifier">Range</code>.<code class="identifier">EndRange</code> <code class="comment">// zero-width range</code>
       <code class="identifier">SynExpr</code>.<code class="identifier">LetOrUseBang</code>(<code class="identifier">spBind</code>, ($1 = <code class="string">"use"</code>), <code class="keyword">true</code>, $2, $4, [], <code class="identifier">SynExpr</code>.<code class="identifier">ImplicitZero</code> <code class="identifier">m</code>, <code class="identifier">mAll</code>) }

  | <code class="identifier">DO_BANG</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">IN</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="identifier">typedSeqExprBlock</code> <code class="keyword">%prec</code> <code class="identifier">expr_let</code> 
     { <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtDo</code>
       <code class="identifier">SynExpr</code>.<code class="identifier">LetOrUseBang</code>(<code class="identifier">spBind</code>, <code class="keyword">false</code>, <code class="keyword">true</code>, <code class="identifier">SynPat</code>.<code class="identifier">Const</code>(<code class="identifier">SynConst</code>.<code class="identifier">Unit</code>, $2.<code class="identifier">Range</code>), $2, [], $5, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $5.<code class="identifier">Range</code>) }

  | <code class="identifier">ODO_BANG</code> <code class="identifier">typedSeqExprBlock</code> <code class="identifier">hardwhiteDefnBindingsTerminator</code> <code class="keyword">%prec</code> <code class="identifier">expr_let</code> 
     { <code class="identifier">SynExpr</code>.<code class="identifier">DoBang</code> ($2, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) }

  | <code class="identifier">FOR</code> <code class="identifier">forLoopBinder</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="identifier">arrowThenExprR</code> <code class="keyword">%prec</code> <code class="identifier">expr_let</code> 
     { <code class="keyword">let</code> <code class="identifier">spBind</code> = <code class="identifier">DebugPointAtFor</code>.<code class="identifier">Yes</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2)
       <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">_</code>) = $2 <code class="keyword">in</code> <code class="identifier">SynExpr</code>.<code class="identifier">ForEach</code> (<code class="identifier">spBind</code>, <code class="identifier">SeqExprOnly</code> <code class="keyword">true</code>, <code class="keyword">true</code>, <code class="identifier">a</code>, <code class="identifier">b</code>, $4, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>) }

  | <code class="identifier">FIXED</code> <code class="identifier">declExpr</code>
     { <code class="identifier">SynExpr</code>.<code class="identifier">Fixed</code> ($2, (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>)) } 

  | <code class="identifier">RARROW</code> <code class="identifier">typedSeqExprBlockR</code> 
     { <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsArrowUseIsLimited</code>(), <code class="identifier">lhs</code> <code class="identifier">parseState</code>))
       <code class="identifier">SynExpr</code>.<code class="identifier">YieldOrReturn</code> ((<code class="keyword">true</code>, <code class="keyword">true</code>), $2, (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>)) } 

  | <code class="identifier">declExpr</code> <code class="identifier">COLON_QMARK</code> <code class="identifier">typ</code>
     { <code class="identifier">SynExpr</code>.<code class="identifier">TypeTest</code> ($1, $3, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code>) }

  | <code class="identifier">declExpr</code> <code class="identifier">COLON_GREATER</code> <code class="identifier">typ</code>
     { <code class="identifier">SynExpr</code>.<code class="identifier">Upcast</code> ($1, $3, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code>) } 

  | <code class="identifier">declExpr</code> <code class="identifier">COLON_QMARK_GREATER</code> <code class="identifier">typ</code>
     { <code class="identifier">SynExpr</code>.<code class="identifier">Downcast</code> ($1, $3, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code>) }

  | <code class="identifier">declExpr</code> <code class="identifier">COLON_EQUALS</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">":="</code> $3 }
  
  | <code class="identifier">minusExpr</code> <code class="identifier">LARROW</code> <code class="identifier">declExprBlock</code>
     { <code class="identifier">mkSynAssign</code> $1 $3 }

  | <code class="identifier">tupleExpr</code>  <code class="keyword">%prec</code> <code class="identifier">expr_tuple</code>
     { <code class="keyword">let</code> <code class="identifier">exprs</code>, <code class="identifier">commas</code> = $1
       <code class="identifier">SynExpr</code>.<code class="identifier">Tuple</code> (<code class="keyword">false</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">exprs</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">commas</code>, (<code class="identifier">commas</code>.<code class="identifier">Head</code>, <code class="identifier">exprs</code>) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> <code class="identifier">e</code> -&gt; <code class="identifier">e</code>.<code class="identifier">Range</code>) ) }

  | <code class="identifier">declExpr</code> <code class="identifier">JOIN_IN</code> <code class="identifier">declExpr</code>
     { <code class="identifier">SynExpr</code>.<code class="identifier">JoinIn</code> ($1, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2, $3, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code>) }

  | <code class="identifier">declExpr</code> <code class="identifier">BAR_BAR</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"||"</code> $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_BAR_OP</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">OR</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"or"</code> $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">AMP</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"&amp;"</code> $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">AMP_AMP</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"&amp;&amp;"</code> $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_AMP_OP</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">EQUALS</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"="</code> $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_COMPARE_OP</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">DOLLAR</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"$"</code> $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">LESS</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"&lt;"</code> $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">LESS</code> <code class="identifier">recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"&lt;"</code>))  
       <code class="identifier">exprFromParseError</code> (<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"&lt;"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">GREATER</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"&gt;"</code> $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_AT_HAT_OP</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">PERCENT_OP</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">COLON_COLON</code> <code class="identifier">declExpr</code>
     { <code class="keyword">let</code> <code class="identifier">tupExpr</code> = <code class="identifier">SynExpr</code>.<code class="identifier">Tuple</code> (<code class="keyword">false</code>, [$1;$3], [<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2], <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code>)
       <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">ExprAtomicFlag</code>.<code class="identifier">NonAtomic</code>, <code class="keyword">true</code>, <code class="identifier">mkSynIdGet</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) <code class="identifier">opNameCons</code>, <code class="identifier">tupExpr</code>, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code>) }

  | <code class="identifier">declExpr</code> <code class="identifier">PLUS_MINUS_OP</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">MINUS</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"-"</code> $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">STAR</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"*"</code> $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_STAR_STAR_OP</code> <code class="identifier">declExpr</code>
     { <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 $3 }

  | <code class="identifier">declExpr</code> <code class="identifier">JOIN_IN</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"in"</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"@in"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">BAR_BAR</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"||"</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"||"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_BAR_OP</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>($2)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">OR</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"or"</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"or"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">AMP</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"&amp;"</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"&amp;"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">AMP_AMP</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"&amp;&amp;"</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"&amp;&amp;"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_AMP_OP</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>($2)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">EQUALS</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"="</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"="</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_COMPARE_OP</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>($2)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">DOLLAR</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"$"</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"$"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">LESS</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"&lt;"</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"&lt;"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">GREATER</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"&gt;"</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"&gt;"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_AT_HAT_OP</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>($2)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">PERCENT_OP</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>($2)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">COLON_COLON</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"::"</code>)) 
       <code class="keyword">let</code> <code class="identifier">tupExpr</code> = <code class="identifier">SynExpr</code>.<code class="identifier">Tuple</code> (<code class="keyword">false</code>, [$1;(<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))], [<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2], <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>)
       <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">ExprAtomicFlag</code>.<code class="identifier">NonAtomic</code>, <code class="keyword">true</code>, <code class="identifier">mkSynIdGet</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) <code class="identifier">opNameCons</code>, <code class="identifier">tupExpr</code>, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>) }

  | <code class="identifier">declExpr</code> <code class="identifier">PLUS_MINUS_OP</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>($2)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">MINUS</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"-"</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"-"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">STAR</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>(<code class="string">"*"</code>)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 <code class="string">"*"</code> (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>($2)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">declExpr</code> <code class="identifier">INFIX_STAR_STAR_OP</code> <code class="identifier">OBLOCKEND_COMING_SOON</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnfinishedExpression</code>($2)) 
       <code class="identifier">exprFromParseError</code>(<code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) $1 $2 (<code class="identifier">arbExpr</code>(<code class="string">"declExprInfix"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>))) }

  | <code class="identifier">minusExpr</code> <code class="keyword">%prec</code> <code class="identifier">expr_prefix_plus_minus</code> { $1 }

<code class="identifier">dynamicArg</code>:
  | <code class="identifier">IDENT</code>
      { <code class="keyword">let</code> <code class="identifier">con</code> = <code class="identifier">SynConst</code>.<code class="identifier">String</code> ($1, <code class="identifier">SynStringKind</code>.<code class="identifier">Regular</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
        <code class="keyword">let</code> <code class="identifier">arg2</code> = <code class="identifier">SynExpr</code>.<code class="identifier">Const</code> (<code class="identifier">con</code>, <code class="identifier">con</code>.<code class="identifier">Range</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)) 
        <code class="identifier">arg2</code> }

  | <code class="identifier">LPAREN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">rparen</code>
      { $2 }

<code class="identifier">withClauses</code>:
  | <code class="identifier">WITH</code> <code class="identifier">withPatternClauses</code>       
      { <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, $2 }

  | <code class="identifier">OWITH</code> <code class="identifier">withPatternClauses</code> <code class="identifier">OEND</code> 
      { <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, $2 }

  | <code class="identifier">OWITH</code> <code class="identifier">withPatternClauses</code> <code class="identifier">recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileWith</code>())
        <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, $2 }

<code class="identifier">withPatternClauses</code>:
  | <code class="identifier">patternClauses</code> 
      { $1 }

  | <code class="identifier">BAR</code> <code class="identifier">patternClauses</code> 
      { $2 }

  | <code class="identifier">BAR</code> <code class="keyword">error</code> 
      { <code class="comment">// silent recovery </code>
        <code class="keyword">let</code> <code class="identifier">mLast</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
        [], <code class="identifier">mLast</code> }

  | <code class="keyword">error</code>  
      { <code class="comment">// silent recovery </code>
        <code class="keyword">let</code> <code class="identifier">mLast</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
        [], <code class="identifier">mLast</code> }


<code class="identifier">patternAndGuard</code>: 
  | <code class="identifier">parenPattern</code> <code class="identifier">patternGuard</code> 
      { $1, $2, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 }
      
<code class="identifier">patternClauses</code>: 
  | <code class="identifier">patternAndGuard</code> <code class="identifier">patternResult</code> <code class="keyword">%prec</code> <code class="identifier">prec_pat_pat_action</code>
     { <code class="keyword">let</code> <code class="identifier">pat</code>, <code class="identifier">guard</code>, <code class="identifier">patm</code> = $1 
       <code class="keyword">let</code> <code class="identifier">mLast</code> = $2.<code class="identifier">Range</code> 
       [<code class="identifier">SynMatchClause</code>(<code class="identifier">pat</code>, <code class="identifier">guard</code>, $2, <code class="identifier">patm</code>, <code class="identifier">DebugPointForTarget</code>.<code class="identifier">Yes</code>)], <code class="identifier">mLast</code>  }

  | <code class="identifier">patternAndGuard</code> <code class="identifier">patternResult</code> <code class="identifier">BAR</code> <code class="identifier">patternClauses</code> 
     { <code class="keyword">let</code> <code class="identifier">pat</code>, <code class="identifier">guard</code>, <code class="identifier">patm</code> = $1 
       <code class="keyword">let</code> <code class="identifier">clauses</code>, <code class="identifier">mLast</code> = $4 
       (<code class="identifier">SynMatchClause</code>(<code class="identifier">pat</code>, <code class="identifier">guard</code>, $2, <code class="identifier">patm</code>, <code class="identifier">DebugPointForTarget</code>.<code class="identifier">Yes</code>) :: <code class="identifier">clauses</code>), <code class="identifier">mLast</code> }

  | <code class="identifier">patternAndGuard</code> <code class="identifier">patternResult</code> <code class="identifier">BAR</code> <code class="keyword">error</code> 
     { <code class="keyword">let</code> <code class="identifier">pat</code>, <code class="identifier">guard</code>, <code class="identifier">patm</code> = $1 
       <code class="keyword">let</code> <code class="identifier">mLast</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3 
       <code class="comment">// silent recovery </code>
       [<code class="identifier">SynMatchClause</code>(<code class="identifier">pat</code>, <code class="identifier">guard</code>, $2, <code class="identifier">patm</code>, <code class="identifier">DebugPointForTarget</code>.<code class="identifier">Yes</code>)], <code class="identifier">mLast</code>  }

  | <code class="identifier">patternAndGuard</code> <code class="identifier">patternResult</code> <code class="keyword">error</code> 
     { <code class="keyword">let</code> <code class="identifier">pat</code>, <code class="identifier">guard</code>, <code class="identifier">patm</code> = $1 
       <code class="keyword">let</code> <code class="identifier">mLast</code> = $2.<code class="identifier">Range</code> 
       <code class="comment">// silent recovery </code>
       [<code class="identifier">SynMatchClause</code>(<code class="identifier">pat</code>, <code class="identifier">guard</code>, $2, <code class="identifier">patm</code>, <code class="identifier">DebugPointForTarget</code>.<code class="identifier">Yes</code>)], <code class="identifier">mLast</code> }

  | <code class="identifier">patternAndGuard</code> <code class="keyword">error</code> 
     { <code class="keyword">let</code> <code class="identifier">pat</code>, <code class="identifier">guard</code>, <code class="identifier">patm</code> = $1 
       <code class="keyword">let</code> <code class="identifier">mLast</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2
       <code class="comment">// silent recovery </code>
       [<code class="identifier">SynMatchClause</code>(<code class="identifier">pat</code>, <code class="identifier">guard</code>, <code class="identifier">SynExpr</code>.<code class="identifier">Const</code> (<code class="identifier">SynConst</code>.<code class="identifier">Unit</code>, <code class="identifier">mLast</code>.<code class="identifier">EndRange</code>), <code class="identifier">patm</code>, <code class="identifier">DebugPointForTarget</code>.<code class="identifier">Yes</code>)], <code class="identifier">mLast</code> }
 
<code class="identifier">patternGuard</code>: 
  | <code class="identifier">WHEN</code> <code class="identifier">declExpr</code> 
     { <code class="identifier">Some</code> $2 }

  | <code class="comment">/* EMPTY */</code>
     { <code class="identifier">None</code> }

<code class="identifier">patternResult</code>: 
  | <code class="identifier">RARROW</code> <code class="identifier">typedSeqExprBlockR</code>  
     { $2 }

<code class="identifier">ifExprCases</code>: 
  | <code class="identifier">ifExprThen</code> <code class="identifier">ifExprElifs</code> 
      { <code class="keyword">let</code> <code class="identifier">exprThen</code>, <code class="identifier">mThen</code> = $1 
        (<code class="keyword">fun</code> <code class="identifier">exprGuard</code> <code class="identifier">mIf</code> -&gt; 
            <code class="keyword">let</code> <code class="identifier">mIfToThen</code> = <code class="identifier">unionRanges</code> <code class="identifier">mIf</code> <code class="identifier">mThen</code>
            <code class="keyword">let</code> <code class="identifier">lastBranch</code> : <code class="identifier">SynExpr</code> = <code class="keyword">match</code> $2 <code class="keyword">with</code> <code class="identifier">None</code> -&gt; <code class="identifier">exprThen</code> | <code class="identifier">Some</code> <code class="identifier">e</code> -&gt; <code class="identifier">e</code>
            <code class="keyword">let</code> <code class="identifier">mIfToEndOfLastBranch</code> = <code class="identifier">unionRanges</code> <code class="identifier">mIf</code> <code class="identifier">lastBranch</code>.<code class="identifier">Range</code>
            <code class="keyword">let</code> <code class="identifier">spIfToThen</code> = <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">Yes</code>(<code class="identifier">mIfToThen</code>)
            <code class="identifier">SynExpr</code>.<code class="identifier">IfThenElse</code> (<code class="identifier">exprGuard</code>, <code class="identifier">exprThen</code>, $2, <code class="identifier">spIfToThen</code>, <code class="keyword">false</code>, <code class="identifier">mIfToThen</code>, <code class="identifier">mIfToEndOfLastBranch</code>)) }

<code class="identifier">ifExprThen</code>: 
  | <code class="identifier">THEN</code>  <code class="identifier">declExpr</code> <code class="keyword">%prec</code> <code class="identifier">prec_then_if</code> 
      { $2, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 }

  | <code class="identifier">OTHEN</code>  <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">oblockend</code> <code class="keyword">%prec</code> <code class="identifier">prec_then_if</code> 
      { $3, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 }

  | <code class="identifier">OTHEN</code>  <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">recover</code> <code class="keyword">%prec</code> <code class="identifier">prec_then_if</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $4 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileThen</code>())
        <code class="identifier">exprFromParseError</code> $3, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 }

<code class="identifier">ifExprElifs</code>: 
  | <code class="comment">/* EMPTY */</code>
      { <code class="identifier">None</code> }

  | <code class="identifier">ELSE</code> <code class="identifier">declExpr</code> 
      { <code class="identifier">Some</code> $2 }

  | <code class="identifier">OELSE</code>  <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">oblockend</code> 
      { <code class="identifier">Some</code> $3 }

  | <code class="identifier">OELSE</code>  <code class="identifier">OBLOCKBEGIN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">recover</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> $4 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileElse</code>())
        <code class="identifier">Some</code> (<code class="identifier">exprFromParseError</code> $3) }

  | <code class="identifier">ELIF</code> <code class="identifier">declExpr</code> <code class="identifier">ifExprCases</code> 
      { <code class="keyword">let</code> <code class="identifier">mElif</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
        <code class="identifier">Some</code> ($3 $2 <code class="identifier">mElif</code>) }

  | <code class="identifier">ELIF</code> <code class="identifier">declExpr</code> <code class="identifier">recover</code> 
      { <code class="identifier">Some</code> (<code class="identifier">exprFromParseError</code> $2) }

<code class="identifier">tupleExpr</code>: 
  | <code class="identifier">tupleExpr</code> <code class="identifier">COMMA</code> <code class="identifier">declExpr</code>   
      { <code class="keyword">let</code> <code class="identifier">exprs</code>, <code class="identifier">commas</code> = $1 <code class="keyword">in</code> ($3 :: <code class="identifier">exprs</code>), ((<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) :: <code class="identifier">commas</code>) }

  | <code class="identifier">tupleExpr</code> <code class="identifier">COMMA</code> <code class="identifier">ends_coming_soon_or_recover</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsExpectedExpressionAfterToken</code>())
        <code class="keyword">let</code> <code class="identifier">exprs</code>, <code class="identifier">commas</code> = $1     
        <code class="keyword">let</code> <code class="identifier">zeroWidthAtNextToken</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>
        ((<code class="identifier">arbExpr</code>(<code class="string">"tupleExpr1"</code>, <code class="identifier">zeroWidthAtNextToken</code>)) :: <code class="identifier">exprs</code>), (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) :: <code class="identifier">commas</code> }

  | <code class="identifier">declExpr</code> <code class="identifier">COMMA</code> <code class="identifier">ends_coming_soon_or_recover</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsExpectedExpressionAfterToken</code>())
        <code class="keyword">let</code> <code class="identifier">zeroWidthAtNextToken</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code> 
        ((<code class="identifier">arbExpr</code>(<code class="string">"tupleExpr2"</code>, <code class="identifier">zeroWidthAtNextToken</code>)) :: [$1]), [<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2] }

  | <code class="identifier">declExpr</code> <code class="identifier">COMMA</code> <code class="identifier">declExpr</code>  
      { [$3 ; $1], [<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2] }

<code class="identifier">minusExpr</code>: 
  | <code class="identifier">MINUS</code> <code class="identifier">minusExpr</code>   <code class="keyword">%prec</code> <code class="identifier">expr_prefix_plus_minus</code>
      { <code class="identifier">mkSynPrefix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) <code class="string">"~-"</code> $2 }

  | <code class="identifier">PLUS_MINUS_OP</code> <code class="identifier">minusExpr</code>  
      { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">IsValidPrefixOperatorUse</code> $1) <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> $2.<code class="identifier">Range</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidPrefixOperator</code>())
        <code class="identifier">mkSynPrefix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) (<code class="string">"~"</code>^($1)) $2 } 

  | <code class="identifier">ADJACENT_PREFIX_OP</code> <code class="identifier">minusExpr</code> 
      { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">IsValidPrefixOperatorUse</code> $1) <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> $2.<code class="identifier">Range</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidPrefixOperator</code>())
        <code class="identifier">mkSynPrefix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) (<code class="string">"~"</code>^($1)) $2 }

  | <code class="identifier">PERCENT_OP</code> <code class="identifier">minusExpr</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">IsValidPrefixOperatorUse</code> $1) <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> $2.<code class="identifier">Range</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidPrefixOperator</code>())
        <code class="identifier">mkSynPrefix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) (<code class="string">"~"</code>^($1)) $2 }

  | <code class="identifier">AMP</code>  <code class="identifier">minusExpr</code>    
      { <code class="identifier">SynExpr</code>.<code class="identifier">AddressOf</code> (<code class="keyword">true</code>, $2, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) } 

  | <code class="identifier">AMP_AMP</code>  <code class="identifier">minusExpr</code>   
      { <code class="identifier">SynExpr</code>.<code class="identifier">AddressOf</code> (<code class="keyword">false</code>, $2, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) } 

  | <code class="identifier">NEW</code> <code class="identifier">atomTypeNonAtomicDeprecated</code>  <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="identifier">atomicExprAfterType</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">New</code> (<code class="keyword">false</code>, $2, $4, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>) }

  | <code class="identifier">NEW</code> <code class="identifier">atomTypeNonAtomicDeprecated</code> <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="keyword">error</code>   
      { <code class="identifier">SynExpr</code>.<code class="identifier">New</code> (<code class="keyword">false</code>, $2, <code class="identifier">arbExpr</code>(<code class="string">"minusExpr"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 4)), <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) ($2).<code class="identifier">Range</code>) }

  | <code class="identifier">NEW</code> <code class="keyword">error</code>
      { <code class="identifier">arbExpr</code>(<code class="string">"minusExpr2"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)) }

  | <code class="identifier">UPCAST</code>  <code class="identifier">minusExpr</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">InferredUpcast</code> ($2, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) }   

  | <code class="identifier">DOWNCAST</code>  <code class="identifier">minusExpr</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">InferredDowncast</code> ($2, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>)}   

  | <code class="identifier">appExpr</code> 
      { $1 }

<code class="identifier">appExpr</code>:
  | <code class="identifier">appExpr</code> <code class="identifier">argExpr</code> <code class="keyword">%prec</code> <code class="identifier">expr_app</code>
      { <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">ExprAtomicFlag</code>.<code class="identifier">NonAtomic</code>, <code class="keyword">false</code>, $1, $2, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $2.<code class="identifier">Range</code>)  }

  | <code class="identifier">atomicExpr</code> 
      { <code class="keyword">let</code> <code class="identifier">arg</code>, <code class="identifier">_</code> = $1 
        <code class="identifier">arg</code> }

<code class="identifier">argExpr</code>:
  | <code class="identifier">ADJACENT_PREFIX_OP</code> <code class="identifier">atomicExpr</code> 
      { <code class="keyword">let</code> <code class="identifier">arg2</code>, <code class="identifier">hpa2</code> = $2 
        <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">IsValidPrefixOperatorUse</code> $1) <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> <code class="identifier">arg2</code>.<code class="identifier">Range</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidPrefixOperator</code>())
        <code class="keyword">if</code> <code class="identifier">hpa2</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSuccessiveArgsShouldBeSpacedOrTupled</code>())
        <code class="identifier">mkSynPrefix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">arg2</code>.<code class="identifier">Range</code>) (<code class="string">"~"</code>^($1)) <code class="identifier">arg2</code> }

   | <code class="identifier">atomicExpr</code> 
      { <code class="keyword">let</code> <code class="identifier">arg</code>, <code class="identifier">hpa</code> = $1 
        <code class="keyword">if</code> <code class="identifier">hpa</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> <code class="identifier">arg</code>.<code class="identifier">Range</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSuccessiveArgsShouldBeSpacedOrTupled</code>())
        <code class="identifier">arg</code> }
    
<code class="identifier">atomicExpr</code>:
  | <code class="identifier">atomicExpr</code> <code class="identifier">HIGH_PRECEDENCE_BRACK_APP</code> <code class="identifier">atomicExpr</code>
      { <code class="keyword">let</code> <code class="identifier">arg1</code>, <code class="identifier">_</code> = $1 
        <code class="keyword">let</code> <code class="identifier">arg2</code>, <code class="identifier">_</code> = $3 
        <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">ExprAtomicFlag</code>.<code class="identifier">Atomic</code>, <code class="keyword">false</code>, <code class="identifier">arg1</code>, <code class="identifier">arg2</code>, <code class="identifier">unionRanges</code> <code class="identifier">arg1</code>.<code class="identifier">Range</code> <code class="identifier">arg2</code>.<code class="identifier">Range</code>), <code class="keyword">true</code>  }

  | <code class="identifier">atomicExpr</code> <code class="identifier">HIGH_PRECEDENCE_PAREN_APP</code> <code class="identifier">atomicExpr</code>
      { <code class="keyword">let</code> <code class="identifier">arg1</code>, <code class="identifier">_</code> = $1 
        <code class="keyword">let</code> <code class="identifier">arg2</code>, <code class="identifier">_</code> = $3 
        <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">ExprAtomicFlag</code>.<code class="identifier">Atomic</code>, <code class="keyword">false</code>, <code class="identifier">arg1</code>, <code class="identifier">arg2</code>, <code class="identifier">unionRanges</code> <code class="identifier">arg1</code>.<code class="identifier">Range</code> <code class="identifier">arg2</code>.<code class="identifier">Range</code>), <code class="keyword">true</code>  }

  | <code class="identifier">atomicExpr</code> <code class="identifier">HIGH_PRECEDENCE_TYAPP</code> <code class="identifier">typeArgsActual</code>
      { <code class="keyword">let</code> <code class="identifier">arg1</code>, <code class="identifier">_</code> = $1 
        <code class="keyword">let</code> <code class="identifier">mLessThan</code>, <code class="identifier">mGreaterThan</code>, <code class="identifier">_</code>, <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">mTypeArgs</code> = $3
        <code class="keyword">let</code> <code class="identifier">mWholeExpr</code> = <code class="identifier">unionRanges</code> <code class="identifier">arg1</code>.<code class="identifier">Range</code> <code class="identifier">mTypeArgs</code>
        <code class="identifier">SynExpr</code>.<code class="identifier">TypeApp</code> (<code class="identifier">arg1</code>, <code class="identifier">mLessThan</code>, <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">mGreaterThan</code>, <code class="identifier">mTypeArgs</code>, <code class="identifier">mWholeExpr</code>), <code class="keyword">false</code> }

  | <code class="identifier">PREFIX_OP</code> <code class="identifier">atomicExpr</code>  
      { <code class="keyword">let</code> <code class="identifier">arg2</code>, <code class="identifier">hpa2</code> = $2 
        <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">IsValidPrefixOperatorUse</code> $1) <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> <code class="identifier">arg2</code>.<code class="identifier">Range</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidPrefixOperator</code>())
        <code class="identifier">mkSynPrefixPrim</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">arg2</code>.<code class="identifier">Range</code>) $1 <code class="identifier">arg2</code>, <code class="identifier">hpa2</code> }

  | <code class="identifier">atomicExpr</code> <code class="identifier">DOT</code> <code class="identifier">atomicExprQualification</code> 
      { <code class="keyword">let</code> <code class="identifier">arg1</code>, <code class="identifier">hpa1</code> = $1 
        $3 <code class="identifier">arg1</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2), <code class="identifier">hpa1</code> }

  | <code class="identifier">BASE</code> <code class="identifier">DOT</code> <code class="identifier">atomicExprQualification</code> 
      { <code class="keyword">let</code> <code class="identifier">arg1</code> = <code class="identifier">SynExpr</code>.<code class="identifier">Ident</code> (<code class="identifier">ident</code>(<code class="string">"base"</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
        $3 <code class="identifier">arg1</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2), <code class="keyword">false</code> }

  | <code class="identifier">QMARK</code> <code class="identifier">nameop</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">LongIdent</code> (<code class="keyword">true</code>, <code class="identifier">LongIdentWithDots</code>([$2], []), <code class="identifier">None</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2), <code class="keyword">false</code> }

  | <code class="identifier">atomicExpr</code> <code class="identifier">QMARK</code> <code class="identifier">dynamicArg</code>
      { <code class="keyword">let</code> <code class="identifier">arg1</code>, <code class="identifier">hpa1</code> = $1
        <code class="identifier">mkSynInfix</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) <code class="identifier">arg1</code> <code class="string">"?"</code> $3, <code class="identifier">hpa1</code> }

  | <code class="identifier">GLOBAL</code>
      { <code class="identifier">SynExpr</code>.<code class="identifier">Ident</code> (<code class="identifier">ident</code>(<code class="identifier">MangledGlobalName</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)), <code class="keyword">false</code> }

  | <code class="identifier">identExpr</code>
      { $1, <code class="keyword">false</code> }

  | <code class="identifier">LBRACK</code> <code class="identifier">listExprElements</code> <code class="identifier">RBRACK</code> 
      { $2 (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) <code class="keyword">false</code>, <code class="keyword">false</code> }

  | <code class="identifier">LBRACK</code> <code class="identifier">listExprElements</code> <code class="identifier">recover</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBracket</code>()) 
        <code class="identifier">exprFromParseError</code> ($2 (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2) <code class="keyword">false</code>), <code class="keyword">false</code> }

  | <code class="identifier">LBRACK</code> <code class="keyword">error</code> <code class="identifier">RBRACK</code> 
      { <code class="comment">// silent recovery </code>
        <code class="identifier">SynExpr</code>.<code class="identifier">ArrayOrList</code> (<code class="keyword">false</code>, [ ], <code class="identifier">lhs</code> <code class="identifier">parseState</code>), <code class="keyword">false</code>  } 

  | <code class="identifier">LBRACK</code> <code class="identifier">recover</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBracket</code>()) 
        <code class="comment">// silent recovery </code>
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">ArrayOrList</code> (<code class="keyword">false</code>, [ ], <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)), <code class="keyword">false</code>  } 

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="identifier">tupleExpr</code> <code class="identifier">rparen</code>
      { <code class="keyword">let</code> <code class="identifier">exprs</code>, <code class="identifier">commas</code> = $3
        <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4
        <code class="identifier">SynExpr</code>.<code class="identifier">Tuple</code> (<code class="keyword">true</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">exprs</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">commas</code>, <code class="identifier">m</code>), <code class="keyword">false</code> }

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="identifier">tupleExpr</code> <code class="identifier">recover</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBracket</code>());
        <code class="keyword">let</code> <code class="identifier">exprs</code>, <code class="identifier">commas</code> = $3
        <code class="keyword">let</code> <code class="identifier">m</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, <code class="identifier">exprs</code>) ||&gt; <code class="identifier">unionRangeWithListBy</code> (<code class="keyword">fun</code> <code class="identifier">e</code> -&gt; <code class="identifier">e</code>.<code class="identifier">Range</code>)
        <code class="identifier">SynExpr</code>.<code class="identifier">Tuple</code> (<code class="keyword">true</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">exprs</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">commas</code>, <code class="identifier">m</code>), <code class="keyword">false</code> }

  | <code class="identifier">atomicExprAfterType</code> 
      { $1, <code class="keyword">false</code> }

<code class="identifier">atomicExprQualification</code>:
  | <code class="identifier">identOrOp</code> 
      { <code class="keyword">let</code> <code class="identifier">idm</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
        (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; <code class="identifier">mkSynDot</code> <code class="identifier">dotm</code> <code class="identifier">lhsm</code> <code class="identifier">e</code> $1) }

  | <code class="identifier">GLOBAL</code>
      { (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; 
            <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">nrGlobalUsedOnlyAsFirstName</code>()) 
            <code class="keyword">let</code> <code class="identifier">fixedLhsm</code> = <code class="identifier">mkRange</code> <code class="identifier">lhsm</code>.<code class="identifier">FileName</code> <code class="identifier">lhsm</code>.<code class="identifier">Start</code> <code class="identifier">dotm</code>.<code class="identifier">End</code> <code class="comment">// previous lhsm is wrong after 'recover'</code>
            <code class="identifier">mkSynDotMissing</code> <code class="identifier">dotm</code> <code class="identifier">fixedLhsm</code> <code class="identifier">e</code>) }

  | <code class="comment">/* empty */</code>
      { (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; 
            <code class="identifier">reportParseErrorAt</code> <code class="identifier">dotm</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMissingQualificationAfterDot</code>()) 
            <code class="keyword">let</code> <code class="identifier">fixedLhsm</code> = <code class="identifier">mkRange</code> <code class="identifier">lhsm</code>.<code class="identifier">FileName</code> <code class="identifier">lhsm</code>.<code class="identifier">Start</code> <code class="identifier">dotm</code>.<code class="identifier">End</code> <code class="comment">// previous lhsm is wrong after 'recover'</code>
            <code class="identifier">mkSynDotMissing</code> <code class="identifier">dotm</code> <code class="identifier">fixedLhsm</code> <code class="identifier">e</code>) }
  | <code class="identifier">recover</code> 
      { (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; 
            <code class="identifier">reportParseErrorAt</code> <code class="identifier">dotm</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMissingQualificationAfterDot</code>()) 
            <code class="keyword">let</code> <code class="identifier">fixedLhsm</code> = <code class="identifier">mkRange</code> <code class="identifier">lhsm</code>.<code class="identifier">FileName</code> <code class="identifier">lhsm</code>.<code class="identifier">Start</code> <code class="identifier">dotm</code>.<code class="identifier">End</code> <code class="comment">// previous lhsm is wrong after 'recover'</code>
            <code class="comment">// Include 'e' in the returned expression but throw it away</code>
            <code class="identifier">SynExpr</code>.<code class="identifier">DiscardAfterMissingQualificationAfterDot</code> (<code class="identifier">e</code>, <code class="identifier">fixedLhsm</code>)) }
  | <code class="identifier">LPAREN</code> <code class="identifier">COLON_COLON</code> <code class="identifier">rparen</code> <code class="identifier">DOT</code> <code class="identifier">INT32</code>  
      { (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; 
            <code class="identifier">libraryOnlyError</code>(<code class="identifier">lhs</code> <code class="identifier">parseState</code>)
            <code class="identifier">SynExpr</code>.<code class="identifier">LibraryOnlyUnionCaseFieldGet</code> (<code class="identifier">e</code>, <code class="identifier">mkSynCaseName</code> <code class="identifier">lhsm</code> <code class="identifier">opNameCons</code>, (<code class="identifier">fst</code> $5), <code class="identifier">lhsm</code>)) }

  | <code class="identifier">LPAREN</code>  <code class="identifier">typedSeqExpr</code> <code class="identifier">rparen</code>  
      { (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; 
            <code class="identifier">mlCompatWarning</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsParenFormIsForML</code>()) (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) 
            <code class="identifier">mkSynDotParenGet</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> <code class="identifier">e</code> $2) }

  |   <code class="identifier">LBRACK</code>  <code class="identifier">typedSeqExpr</code> <code class="identifier">RBRACK</code>
      { (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; <code class="identifier">mkSynDotBrackGet</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> <code class="identifier">e</code> $2 <code class="keyword">false</code>) }

  |   <code class="identifier">LBRACK</code>  <code class="identifier">typedSeqExpr</code> <code class="identifier">recover</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBracket</code>()) 
        (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; <code class="identifier">exprFromParseError</code> (<code class="identifier">mkSynDotBrackGet</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> <code class="identifier">e</code> $2 <code class="keyword">false</code>)) }

  | <code class="identifier">LBRACK</code>  <code class="identifier">optRangeSeqExpr</code> <code class="identifier">RBRACK</code>
      { (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; <code class="identifier">mkSynDotBrackSeqSliceGet</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> <code class="identifier">e</code> $2) }
 
  | <code class="identifier">LBRACK</code>  <code class="identifier">optRangeSeqExpr</code> <code class="identifier">recover</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBracket</code>()) 
        (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; <code class="identifier">exprFromParseError</code> (<code class="identifier">mkSynDotBrackSeqSliceGet</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> <code class="identifier">e</code> $2)) }

  | <code class="identifier">LBRACK</code>  <code class="keyword">error</code> <code class="identifier">RBRACK</code>  
      { <code class="keyword">let</code> <code class="identifier">mArg</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; <code class="identifier">mkSynDotBrackGet</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> <code class="identifier">e</code> (<code class="identifier">arbExpr</code>(<code class="string">"indexerExpr1"</code>, <code class="identifier">mArg</code>)) <code class="keyword">false</code>) }

  | <code class="identifier">LBRACK</code>  <code class="identifier">recover</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBracket</code>())
        <code class="keyword">let</code> <code class="identifier">mArg</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1).<code class="identifier">EndRange</code> 
        (<code class="keyword">fun</code> <code class="identifier">e</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> -&gt; <code class="identifier">exprFromParseError</code> (<code class="identifier">mkSynDotBrackGet</code> <code class="identifier">lhsm</code> <code class="identifier">dotm</code> <code class="identifier">e</code> (<code class="identifier">arbExpr</code>(<code class="string">"indexerExpr2"</code>, <code class="identifier">mArg</code>)) <code class="keyword">false</code>)) }

<code class="identifier">optRangeSeqExpr</code>: 

  | <code class="identifier">optRange</code> <code class="identifier">COMMA</code> <code class="identifier">optRangeSeqExpr</code> <code class="keyword">%prec</code> <code class="identifier">slice_comma</code> { $1 :: $3 } 

  | <code class="identifier">optRange</code> { [$1] }

<code class="identifier">optRange</code>:
  | <code class="identifier">rangeDeclExpr</code> <code class="identifier">DOT_DOT</code> <code class="identifier">rangeDeclExpr</code> 
      { <code class="identifier">SynIndexerArg</code>.<code class="identifier">Two</code>(
          <code class="identifier">mkSynOptionalExpr</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">Some</code> (<code class="identifier">fst</code> $1)),
          (<code class="identifier">snd</code> $1),
          <code class="identifier">mkSynOptionalExpr</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">Some</code> (<code class="identifier">fst</code> $3)),
          (<code class="identifier">snd</code> $3),
          (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1),
          (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3)) }

   | <code class="identifier">rangeDeclExpr</code> <code class="identifier">DOT_DOT</code> 
      { <code class="identifier">SynIndexerArg</code>.<code class="identifier">Two</code>(
          <code class="identifier">mkSynOptionalExpr</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">Some</code> (<code class="identifier">fst</code> $1)),
          (<code class="identifier">snd</code> $1),
          <code class="identifier">mkSynOptionalExpr</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) <code class="identifier">None</code>,
          <code class="keyword">false</code>,
          (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1),
          (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)) }

  | <code class="identifier">DOT_DOT</code> <code class="identifier">rangeDeclExpr</code> 
      { <code class="identifier">SynIndexerArg</code>.<code class="identifier">Two</code>(
          <code class="identifier">mkSynOptionalExpr</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">None</code>,
          <code class="keyword">false</code>,
          <code class="identifier">mkSynOptionalExpr</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">Some</code> (<code class="identifier">fst</code> $2)),
          (<code class="identifier">snd</code> $2),
          (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2),
          (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)) }
      
  | <code class="identifier">STAR</code> 
      { <code class="identifier">SynIndexerArg</code>.<code class="identifier">Two</code>(
          <code class="identifier">mkSynOptionalExpr</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">None</code>,
          <code class="keyword">false</code>,
          (<code class="identifier">mkSynOptionalExpr</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">None</code>),
          <code class="keyword">false</code>,
          (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1),
          (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)) }

  | <code class="identifier">rangeDeclExpr</code>
      { <code class="identifier">SynIndexerArg</code>.<code class="identifier">One</code>((<code class="identifier">fst</code> $1), (<code class="identifier">snd</code> $1), (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)) }

<code class="identifier">rangeDeclExpr</code>:
  | <code class="identifier">declExpr</code> <code class="keyword">%prec</code> <code class="identifier">slice_expr</code>
    { $1, <code class="keyword">false</code> }

  | <code class="identifier">INFIX_AT_HAT_OP</code> <code class="identifier">declExpr</code> <code class="keyword">%prec</code> <code class="identifier">slice_expr</code>
    { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">parseState</code>.<code class="identifier">LexBuffer</code>.<code class="identifier">SupportsFeature</code> <code class="identifier">LanguageFeature</code>.<code class="identifier">FromEndSlicing</code>) <code class="keyword">then</code> 
        <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">fromEndSlicingRequiresVFive</code>())
      <code class="keyword">if</code> $1 &lt;&gt; <code class="string">"^"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidPrefixOperator</code>())
      $2, <code class="keyword">true</code> }

<code class="comment">/* the start of atomicExprAfterType must not overlap with the valid postfix tokens of the type syntax, e.g. new List&lt;T&gt;(...) */</code>
<code class="identifier">atomicExprAfterType</code>:
  | <code class="identifier">constant</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">Const</code> (<code class="identifier">fst</code> $1, <code class="identifier">snd</code> $1) }

  | <code class="identifier">parenExpr</code> 
      { $1 }

  | <code class="identifier">braceExpr</code> 
      { $1 }

  | <code class="identifier">braceBarExpr</code> 
      { $1 }

  | <code class="identifier">interpolatedString</code>
      { <code class="keyword">let</code> <code class="identifier">parts</code>, <code class="identifier">synStringKind</code> = $1
        <code class="identifier">SynExpr</code>.<code class="identifier">InterpolatedString</code>(<code class="identifier">parts</code>, <code class="identifier">synStringKind</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) }

  | <code class="identifier">NULL</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">Null</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

  | <code class="identifier">FALSE</code>  
      { <code class="identifier">SynExpr</code>.<code class="identifier">Const</code> (<code class="identifier">SynConst</code>.<code class="identifier">Bool</code> <code class="keyword">false</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

  | <code class="identifier">TRUE</code>  
      { <code class="identifier">SynExpr</code>.<code class="identifier">Const</code> (<code class="identifier">SynConst</code>.<code class="identifier">Bool</code> <code class="keyword">true</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

  | <code class="identifier">quoteExpr</code>
      { $1 }

  | <code class="identifier">arrayExpr</code>
      { $1 }

  | <code class="identifier">beginEndExpr</code>
      { $1 }
  
<code class="identifier">beginEndExpr</code>:
  | <code class="identifier">BEGIN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">END</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">Paren</code> ($2, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, <code class="identifier">Some</code>(<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3), <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) } 

  | <code class="identifier">BEGIN</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">recover</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBegin</code>()); <code class="identifier">exprFromParseError</code> $2 } 

  | <code class="identifier">BEGIN</code> <code class="keyword">error</code> <code class="identifier">END</code> 
      { <code class="comment">(* silent recovery *)</code> <code class="identifier">arbExpr</code>(<code class="string">"beginEndExpr"</code>, (<code class="identifier">lhs</code> <code class="identifier">parseState</code>))  } 

  | <code class="identifier">BEGIN</code> <code class="identifier">END</code> 
      { <code class="identifier">mkSynUnit</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

<code class="identifier">quoteExpr</code>:
  | <code class="identifier">LQUOTE</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">RQUOTE</code> 
      { <code class="keyword">if</code> $1 &lt;&gt; $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMismatchedQuote</code>(<code class="identifier">fst</code> $1))
        (<code class="identifier">SynExpr</code>.<code class="identifier">Quote</code> (<code class="identifier">mkSynIdGet</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) (<code class="identifier">CompileOpName</code> (<code class="identifier">fst</code> $1)), <code class="identifier">snd</code> $1, $2, <code class="keyword">false</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>)) } 

  | <code class="identifier">LQUOTE</code> <code class="identifier">typedSeqExpr</code> <code class="identifier">recover</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatched</code>(<code class="identifier">fst</code> $1))  
        <code class="keyword">let</code> <code class="identifier">mExpr</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">Quote</code> (<code class="identifier">mkSynIdGet</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) (<code class="identifier">CompileOpName</code> (<code class="identifier">fst</code> $1)), <code class="identifier">snd</code> $1, $2, <code class="keyword">false</code>, <code class="identifier">mExpr</code>))  } 

  | <code class="identifier">LQUOTE</code> <code class="keyword">error</code> <code class="identifier">RQUOTE</code> 
      { <code class="comment">(* silent recovery *)</code> <code class="identifier">SynExpr</code>.<code class="identifier">Quote</code> (<code class="identifier">mkSynIdGet</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) (<code class="identifier">CompileOpName</code> (<code class="identifier">fst</code> $1)), <code class="identifier">snd</code> $1, <code class="identifier">arbExpr</code>(<code class="string">"quoteExpr"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)), <code class="keyword">false</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>)  }  

  | <code class="identifier">LQUOTE</code> <code class="identifier">recover</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatched</code>(<code class="identifier">fst</code> $1))
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">Quote</code> (<code class="identifier">mkSynIdGet</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) (<code class="identifier">CompileOpName</code> (<code class="identifier">fst</code> $1)), <code class="identifier">snd</code> $1, <code class="identifier">arbExpr</code>(<code class="string">"quoteExpr2"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1).<code class="identifier">EndRange</code>), <code class="keyword">false</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))  }  

<code class="identifier">arrayExpr</code>:
  | <code class="identifier">LBRACK_BAR</code> <code class="identifier">listExprElements</code> <code class="identifier">BAR_RBRACK</code> 
      {  $2 (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) <code class="keyword">true</code> } 

  | <code class="identifier">LBRACK_BAR</code> <code class="identifier">listExprElements</code> <code class="identifier">recover</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBracketBar</code>()) 
        <code class="identifier">exprFromParseError</code> ($2 (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2) <code class="keyword">true</code>) }

  | <code class="identifier">LBRACK_BAR</code> <code class="keyword">error</code> <code class="identifier">BAR_RBRACK</code> 
      {  <code class="comment">(* silent recovery *)</code> <code class="identifier">SynExpr</code>.<code class="identifier">ArrayOrList</code> (<code class="keyword">true</code>, [ ], <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }  

  | <code class="identifier">LBRACK_BAR</code> <code class="identifier">recover</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBracketBar</code>())  
        <code class="comment">(* silent recovery *)</code> 
        <code class="identifier">exprFromParseError</code> (<code class="identifier">SynExpr</code>.<code class="identifier">ArrayOrList</code> (<code class="keyword">true</code>, [ ], <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)) }  

<code class="identifier">parenExpr</code>:
  | <code class="identifier">LPAREN</code> <code class="identifier">rparen</code> 
      { <code class="identifier">SynExpr</code>.<code class="identifier">Const</code> (<code class="identifier">SynConst</code>.<code class="identifier">Unit</code>, (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2)) } 

  | <code class="identifier">LPAREN</code> <code class="identifier">parenExprBody</code> <code class="identifier">rparen</code>
      { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
        <code class="identifier">SynExpr</code>.<code class="identifier">Paren</code> ($2 <code class="identifier">m</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, <code class="identifier">Some</code>(<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3), <code class="identifier">m</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">parenExprBody</code> <code class="identifier">ends_other_than_rparen_coming_soon_or_recover</code>
      { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>())
        <code class="keyword">let</code> <code class="identifier">lhsm</code> = <code class="identifier">unionRangeWithPos</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2).<code class="identifier">End</code>
        <code class="identifier">SynExpr</code>.<code class="identifier">Paren</code> (<code class="identifier">exprFromParseError</code> ($2 <code class="identifier">lhsm</code>), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1, <code class="identifier">None</code>, <code class="identifier">lhsm</code>) }

  | <code class="identifier">LPAREN</code> <code class="keyword">error</code> <code class="identifier">rparen</code> 
      { <code class="comment">// silent recovery</code>
        <code class="identifier">SynExpr</code>.<code class="identifier">Paren</code> (<code class="identifier">arbExpr</code>(<code class="string">"parenExpr1"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1).<code class="identifier">EndRange</code>), (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">Some</code>(<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3), (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3)) } 

  | <code class="identifier">LPAREN</code> <code class="identifier">TYPE_COMING_SOON</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>())
        <code class="keyword">let</code> <code class="identifier">lhsm</code> = <code class="identifier">unionRangeWithPos</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2).<code class="identifier">Start</code>
        <code class="identifier">arbExpr</code>(<code class="string">"parenExpr2tcs"</code>, <code class="identifier">lhsm</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">MODULE_COMING_SOON</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>())
        <code class="keyword">let</code> <code class="identifier">lhsm</code> = <code class="identifier">unionRangeWithPos</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2).<code class="identifier">Start</code>
        <code class="identifier">arbExpr</code>(<code class="string">"parenExpr2mcs"</code>, <code class="identifier">lhsm</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">RBRACE_COMING_SOON</code>
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>())
        <code class="keyword">let</code> <code class="identifier">lhsm</code> = <code class="identifier">unionRangeWithPos</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2).<code class="identifier">Start</code>
        <code class="identifier">arbExpr</code>(<code class="string">"parenExpr2rbcs"</code>, <code class="identifier">lhsm</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">OBLOCKEND_COMING_SOON</code> 
      { <code class="keyword">let</code> <code class="identifier">lparenRange</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
        <code class="identifier">reportParseErrorAt</code> <code class="identifier">lparenRange</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>())
        <code class="identifier">SynExpr</code>.<code class="identifier">Paren</code>(<code class="identifier">arbExpr</code>(<code class="string">"parenExpr2obecs"</code>, <code class="identifier">lparenRange</code>.<code class="identifier">EndRange</code>), <code class="identifier">lparenRange</code>, <code class="identifier">None</code>, <code class="identifier">lparenRange</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">recover</code> <code class="keyword">%prec</code> <code class="identifier">prec_atomexpr_lparen_error</code> 
      { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>()) 
        <code class="identifier">arbExpr</code>(<code class="string">"parenExpr2"</code>, (<code class="identifier">lhs</code> <code class="identifier">parseState</code>))  }  

        <code class="comment">// This is really what we should be doing, but it fails because param info expects the range of the expression</code>
        <code class="comment">// to extend all the way over the "recover", to the end of the file if necessary</code>
        <code class="comment">// </code>
        <code class="comment">// let mLeftParen = rhs parseState 1</code>
        <code class="comment">//let lhsm = if $2 then unionRangeWithPos mLeftParen (rhs parseState 2).Start else mLeftParen</code>
        <code class="comment">//arbExpr("parenExpr2", lhsm)  }  </code>

<code class="identifier">parenExprBody</code>:
  | <code class="identifier">staticallyKnownHeadTypars</code> <code class="identifier">COLON</code> <code class="identifier">LPAREN</code> <code class="identifier">classMemberSpfn</code> <code class="identifier">rparen</code>  <code class="identifier">typedSeqExpr</code> 
      { (<code class="keyword">fun</code> <code class="identifier">m</code> -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">TraitCall</code> ($1, $4, $6, <code class="identifier">m</code>)) } <code class="comment">/* disambiguate: x $a.id(x) */</code>

  | <code class="identifier">typedSeqExpr</code>
      { (<code class="keyword">fun</code> <code class="identifier">_m</code> -&gt; $1) } 

  | <code class="identifier">inlineAssemblyExpr</code> 
      { $1 }

<code class="identifier">staticallyKnownHeadTypars</code>:
  | <code class="identifier">staticallyKnownHeadTypar</code> 
      { [$1] }

  | <code class="identifier">LPAREN</code> <code class="identifier">staticallyKnownHeadTyparAlts</code> <code class="identifier">rparen</code> 
      { <code class="identifier">List</code>.<code class="identifier">rev</code> $2 }

<code class="identifier">staticallyKnownHeadTyparAlts</code>:
  | <code class="identifier">staticallyKnownHeadTyparAlts</code> <code class="identifier">OR</code> <code class="identifier">staticallyKnownHeadTypar</code>
      {$3 :: $1}

  | <code class="identifier">staticallyKnownHeadTypar</code>
      { [$1] }

<code class="identifier">braceExpr</code>:
  | <code class="identifier">LBRACE</code> <code class="identifier">braceExprBody</code> <code class="identifier">rbrace</code> 
     {  <code class="keyword">let</code> <code class="identifier">m</code>, <code class="identifier">r</code> = $2 <code class="keyword">in</code> <code class="identifier">r</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) }

  | <code class="identifier">LBRACE</code> <code class="identifier">braceExprBody</code> <code class="identifier">recover</code> 
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBrace</code>())  
       <code class="keyword">let</code> <code class="identifier">m</code>, <code class="identifier">r</code> = $2 
       <code class="comment">// Note, we can't use 'exprFromParseError' because the extra syntax node interferes with some syntax-directed transformations for computation expressions</code>
       <code class="identifier">r</code> (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">m</code>) }

  | <code class="identifier">LBRACE</code> <code class="keyword">error</code> <code class="identifier">rbrace</code> 
     { <code class="comment">// silent recovery </code>
       <code class="identifier">arbExpr</code>(<code class="string">"braceExpr"</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3)  }  

  | <code class="identifier">LBRACE</code> <code class="identifier">recover</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBrace</code>())  
       <code class="comment">// Note, we can't use 'exprFromParseError' because the extra syntax node interferes with some syntax-directed transformations for computation expressions</code>
       <code class="identifier">SynExpr</code>.<code class="identifier">Record</code> (<code class="identifier">None</code>, <code class="identifier">None</code>, [], <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) }

  | <code class="identifier">LBRACE</code> <code class="identifier">rbrace</code> 
     {  <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2 
        <code class="identifier">SynExpr</code>.<code class="identifier">Record</code> (<code class="identifier">None</code>, <code class="identifier">None</code>, [], <code class="identifier">m</code>) }

<code class="identifier">braceExprBody</code>:
  | <code class="identifier">recdExpr</code> 
     {  (<code class="identifier">lhs</code> <code class="identifier">parseState</code>), (<code class="keyword">fun</code> <code class="identifier">m</code> -&gt; <code class="keyword">let</code> <code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code> = $1 <code class="keyword">in</code> <code class="identifier">SynExpr</code>.<code class="identifier">Record</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">m</code>)) }

  | <code class="identifier">objExpr</code> 
     { $1 }

  | <code class="identifier">monadicExprInitial</code> 
     { <code class="keyword">let</code> <code class="identifier">m</code>, <code class="identifier">r</code> = $1 <code class="keyword">in</code> (<code class="identifier">m</code>, <code class="identifier">r</code> <code class="keyword">false</code>) }

<code class="identifier">listExprElements</code>: 
  | <code class="identifier">monadicExprInitial</code>
     { <code class="keyword">let</code> <code class="identifier">m</code>, <code class="identifier">r</code> = $1 <code class="keyword">in</code> (<code class="keyword">fun</code> <code class="identifier">lhsm</code> <code class="identifier">isArray</code> -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">ArrayOrListOfSeqExpr</code> (<code class="identifier">isArray</code>, <code class="identifier">r</code> <code class="keyword">true</code> <code class="identifier">m</code>, <code class="identifier">lhsm</code>)) }

  | 
     { (<code class="keyword">fun</code> <code class="identifier">lhsm</code> <code class="identifier">isArray</code> -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">ArrayOrList</code> (<code class="identifier">isArray</code>, [ ], <code class="identifier">lhsm</code>)) }

<code class="identifier">monadicExprInitial</code>: 
  | <code class="identifier">seqExpr</code>
     { $1.<code class="identifier">Range</code>, (<code class="keyword">fun</code> <code class="identifier">isArrayOrList</code> <code class="identifier">lhsm</code> -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">CompExpr</code> (<code class="identifier">isArrayOrList</code>, <code class="identifier">ref</code>(<code class="identifier">isArrayOrList</code>), $1, <code class="identifier">lhsm</code>)) }

  | <code class="identifier">rangeSequenceExpr</code> 
     { $1 }
  
<code class="identifier">rangeSequenceExpr</code>: 
  | <code class="identifier">declExpr</code> <code class="identifier">DOT_DOT</code>  <code class="identifier">declExpr</code>  
     { <code class="keyword">let</code> <code class="identifier">opm</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)
       (<code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code>), (<code class="keyword">fun</code> <code class="identifier">_isArray</code> <code class="identifier">wholem</code> -&gt; 
                                                <code class="comment">// in the case of "{ 1 .. 10 }", we want the range of the expression to include the curlies, that comes from a higher level rule in the grammar,</code>
                                                <code class="comment">// passed down as 'wholem', so patch up that range here</code>
                                                <code class="keyword">match</code> (<code class="identifier">mkSynInfix</code> <code class="identifier">opm</code> $1 <code class="string">".."</code> $3) <code class="keyword">with</code>
                                                | <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">wholem</code>)
                                                | <code class="identifier">_</code> -&gt; <code class="identifier">failwith</code> <code class="string">"impossible"</code>) }

  | <code class="identifier">declExpr</code> <code class="identifier">DOT_DOT</code>  <code class="identifier">declExpr</code> <code class="identifier">DOT_DOT</code> <code class="identifier">declExpr</code>  
     { (<code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $5.<code class="identifier">Range</code>), (<code class="keyword">fun</code> <code class="identifier">_isArray</code> <code class="identifier">wholem</code> -&gt; <code class="identifier">mkSynTrifix</code> <code class="identifier">wholem</code> <code class="string">".. .."</code> $1 $3 $5) }

  | <code class="identifier">declExpr</code> <code class="identifier">DOT_DOT</code> <code class="identifier">recover</code>  
     { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileExpression</code>())
       <code class="keyword">let</code> <code class="identifier">opm</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)
       <code class="keyword">let</code> <code class="identifier">e</code> = <code class="identifier">arbExpr</code>(<code class="string">"rangeSeqError1"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3).<code class="identifier">StartRange</code>)
       (<code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> <code class="identifier">e</code>.<code class="identifier">Range</code>), (<code class="keyword">fun</code> <code class="identifier">_isArray</code> <code class="identifier">wholem</code> -&gt; 
                                                <code class="comment">// in the case of "{ 1 .. 10 }", we want the range of the expression to include the curlies, that comes from a higher level rule in the grammar,</code>
                                                <code class="comment">// passed down as 'wholem', so patch up that range here</code>
                                                <code class="keyword">match</code> (<code class="identifier">mkSynInfix</code> <code class="identifier">opm</code> $1 <code class="string">".."</code> <code class="identifier">e</code>) <code class="keyword">with</code>
                                                | <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">App</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, <code class="identifier">c</code>, <code class="identifier">d</code>, <code class="identifier">wholem</code>)
                                                | <code class="identifier">_</code> -&gt; <code class="identifier">failwith</code> <code class="string">"impossible"</code>) }


<code class="identifier">arrowThenExprR</code>:
  | <code class="identifier">RARROW</code> <code class="identifier">typedSeqExprBlockR</code> 
     { <code class="identifier">SynExpr</code>.<code class="identifier">YieldOrReturn</code> ((<code class="keyword">true</code>, <code class="keyword">false</code>), $2, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) }


<code class="identifier">forLoopBinder</code>: 
  | <code class="identifier">parenPattern</code> <code class="identifier">IN</code> <code class="identifier">declExpr</code> 
     { ($1, $3, <code class="keyword">true</code>) }

  | <code class="identifier">parenPattern</code> <code class="identifier">IN</code> <code class="identifier">rangeSequenceExpr</code> 
     { <code class="keyword">let</code> <code class="identifier">m</code>, <code class="identifier">r</code> = $3 <code class="keyword">in</code> ($1, <code class="identifier">r</code> <code class="keyword">false</code> <code class="identifier">m</code>, <code class="keyword">true</code>) }

  | <code class="identifier">parenPattern</code> <code class="identifier">IN</code> <code class="identifier">ends_coming_soon_or_recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsExpectedExpressionAfterToken</code>())
       ($1, <code class="identifier">arbExpr</code>(<code class="string">"forLoopBinder"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)), <code class="keyword">false</code>) }

  | <code class="identifier">parenPattern</code> <code class="identifier">ends_coming_soon_or_recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $2 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInOrEqualExpected</code>())
       ($1, <code class="identifier">arbExpr</code>(<code class="string">"forLoopBinder2"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1).<code class="identifier">EndRange</code>), <code class="keyword">false</code>) }

<code class="identifier">forLoopRange</code>: 
  | <code class="identifier">parenPattern</code> <code class="identifier">EQUALS</code> <code class="identifier">declExpr</code> <code class="identifier">forLoopDirection</code> <code class="identifier">declExpr</code> 
      { <code class="identifier">idOfPat</code> <code class="identifier">parseState</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $1, $3, $4, $5 }

  | <code class="identifier">parenPattern</code> <code class="identifier">EQUALS</code> <code class="identifier">rangeSequenceExpr</code>
     { <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedSymbolEqualsInsteadOfIn</code>()) }

<code class="identifier">forLoopDirection</code>: 
  | <code class="identifier">TO</code>     { <code class="keyword">true</code> } 

  | <code class="identifier">DOWNTO</code> { <code class="keyword">false</code> }

<code class="identifier">inlineAssemblyExpr</code>:
  | <code class="identifier">HASH</code> <code class="identifier">stringOrKeywordString</code> <code class="identifier">opt_inlineAssemblyTypeArg</code> <code class="identifier">optCurriedArgExprs</code>  <code class="identifier">optInlineAssemblyReturnTypes</code> <code class="identifier">HASH</code> 
      { <code class="identifier">libraryOnlyWarning</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>)
        <code class="keyword">let</code> (<code class="identifier">s</code>, <code class="identifier">_</code>), <code class="identifier">sm</code> = $2, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2
        (<code class="keyword">fun</code> <code class="identifier">m</code> -&gt;
            <code class="keyword">let</code> <code class="identifier">ilInstrs</code> = <code class="identifier">ParseAssemblyCodeInstructions</code> <code class="identifier">s</code> <code class="identifier">parseState</code>.<code class="identifier">LexBuffer</code>.<code class="identifier">SupportsFeature</code> <code class="identifier">sm</code>
            <code class="identifier">SynExpr</code>.<code class="identifier">LibraryOnlyILAssembly</code> (<code class="identifier">box</code> <code class="identifier">ilInstrs</code>, $3, <code class="identifier">List</code>.<code class="identifier">rev</code> $4, $5, <code class="identifier">m</code>)) }

<code class="identifier">optCurriedArgExprs</code>:
  | <code class="identifier">optCurriedArgExprs</code> <code class="identifier">argExpr</code>  <code class="keyword">%prec</code> <code class="identifier">expr_args</code>
      { $2 :: $1 }

  | <code class="comment">/* EMPTY */</code>
      { [] }

<code class="identifier">opt_atomicExprAfterType</code>: 
  | <code class="comment">/* EMPTY */</code>
      { <code class="identifier">None</code> }

  | <code class="identifier">atomicExprAfterType</code> 
      { <code class="identifier">Some</code>($1) }

<code class="identifier">opt_inlineAssemblyTypeArg</code>:
  | <code class="comment">/* EMPTY */</code>
      { [] }

  | <code class="identifier">typeKeyword</code> <code class="identifier">LPAREN</code> <code class="identifier">typ</code> <code class="identifier">rparen</code>
      {  [$3] }

<code class="identifier">optInlineAssemblyReturnTypes</code>:
  | <code class="comment">/* EMPTY */</code>
     { [] }

  | <code class="identifier">COLON</code> <code class="identifier">typ</code> 
     { [$2] }

  | <code class="identifier">COLON</code> <code class="identifier">LPAREN</code> <code class="identifier">rparen</code>  
     {  [] }

<code class="identifier">recdExpr</code>:
  | <code class="identifier">INHERIT</code> <code class="identifier">atomTypeNonAtomicDeprecated</code> <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="identifier">opt_atomicExprAfterType</code> <code class="identifier">recdExprBindings</code> <code class="identifier">opt_seps_recd</code>
     { <code class="keyword">let</code> <code class="identifier">arg</code> = <code class="keyword">match</code> $4 <code class="keyword">with</code> <code class="identifier">None</code> -&gt; <code class="identifier">mkSynUnit</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) | <code class="identifier">Some</code> <code class="identifier">e</code> -&gt; <code class="identifier">e</code> 
       <code class="keyword">let</code> <code class="identifier">l</code> = <code class="identifier">List</code>.<code class="identifier">rev</code> $5
       <code class="keyword">let</code> <code class="identifier">dummyField</code> = <code class="identifier">mkRecdField</code> (<code class="identifier">LongIdentWithDots</code>([], [])) <code class="comment">// dummy identifier, it will be discarded</code>
       <code class="keyword">let</code> <code class="identifier">l</code> = <code class="identifier">rebindRanges</code> (<code class="identifier">dummyField</code>, <code class="identifier">None</code>) <code class="identifier">l</code> $6 
       <code class="keyword">let</code> (<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">inheritsSep</code>) = <code class="identifier">List</code>.<code class="identifier">head</code> <code class="identifier">l</code>
       <code class="keyword">let</code> <code class="identifier">bindings</code> = <code class="identifier">List</code>.<code class="identifier">tail</code> <code class="identifier">l</code>
       (<code class="identifier">Some</code> ($2, <code class="identifier">arg</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 2 4, <code class="identifier">inheritsSep</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">None</code>, <code class="identifier">bindings</code>) }

  | <code class="identifier">recdExprCore</code>
    { <code class="keyword">let</code> <code class="identifier">a</code>, <code class="identifier">b</code> = $1 <code class="keyword">in</code> (<code class="identifier">None</code>, <code class="identifier">a</code>, <code class="identifier">b</code>) }

<code class="identifier">recdExprCore</code>:
  | <code class="identifier">appExpr</code> <code class="identifier">EQUALS</code> <code class="identifier">declExprBlock</code> <code class="identifier">recdExprBindings</code> <code class="identifier">opt_seps_recd</code>
     { <code class="keyword">match</code> $1 <code class="keyword">with</code> 
       | <code class="identifier">LongOrSingleIdent</code>(<code class="keyword">false</code>, (<code class="identifier">LongIdentWithDots</code>(<code class="identifier">_</code>, <code class="identifier">_</code>) <code class="keyword">as</code> <code class="identifier">f</code>), <code class="identifier">None</code>, <code class="identifier">m</code>) -&gt;  
            <code class="keyword">let</code> <code class="identifier">f</code> = <code class="identifier">mkRecdField</code> <code class="identifier">f</code>
            <code class="keyword">let</code> <code class="identifier">l</code> = <code class="identifier">List</code>.<code class="identifier">rev</code> $4
            <code class="keyword">let</code> <code class="identifier">l</code> = <code class="identifier">rebindRanges</code> (<code class="identifier">f</code>, <code class="identifier">Some</code> $3) <code class="identifier">l</code> $5
            (<code class="identifier">None</code>, <code class="identifier">l</code>)
       | <code class="identifier">_</code> -&gt; <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsFieldBinding</code>()) }

<code class="comment">/*
    handles cases when identifier can start from the underscore
*/</code>

  | <code class="identifier">UNDERSCORE</code>
    { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
      <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnderscoreInvalidFieldName</code>())
      <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsFieldBinding</code>())
      <code class="keyword">let</code> <code class="identifier">f</code> = <code class="identifier">mkUnderscoreRecdField</code> <code class="identifier">m</code>
      (<code class="identifier">None</code>, [ (<code class="identifier">f</code>, <code class="identifier">None</code>, <code class="identifier">None</code>)  ]) }

  | <code class="identifier">UNDERSCORE</code> <code class="identifier">EQUALS</code>
    { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
      <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnderscoreInvalidFieldName</code>())      
      <code class="keyword">let</code> <code class="identifier">f</code> = <code class="identifier">mkUnderscoreRecdField</code> <code class="identifier">m</code>

      <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsFieldBinding</code>())
      
      (<code class="identifier">None</code>, [ (<code class="identifier">f</code>, <code class="identifier">None</code>, <code class="identifier">None</code>) ]) }

  | <code class="identifier">UNDERSCORE</code> <code class="identifier">EQUALS</code> <code class="identifier">declExprBlock</code> <code class="identifier">recdExprBindings</code> <code class="identifier">opt_seps_recd</code>
    { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnderscoreInvalidFieldName</code>())
      <code class="keyword">let</code> <code class="identifier">f</code> = <code class="identifier">mkUnderscoreRecdField</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
      <code class="keyword">let</code> <code class="identifier">l</code> = <code class="identifier">List</code>.<code class="identifier">rev</code> $4
      <code class="keyword">let</code> <code class="identifier">l</code> = <code class="identifier">rebindRanges</code> (<code class="identifier">f</code>, <code class="identifier">Some</code> $3) <code class="identifier">l</code> $5
      (<code class="identifier">None</code>, <code class="identifier">l</code>) }

<code class="comment">/* handles case like {x with}  */</code>
  | <code class="identifier">appExpr</code> <code class="identifier">WITH</code> <code class="identifier">recdBinding</code> <code class="identifier">recdExprBindings</code> <code class="identifier">opt_seps_recd</code>
     {  <code class="keyword">let</code> <code class="identifier">l</code> = <code class="identifier">List</code>.<code class="identifier">rev</code> $4
        <code class="keyword">let</code> <code class="identifier">l</code> = <code class="identifier">rebindRanges</code> $3 <code class="identifier">l</code> $5
        (<code class="identifier">Some</code> ($1, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2, <code class="identifier">None</code>)), <code class="identifier">l</code>) }

  | <code class="identifier">appExpr</code> <code class="identifier">OWITH</code> <code class="identifier">opt_seps_recd</code> <code class="identifier">OEND</code>
     { (<code class="identifier">Some</code> ($1, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2, <code class="identifier">None</code>)), []) }

  | <code class="identifier">appExpr</code> <code class="identifier">OWITH</code> <code class="identifier">recdBinding</code> <code class="identifier">recdExprBindings</code> <code class="identifier">opt_seps_recd</code> <code class="identifier">OEND</code>
     {  <code class="keyword">let</code> <code class="identifier">l</code> = <code class="identifier">List</code>.<code class="identifier">rev</code> $4
        <code class="keyword">let</code> <code class="identifier">l</code> = <code class="identifier">rebindRanges</code> $3 <code class="identifier">l</code> $5
        (<code class="identifier">Some</code> ($1, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2, <code class="identifier">None</code>)), <code class="identifier">l</code>) }

<code class="identifier">opt_seps_recd</code>:
  | <code class="identifier">seps_recd</code>
     { <code class="identifier">Some</code> $1 }

  | <code class="comment">/* EMPTY */</code>
     { <code class="identifier">None</code> }

<code class="identifier">seps_recd</code>:
  | <code class="identifier">OBLOCKSEP</code>
     { (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">None</code> }

  | <code class="identifier">SEMICOLON</code>
     { <code class="keyword">let</code> <code class="identifier">m</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="keyword">in</code> (<code class="identifier">m</code>, <code class="identifier">Some</code> <code class="identifier">m</code>.<code class="identifier">End</code>) }

  | <code class="identifier">SEMICOLON</code> <code class="identifier">OBLOCKSEP</code>
     { (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2), <code class="identifier">Some</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1).<code class="identifier">End</code> }

  | <code class="identifier">OBLOCKSEP</code> <code class="identifier">SEMICOLON</code>
     { (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2), <code class="identifier">Some</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2).<code class="identifier">End</code> }


<code class="comment">/* identifier can start from the underscore */</code>
<code class="identifier">pathOrUnderscore</code> :
  | <code class="identifier">path</code>
    { <code class="identifier">mkRecdField</code> $1 }

  | <code class="identifier">UNDERSCORE</code> 
    { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
      <code class="identifier">reportParseErrorAt</code> <code class="identifier">m</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnderscoreInvalidFieldName</code>())
      <code class="identifier">mkUnderscoreRecdField</code> <code class="identifier">m</code> }

<code class="identifier">recdExprBindings</code>: 
  | <code class="identifier">recdExprBindings</code> <code class="identifier">seps_recd</code> <code class="identifier">recdBinding</code>
     { ($3, <code class="identifier">Some</code> $2) :: $1 }

  | <code class="comment">/* EMPTY */</code>
     { [] }

<code class="identifier">recdBinding</code>:
  | <code class="identifier">pathOrUnderscore</code> <code class="identifier">EQUALS</code> <code class="identifier">declExprBlock</code>
     { ($1, <code class="identifier">Some</code> $3) }

  | <code class="identifier">pathOrUnderscore</code> <code class="identifier">EQUALS</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsFieldBinding</code>())
       ($1, <code class="identifier">None</code>) }

  | <code class="identifier">pathOrUnderscore</code> <code class="identifier">EQUALS</code> <code class="identifier">ends_coming_soon_or_recover</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsFieldBinding</code>())
       ($1, <code class="identifier">None</code>) }

  | <code class="identifier">pathOrUnderscore</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsFieldBinding</code>())
       ($1, <code class="identifier">None</code>) }

  | <code class="identifier">pathOrUnderscore</code> <code class="identifier">ends_coming_soon_or_recover</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsFieldBinding</code>())
       ($1, <code class="identifier">None</code>) }

<code class="comment">/* There is a minor conflict between
       seq { new ty() }  // sequence expression with one very odd 'action' expression
  and 
       { new ty() }   // object expression with no interfaces and no overrides
Hence we make sure the latter is not permitted by the grammar
*/</code>
<code class="identifier">objExpr</code>:
  | <code class="identifier">objExprBaseCall</code> <code class="identifier">objExprBindings</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="identifier">opt_objExprInterfaces</code>
     { <code class="keyword">let</code> <code class="identifier">mNewExpr</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       <code class="keyword">let</code> <code class="identifier">fullRange</code> = <code class="keyword">match</code> $4 <code class="keyword">with</code> [] -&gt; (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) | <code class="identifier">_</code> -&gt; (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 4)
       <code class="identifier">fullRange</code>, (<code class="keyword">fun</code> <code class="identifier">m</code> -&gt; <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>) = $1 <code class="keyword">in</code> <code class="identifier">SynExpr</code>.<code class="identifier">ObjExpr</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, $2, $4, <code class="identifier">mNewExpr</code>, <code class="identifier">m</code>)) }

  | <code class="identifier">objExprBaseCall</code> <code class="identifier">opt_OBLOCKSEP</code> <code class="identifier">objExprInterfaces</code>
     { <code class="keyword">let</code> <code class="identifier">mNewExpr</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
       <code class="keyword">let</code> <code class="identifier">fullRange</code> = <code class="keyword">match</code> $3 <code class="keyword">with</code> [] -&gt; (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) | <code class="identifier">_</code> -&gt; (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3)
       <code class="identifier">fullRange</code>, (<code class="keyword">fun</code> <code class="identifier">m</code> -&gt; <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>) = $1 <code class="keyword">in</code> <code class="identifier">SynExpr</code>.<code class="identifier">ObjExpr</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, [], $3, <code class="identifier">mNewExpr</code>, <code class="identifier">m</code>)) }

  | <code class="identifier">NEW</code> <code class="identifier">atomTypeNonAtomicDeprecated</code>
     { <code class="keyword">let</code> <code class="identifier">mNewExpr</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1 
       (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2), (<code class="keyword">fun</code> <code class="identifier">m</code> -&gt; <code class="keyword">let</code> (<code class="identifier">a</code>, <code class="identifier">b</code>) = $2, <code class="identifier">None</code> <code class="keyword">in</code> <code class="identifier">SynExpr</code>.<code class="identifier">ObjExpr</code> (<code class="identifier">a</code>, <code class="identifier">b</code>, [], [], <code class="identifier">mNewExpr</code>, <code class="identifier">m</code>)) }

<code class="identifier">objExprBaseCall</code>:
  | <code class="identifier">NEW</code> <code class="identifier">atomTypeNonAtomicDeprecated</code>  <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="identifier">atomicExprAfterType</code> <code class="identifier">baseSpec</code>
     { ($2, <code class="identifier">Some</code>($4, <code class="identifier">Some</code>($5))) }

  | <code class="identifier">NEW</code> <code class="identifier">atomTypeNonAtomicDeprecated</code>  <code class="identifier">opt_HIGH_PRECEDENCE_APP</code> <code class="identifier">atomicExprAfterType</code> 
     { ($2, <code class="identifier">Some</code>($4, <code class="identifier">None</code>)) }

  | <code class="identifier">NEW</code> <code class="identifier">atomTypeNonAtomicDeprecated</code>
     { $2, <code class="identifier">None</code> }
 


<code class="identifier">opt_objExprBindings</code>: 
  | <code class="identifier">objExprBindings</code>
     { $1 }

  | <code class="comment">/* EMPTY */</code>
     { [] }

<code class="identifier">objExprBindings</code>: 
  | <code class="identifier">WITH</code> <code class="identifier">localBindings</code> 
      { <code class="keyword">let</code> <code class="identifier">mWithKwd</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
        <code class="keyword">let</code> <code class="identifier">_localBindingsLastRange</code>, <code class="identifier">localBindingsBuilder</code> = $2 
        <code class="identifier">localBindingsBuilder</code> [] <code class="identifier">None</code> <code class="identifier">mWithKwd</code> }

  | <code class="identifier">OWITH</code> <code class="identifier">localBindings</code> <code class="identifier">OEND</code>
      { <code class="keyword">let</code> <code class="identifier">mWithKwd</code> = (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)
        <code class="keyword">let</code> <code class="identifier">_localBindingsLastRange</code>, <code class="identifier">localBindingsBuilder</code> = $2 
        <code class="identifier">localBindingsBuilder</code> [] <code class="identifier">None</code> <code class="identifier">mWithKwd</code> }

  | <code class="identifier">WITH</code> <code class="identifier">objectImplementationBlock</code> <code class="identifier">opt_declEnd</code>
      { $2 |&gt; 
        (<code class="identifier">List</code>.<code class="identifier">choose</code> (<code class="keyword">function</code> 
                          | <code class="identifier">SynMemberDefn</code>.<code class="identifier">Member</code>(<code class="identifier">b</code>, <code class="identifier">m</code>) -&gt; <code class="identifier">Some</code> <code class="identifier">b</code>
                          | <code class="identifier">SynMemberDefn</code>.<code class="identifier">AutoProperty</code>(<code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">_</code>, <code class="identifier">m</code>) -&gt; <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsIllegalMemberVarInObjectImplementation</code>(), <code class="identifier">m</code>)); <code class="identifier">None</code>
                          | <code class="identifier">x</code> -&gt; <code class="identifier">errorR</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMemberIllegalInObjectImplementation</code>(), <code class="identifier">x</code>.<code class="identifier">Range</code>)); <code class="identifier">None</code>)) }

<code class="identifier">objExprInterfaces</code>:
  | <code class="identifier">objExprInterface</code> <code class="identifier">opt_objExprInterfaces</code> { $1 :: $2 }

<code class="identifier">opt_objExprInterfaces</code>:
  | <code class="keyword">%prec</code> <code class="identifier">prec_interfaces_prefix</code> 
     { [] }

  | <code class="identifier">objExprInterface</code> <code class="identifier">opt_objExprInterfaces</code> 
     { $1 :: $2 }

  | <code class="keyword">error</code> <code class="identifier">opt_objExprInterfaces</code> 
     { <code class="comment">(* silent recovery *)</code> $2 }

<code class="identifier">objExprInterface</code>:
  | <code class="identifier">interfaceMember</code> <code class="identifier">appType</code> <code class="identifier">opt_objExprBindings</code> <code class="identifier">opt_declEnd</code> <code class="identifier">opt_OBLOCKSEP</code>
    { <code class="identifier">SynInterfaceImpl</code>($2, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

<code class="identifier">braceBarExpr</code>:
  | <code class="identifier">STRUCT</code> <code class="identifier">braceBarExprCore</code>
      { $2 <code class="keyword">true</code> }

  | <code class="identifier">braceBarExprCore</code>
      { $1 <code class="keyword">false</code> }

<code class="identifier">braceBarExprCore</code>:
  | <code class="identifier">LBRACE_BAR</code> <code class="identifier">recdExprCore</code> <code class="identifier">bar_rbrace</code>
     { <code class="keyword">let</code> <code class="identifier">orig</code>, <code class="identifier">flds</code> = $2
       <code class="keyword">let</code> <code class="identifier">flds</code> = 
           <code class="identifier">flds</code> |&gt; <code class="identifier">List</code>.<code class="identifier">choose</code> (<code class="keyword">function</code> 
             | ((<code class="identifier">LongIdentWithDots</code>([<code class="identifier">id</code>], <code class="identifier">_</code>), <code class="identifier">_</code>), <code class="identifier">Some</code> <code class="identifier">e</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">Some</code> (<code class="identifier">id</code>, <code class="identifier">e</code>) 
             | ((<code class="identifier">LongIdentWithDots</code>([<code class="identifier">id</code>], <code class="identifier">_</code>), <code class="identifier">_</code>), <code class="identifier">None</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">Some</code> (<code class="identifier">id</code>, <code class="identifier">arbExpr</code>(<code class="string">"anonField"</code>, <code class="identifier">id</code>.<code class="identifier">idRange</code>)) 
             | <code class="identifier">_</code> -&gt; <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidAnonRecdType</code>()); <code class="identifier">None</code>) 
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
       (<code class="keyword">fun</code> <code class="identifier">isStruct</code> -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">AnonRecd</code> (<code class="identifier">isStruct</code>, <code class="identifier">orig</code>, <code class="identifier">flds</code>, <code class="identifier">m</code>)) }

  | <code class="identifier">LBRACE_BAR</code> <code class="identifier">recdExprCore</code> <code class="identifier">recover</code> 
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBraceBar</code>())  
       <code class="keyword">let</code> <code class="identifier">orig</code>, <code class="identifier">flds</code> = $2 
       <code class="keyword">let</code> <code class="identifier">flds</code> = 
           <code class="identifier">flds</code> |&gt; <code class="identifier">List</code>.<code class="identifier">choose</code> (<code class="keyword">function</code> 
             | ((<code class="identifier">LongIdentWithDots</code>([<code class="identifier">id</code>], <code class="identifier">_</code>), <code class="identifier">_</code>), <code class="identifier">Some</code> <code class="identifier">e</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">Some</code> (<code class="identifier">id</code>, <code class="identifier">e</code>) 
             | ((<code class="identifier">LongIdentWithDots</code>([<code class="identifier">id</code>], <code class="identifier">_</code>), <code class="identifier">_</code>), <code class="identifier">None</code>, <code class="identifier">_</code>) -&gt; <code class="identifier">Some</code> (<code class="identifier">id</code>, <code class="identifier">arbExpr</code>(<code class="string">"anonField"</code>, <code class="identifier">id</code>.<code class="identifier">idRange</code>)) 
             | <code class="identifier">_</code> -&gt; <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidAnonRecdType</code>()); <code class="identifier">None</code>) 
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2
       (<code class="keyword">fun</code> <code class="identifier">isStruct</code> -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">AnonRecd</code> (<code class="identifier">isStruct</code>, <code class="identifier">orig</code>, <code class="identifier">flds</code>, <code class="identifier">m</code>)) }

  | <code class="identifier">LBRACE_BAR</code> <code class="keyword">error</code> <code class="identifier">bar_rbrace</code>
     { <code class="comment">// silent recovery </code>
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
       (<code class="keyword">fun</code> <code class="identifier">_</code> -&gt; <code class="identifier">arbExpr</code>(<code class="string">"braceBarExpr"</code>, <code class="identifier">m</code>)) }  

  | <code class="identifier">LBRACE_BAR</code> <code class="identifier">recover</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedBraceBar</code>())  
       <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 1
       (<code class="keyword">fun</code> <code class="identifier">isStruct</code> -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">AnonRecd</code> (<code class="identifier">isStruct</code>, <code class="identifier">None</code>, [], <code class="identifier">m</code>)) }

  | <code class="identifier">LBRACE_BAR</code> <code class="identifier">bar_rbrace</code> 
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2
       (<code class="keyword">fun</code> <code class="identifier">isStruct</code> -&gt; <code class="identifier">SynExpr</code>.<code class="identifier">AnonRecd</code> (<code class="identifier">isStruct</code>, <code class="identifier">None</code>, [], <code class="identifier">m</code>)) }

<code class="identifier">anonLambdaExpr</code>: 
  | <code class="identifier">FUN</code> <code class="identifier">atomicPatterns</code> <code class="identifier">RARROW</code> <code class="identifier">typedSeqExprBlock</code> 
     { <code class="keyword">let</code> <code class="identifier">mAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>
       <code class="identifier">mkSynFunMatchLambdas</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="keyword">false</code> <code class="identifier">mAll</code> $2 $4 }

  | <code class="identifier">FUN</code> <code class="identifier">atomicPatterns</code> <code class="identifier">RARROW</code> <code class="keyword">error</code>
     { <code class="keyword">let</code> <code class="identifier">mAll</code> = <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3
       <code class="identifier">mkSynFunMatchLambdas</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="keyword">false</code> <code class="identifier">mAll</code> $2 (<code class="identifier">arbExpr</code>(<code class="string">"anonLambdaExpr1"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 4))) }

  | <code class="identifier">OFUN</code> <code class="identifier">atomicPatterns</code> <code class="identifier">RARROW</code> <code class="identifier">typedSeqExprBlockR</code> <code class="identifier">OEND</code>
     { <code class="keyword">let</code> <code class="identifier">mAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>
       <code class="identifier">mkSynFunMatchLambdas</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="keyword">false</code> <code class="identifier">mAll</code> $2 $4 }

  | <code class="identifier">OFUN</code> <code class="identifier">atomicPatterns</code> <code class="identifier">RARROW</code> <code class="identifier">typedSeqExprBlockR</code> <code class="identifier">recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $5 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileFunBody</code>());
       <code class="keyword">let</code> <code class="identifier">mAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>
       <code class="identifier">exprFromParseError</code> (<code class="identifier">mkSynFunMatchLambdas</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="keyword">false</code> <code class="identifier">mAll</code> $2 $4) }

  | <code class="identifier">OFUN</code> <code class="identifier">atomicPatterns</code> <code class="identifier">RARROW</code> <code class="identifier">ORIGHT_BLOCK_END</code> <code class="identifier">OEND</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMissingFunctionBody</code>())
       <code class="identifier">mkSynFunMatchLambdas</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="keyword">false</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) $2 (<code class="identifier">arbExpr</code>(<code class="string">"anonLambdaExpr2"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 4))) }

  | <code class="identifier">OFUN</code> <code class="identifier">atomicPatterns</code> <code class="identifier">RARROW</code> <code class="identifier">recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $4 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileFunBody</code>())
       <code class="identifier">exprFromParseError</code> (<code class="identifier">mkSynFunMatchLambdas</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="keyword">false</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 3) $2 (<code class="identifier">arbExpr</code>(<code class="string">"anonLambdaExpr3"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 4)))) }

  | <code class="identifier">OFUN</code> <code class="identifier">atomicPatterns</code> <code class="keyword">error</code> <code class="identifier">OEND</code>
     { <code class="identifier">exprFromParseError</code> (<code class="identifier">mkSynFunMatchLambdas</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="keyword">false</code> (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2) $2 (<code class="identifier">arbExpr</code>(<code class="string">"anonLambdaExpr4"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3)))) }

  | <code class="identifier">OFUN</code> <code class="keyword">error</code> <code class="identifier">OEND</code>
     { <code class="identifier">exprFromParseError</code> (<code class="identifier">mkSynFunMatchLambdas</code> <code class="identifier">parseState</code>.<code class="identifier">SynArgNameGenerator</code> <code class="keyword">false</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) [] (<code class="identifier">arbExpr</code>(<code class="string">"anonLambdaExpr5"</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)))) }

<code class="identifier">anonMatchingExpr</code>: 
  | <code class="identifier">FUNCTION</code> <code class="identifier">withPatternClauses</code> <code class="keyword">%prec</code> <code class="identifier">expr_function</code>
     { <code class="keyword">let</code> <code class="identifier">clauses</code>, <code class="identifier">mLast</code> = $2
       <code class="keyword">let</code> <code class="identifier">mAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">mLast</code>
       <code class="identifier">SynExpr</code>.<code class="identifier">MatchLambda</code> (<code class="keyword">false</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">clauses</code>, <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtInvisible</code>, <code class="identifier">mAll</code>) }

  | <code class="identifier">OFUNCTION</code> <code class="identifier">withPatternClauses</code> <code class="identifier">OEND</code> <code class="keyword">%prec</code> <code class="identifier">expr_function</code>
     { <code class="keyword">let</code> <code class="identifier">clauses</code>, <code class="identifier">mLast</code> = $2
       <code class="keyword">let</code> <code class="identifier">mAll</code> = <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">mLast</code>
       <code class="identifier">SynExpr</code>.<code class="identifier">MatchLambda</code> (<code class="keyword">false</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">clauses</code>, <code class="identifier">DebugPointAtBinding</code>.<code class="identifier">NoneAtInvisible</code>, <code class="identifier">mAll</code>) }

<code class="comment">/*--------------------------------------------------------------------------*/</code>
<code class="comment">/* TYPE ALGEBRA                                                             */</code>

<code class="identifier">typeWithTypeConstraints</code>:
  | <code class="identifier">typ</code> <code class="keyword">%prec</code> <code class="identifier">prec_wheretyp_prefix</code> 
     { $1 }

  | <code class="identifier">typ</code> <code class="identifier">WHEN</code> <code class="identifier">typeConstraints</code> 
     { <code class="identifier">SynType</code>.<code class="identifier">WithGlobalConstraints</code>($1, <code class="identifier">List</code>.<code class="identifier">rev</code> $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

<code class="identifier">topTypeWithTypeConstraints</code>: 
  | <code class="identifier">topType</code> 
     { $1 }

  | <code class="identifier">topType</code> <code class="identifier">WHEN</code> <code class="identifier">typeConstraints</code> 
     { <code class="keyword">let</code> <code class="identifier">ty</code>, <code class="identifier">arity</code> = $1 
       <code class="comment">// nb. it doesn't matter where the constraints go in the structure of the type. </code>
       <code class="identifier">SynType</code>.<code class="identifier">WithGlobalConstraints</code>(<code class="identifier">ty</code>, <code class="identifier">List</code>.<code class="identifier">rev</code> $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>), <code class="identifier">arity</code> }

<code class="identifier">opt_topReturnTypeWithTypeConstraints</code>: 
  |             
     { <code class="identifier">None</code> } 

  | <code class="identifier">COLON</code> <code class="identifier">topTypeWithTypeConstraints</code> 
     { <code class="keyword">let</code> <code class="identifier">ty</code>, <code class="identifier">arity</code> = $2 
       <code class="keyword">let</code> <code class="identifier">arity</code> = (<code class="keyword">match</code> <code class="identifier">arity</code> <code class="keyword">with</code> <code class="identifier">SynValInfo</code>([], <code class="identifier">rmdata</code>)-&gt; <code class="identifier">rmdata</code> | <code class="identifier">_</code> -&gt; <code class="identifier">SynInfo</code>.<code class="identifier">unnamedRetVal</code>)
       <code class="identifier">Some</code> (<code class="identifier">SynReturnInfo</code>((<code class="identifier">ty</code>, <code class="identifier">arity</code>), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)) }

<code class="identifier">topType</code>: 
  | <code class="identifier">topTupleType</code> <code class="identifier">RARROW</code> <code class="identifier">topType</code> 
     { <code class="keyword">let</code> <code class="identifier">dty</code>, <code class="identifier">dmdata</code>= $1 
       <code class="keyword">let</code> <code class="identifier">rty</code>, (<code class="identifier">SynValInfo</code>(<code class="identifier">dmdatas</code>, <code class="identifier">rmdata</code>)) = $3 
       <code class="identifier">SynType</code>.<code class="identifier">Fun</code>(<code class="identifier">dty</code>, <code class="identifier">rty</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>), (<code class="identifier">SynValInfo</code>(<code class="identifier">dmdata</code> :: <code class="identifier">dmdatas</code>, <code class="identifier">rmdata</code>)) }

  | <code class="identifier">topTupleType</code> 
     { <code class="keyword">let</code> <code class="identifier">ty</code>, <code class="identifier">rmdata</code> = $1 <code class="keyword">in</code> <code class="identifier">ty</code>, (<code class="identifier">SynValInfo</code>([], (<code class="keyword">match</code> <code class="identifier">rmdata</code> <code class="keyword">with</code> [<code class="identifier">md</code>] -&gt; <code class="identifier">md</code> | <code class="identifier">_</code> -&gt; <code class="identifier">SynInfo</code>.<code class="identifier">unnamedRetVal</code>))) }

<code class="identifier">topTupleType</code>:
  | <code class="identifier">topAppType</code> <code class="identifier">STAR</code> <code class="identifier">topTupleTypeElements</code> 
     { <code class="keyword">let</code> <code class="identifier">ty</code>, <code class="identifier">mdata</code> = $1 <code class="keyword">in</code> <code class="keyword">let</code> <code class="identifier">tys</code>, <code class="identifier">mdatas</code> = <code class="identifier">List</code>.<code class="identifier">unzip</code> $3 <code class="keyword">in</code> (<code class="identifier">SynType</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, <code class="identifier">List</code>.<code class="identifier">map</code> (<code class="keyword">fun</code> <code class="identifier">ty</code> -&gt; (<code class="keyword">false</code>, <code class="identifier">ty</code>)) (<code class="identifier">ty</code> :: <code class="identifier">tys</code>), <code class="identifier">lhs</code> <code class="identifier">parseState</code>)), (<code class="identifier">mdata</code> :: <code class="identifier">mdatas</code>) }

  | <code class="identifier">topAppType</code>                 
     { <code class="keyword">let</code> <code class="identifier">ty</code>, <code class="identifier">mdata</code> = $1 <code class="keyword">in</code> <code class="identifier">ty</code>, [<code class="identifier">mdata</code>] }

<code class="identifier">topTupleTypeElements</code>:
  | <code class="identifier">topAppType</code> <code class="identifier">STAR</code> <code class="identifier">topTupleTypeElements</code>       
     { $1 :: $3 }

  | <code class="identifier">topAppType</code> <code class="keyword">%prec</code> <code class="identifier">prec_toptuptyptail_prefix</code> 
     { [$1] }

<code class="identifier">topAppType</code>:
  | <code class="identifier">attributes</code> <code class="identifier">appType</code> <code class="identifier">COLON</code> <code class="identifier">appType</code> 
     { <code class="keyword">match</code> $2 <code class="keyword">with</code> 
       | <code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>(<code class="identifier">LongIdentWithDots</code>([<code class="identifier">id</code>], <code class="identifier">_</code>)) -&gt; $4, <code class="identifier">SynArgInfo</code>($1, <code class="keyword">false</code>, <code class="identifier">Some</code> <code class="identifier">id</code>)
       | <code class="identifier">_</code> -&gt; <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSyntaxErrorInLabeledType</code>())  }

  | <code class="identifier">attributes</code> <code class="identifier">QMARK</code> <code class="identifier">ident</code> <code class="identifier">COLON</code> <code class="identifier">appType</code> 
     { $5, <code class="identifier">SynArgInfo</code>($1, <code class="keyword">true</code>, <code class="identifier">Some</code> $3) }

  | <code class="identifier">attributes</code> <code class="identifier">appType</code> 
     { ($2, <code class="identifier">SynArgInfo</code>($1, <code class="keyword">false</code>, <code class="identifier">None</code>)) }

  | <code class="identifier">appType</code> <code class="identifier">COLON</code> <code class="identifier">appType</code> 
     { <code class="keyword">match</code> $1 <code class="keyword">with</code> 
       | <code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>(<code class="identifier">LongIdentWithDots</code>([<code class="identifier">id</code>], <code class="identifier">_</code>)) -&gt; $3, <code class="identifier">SynArgInfo</code>([], <code class="keyword">false</code>, <code class="identifier">Some</code> <code class="identifier">id</code>)
       | <code class="identifier">_</code> -&gt; <code class="identifier">raiseParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSyntaxErrorInLabeledType</code>())  }

  | <code class="identifier">QMARK</code> <code class="identifier">ident</code> <code class="identifier">COLON</code> <code class="identifier">appType</code> 
     { $4, <code class="identifier">SynArgInfo</code>([], <code class="keyword">true</code>, <code class="identifier">Some</code> $2) }

  | <code class="identifier">appType</code> 
     { $1, <code class="identifier">SynArgInfo</code>([], <code class="keyword">false</code>, <code class="identifier">None</code>) }

<code class="comment">/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */</code>
<code class="comment">/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */</code>
<code class="identifier">typ</code>:
  | <code class="identifier">tupleType</code> <code class="identifier">RARROW</code> <code class="identifier">typ</code>  
     { <code class="identifier">SynType</code>.<code class="identifier">Fun</code>($1, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">tupleType</code> <code class="keyword">%prec</code> <code class="identifier">prec_typ_prefix</code> 
     { $1 }

<code class="identifier">typEOF</code>:
  | <code class="identifier">typ</code> <code class="identifier">EOF</code> { <code class="identifier">checkEndOfFileError</code> $2; $1 }


<code class="identifier">tupleType</code>:
  | <code class="identifier">appType</code> <code class="identifier">STAR</code> <code class="identifier">tupleOrQuotTypeElements</code> 
    { <code class="identifier">SynType</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, (<code class="keyword">false</code>, $1) :: $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> <code class="identifier">tupleOrQuotTypeElements</code>
    { <code class="keyword">if</code> $1 &lt;&gt; <code class="string">"/"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedInfixOperator</code>());
      <code class="identifier">SynType</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, (<code class="keyword">true</code>, <code class="identifier">SynType</code>.<code class="identifier">StaticConstant</code> (<code class="identifier">SynConst</code>.<code class="identifier">Int32</code> 1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>)) :: $2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">appType</code> <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> <code class="identifier">tupleOrQuotTypeElements</code>
    { <code class="keyword">if</code> $2 &lt;&gt; <code class="string">"/"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedInfixOperator</code>());
      <code class="identifier">SynType</code>.<code class="identifier">Tuple</code>(<code class="keyword">false</code>, (<code class="keyword">true</code>, $1) :: $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">appType</code> <code class="keyword">%prec</code> <code class="identifier">prec_tuptyp_prefix</code> 
    { $1 }

<code class="identifier">tupleOrQuotTypeElements</code>:
  | <code class="identifier">appType</code> <code class="identifier">STAR</code> <code class="identifier">tupleOrQuotTypeElements</code>              
    { (<code class="keyword">false</code>, $1) :: $3 }

  | <code class="identifier">appType</code> <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> <code class="identifier">tupleOrQuotTypeElements</code> 
    { <code class="keyword">if</code> $2 &lt;&gt; <code class="string">"/"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedInfixOperator</code>());
      (<code class="keyword">true</code>, $1) :: $3 }

  | <code class="identifier">appType</code> <code class="keyword">%prec</code> <code class="identifier">prec_tuptyptail_prefix</code> 
    { [(<code class="keyword">false</code>, $1)] }

<code class="identifier">appTypeCon</code>:
  | <code class="identifier">path</code> <code class="keyword">%prec</code> <code class="identifier">prec_atomtyp_path</code> 
    { <code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>($1) }

  | <code class="identifier">typar</code> 
    { <code class="identifier">SynType</code>.<code class="identifier">Var</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

<code class="identifier">appTypeConPower</code>:
  | <code class="identifier">appTypeCon</code> <code class="identifier">INFIX_AT_HAT_OP</code> <code class="identifier">atomicRationalConstant</code>
    { <code class="keyword">if</code> $2 &lt;&gt; <code class="string">"^"</code> &amp;&amp; $2 &lt;&gt; <code class="string">"^-"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedInfixOperator</code>());
      <code class="keyword">if</code> $2 = <code class="string">"^-"</code> <code class="keyword">then</code> <code class="identifier">SynType</code>.<code class="identifier">MeasurePower</code>($1, <code class="identifier">SynRationalConst</code>.<code class="identifier">Negate</code>($3), <code class="identifier">lhs</code> <code class="identifier">parseState</code>)
      <code class="keyword">else</code> <code class="identifier">SynType</code>.<code class="identifier">MeasurePower</code>($1, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>)  }

  | <code class="identifier">appTypeCon</code> 
    { $1 }

<code class="identifier">appType</code>:
  | <code class="identifier">appType</code> <code class="identifier">arrayTypeSuffix</code> 
      {  <code class="identifier">SynType</code>.<code class="identifier">Array</code>($2, $1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">appType</code> <code class="identifier">HIGH_PRECEDENCE_BRACK_APP</code> <code class="identifier">arrayTypeSuffix</code>   <code class="comment">/* only HPA for "name[]" allowed here */</code>
      {  <code class="identifier">SynType</code>.<code class="identifier">Array</code>($3, $1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">appType</code> <code class="identifier">appTypeConPower</code>  
      <code class="comment">/* note: use "rhs parseState 1" to deal with parens in "(int) list" */</code>
      { <code class="identifier">SynType</code>.<code class="identifier">App</code>($2, <code class="identifier">None</code>, [$1], [], <code class="identifier">None</code>, <code class="keyword">true</code>, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $2.<code class="identifier">Range</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">appTypePrefixArguments</code> <code class="identifier">rparen</code>  <code class="identifier">appTypeConPower</code>
      { <code class="keyword">let</code> <code class="identifier">args</code>, <code class="identifier">commas</code> = $2
        <code class="identifier">mlCompatWarning</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMultiArgumentGenericTypeFormDeprecated</code>()) (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>); 
        <code class="identifier">SynType</code>.<code class="identifier">App</code>($4, <code class="identifier">None</code>, <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">None</code>, <code class="keyword">true</code>, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>) }

  | <code class="identifier">powerType</code> 
      { $1 }

  | <code class="identifier">typar</code> <code class="identifier">COLON_GREATER</code> <code class="identifier">typ</code>                     
      {  <code class="keyword">let</code> <code class="identifier">tp</code>, <code class="identifier">typ</code> = $1, $3 
         <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code> 
         <code class="identifier">SynType</code>.<code class="identifier">WithGlobalConstraints</code>(<code class="identifier">SynType</code>.<code class="identifier">Var</code> (<code class="identifier">tp</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), [<code class="identifier">SynTypeConstraint</code>.<code class="identifier">WhereTyparSubtypeOfType</code>(<code class="identifier">tp</code>, <code class="identifier">typ</code>, <code class="identifier">m</code>)], <code class="identifier">m</code>)  }

  | <code class="identifier">UNDERSCORE</code> <code class="identifier">COLON_GREATER</code> <code class="identifier">typ</code> <code class="keyword">%prec</code> <code class="identifier">COLON_GREATER</code> 
      {  <code class="identifier">SynType</code>.<code class="identifier">HashConstraint</code>($3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

<code class="identifier">arrayTypeSuffix</code>:
  | <code class="identifier">LBRACK</code> <code class="identifier">RBRACK</code> 
      { 1 }

  | <code class="identifier">LBRACK</code> <code class="identifier">COMMA</code> <code class="identifier">RBRACK</code> 
      { 2 }

  | <code class="identifier">LBRACK</code> <code class="identifier">COMMA</code> <code class="identifier">COMMA</code> <code class="identifier">RBRACK</code> 
      { 3 }

  | <code class="identifier">LBRACK</code> <code class="identifier">COMMA</code> <code class="identifier">COMMA</code> <code class="identifier">COMMA</code> <code class="identifier">RBRACK</code> 
      { 4 }

<code class="identifier">appTypePrefixArguments</code>:
  | <code class="identifier">typeArgActual</code> <code class="identifier">COMMA</code> <code class="identifier">typeArgActual</code> <code class="identifier">typeArgListElements</code> 
      { <code class="keyword">let</code> <code class="identifier">typeArgs</code>, <code class="identifier">commas</code> = $4 <code class="keyword">in</code> $1 :: $3 :: <code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">typeArgs</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) :: (<code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">commas</code>) }

<code class="identifier">typeArgListElements</code>: 
  | <code class="identifier">typeArgListElements</code> <code class="identifier">COMMA</code> <code class="identifier">typeArgActual</code>
      { <code class="keyword">let</code> <code class="identifier">typeArgs</code>, <code class="identifier">commas</code> = $1
        $3 :: <code class="identifier">typeArgs</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) :: <code class="identifier">commas</code> } 

  | <code class="identifier">typeArgListElements</code> <code class="identifier">COMMA</code> <code class="identifier">dummyTypeArg</code> <code class="keyword">%prec</code> <code class="identifier">prec_args_error</code>  <code class="comment">/* NOTE: no "recover" */</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMissingTypeArgs</code>())
       <code class="keyword">let</code> <code class="identifier">typeArgs</code>, <code class="identifier">commas</code> = $1
       $3 :: <code class="identifier">typeArgs</code>, (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) :: <code class="identifier">commas</code> } 

  |   
      { [], [] }

<code class="identifier">powerType</code>:
  | <code class="identifier">atomTypeOrAnonRecdType</code>
    { $1 }

  | <code class="identifier">atomTypeOrAnonRecdType</code> <code class="identifier">INFIX_AT_HAT_OP</code> <code class="identifier">atomicRationalConstant</code>
     { <code class="keyword">if</code> $2 &lt;&gt; <code class="string">"^"</code> &amp;&amp; $2 &lt;&gt; <code class="string">"^-"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedInfixOperator</code>());
       <code class="keyword">if</code> $2 = <code class="string">"^-"</code> <code class="keyword">then</code> <code class="identifier">SynType</code>.<code class="identifier">MeasurePower</code>($1, <code class="identifier">SynRationalConst</code>.<code class="identifier">Negate</code>($3), <code class="identifier">lhs</code> <code class="identifier">parseState</code>)
       <code class="keyword">else</code> <code class="identifier">SynType</code>.<code class="identifier">MeasurePower</code>($1, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }


<code class="comment">/* Like appType but gives a deprecation error when a non-atomic type is used */</code>
<code class="comment">/* Also, doesn't start with '{|'  */</code>
<code class="identifier">atomTypeNonAtomicDeprecated</code>:
  | <code class="identifier">LPAREN</code> <code class="identifier">appTypePrefixArguments</code> <code class="identifier">rparen</code>  <code class="identifier">appTypeConPower</code>
      { <code class="keyword">let</code> <code class="identifier">args</code>, <code class="identifier">commas</code> = $2
        <code class="identifier">mlCompatWarning</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMultiArgumentGenericTypeFormDeprecated</code>()) (<code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>); 
        <code class="identifier">SynType</code>.<code class="identifier">App</code>($4, <code class="identifier">None</code>, <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">None</code>, <code class="keyword">true</code>, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $4.<code class="identifier">Range</code>) }

  | <code class="identifier">atomType</code>
      { $1 }

<code class="identifier">atomTypeOrAnonRecdType</code>:
  | <code class="identifier">atomType</code>
     { $1 }

  | <code class="identifier">anonRecdType</code>
     { <code class="keyword">let</code> <code class="identifier">flds</code>, <code class="identifier">isStruct</code> = $1
       <code class="keyword">let</code> <code class="identifier">flds2</code> = 
           <code class="identifier">flds</code> |&gt; <code class="identifier">List</code>.<code class="identifier">choose</code> (<code class="keyword">function</code> 
             | (<code class="identifier">SynField</code>([], <code class="keyword">false</code>, <code class="identifier">Some</code> <code class="identifier">id</code>, <code class="identifier">ty</code>, <code class="keyword">false</code>, <code class="identifier">_xmldoc</code>, <code class="identifier">None</code>, <code class="identifier">_m</code>)) -&gt; <code class="identifier">Some</code> (<code class="identifier">id</code>, <code class="identifier">ty</code>) 
             | <code class="identifier">_</code> -&gt; <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidAnonRecdType</code>()); <code class="identifier">None</code>)
       <code class="identifier">SynType</code>.<code class="identifier">AnonRecd</code> (<code class="identifier">isStruct</code>, <code class="identifier">flds2</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) }  

<code class="comment">/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */</code>
<code class="comment">/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */</code>
<code class="identifier">atomType</code>:
  | <code class="identifier">HASH</code> <code class="identifier">atomType</code> 
     { <code class="identifier">SynType</code>.<code class="identifier">HashConstraint</code>($2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">appTypeConPower</code> <code class="keyword">%prec</code> <code class="identifier">prec_atomtyp_path</code> 
     { $1 }

  | <code class="identifier">UNDERSCORE</code> 
     { <code class="identifier">SynType</code>.<code class="identifier">Anon</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">typ</code> <code class="identifier">rparen</code>
     { <code class="identifier">SynType</code>.<code class="identifier">Paren</code> ($2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">typ</code> <code class="identifier">recover</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code> ())
       <code class="identifier">SynType</code>.<code class="identifier">Paren</code> ($2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="identifier">appType</code> <code class="identifier">STAR</code> <code class="identifier">tupleOrQuotTypeElements</code>  <code class="identifier">rparen</code> 
    { <code class="identifier">SynType</code>.<code class="identifier">Tuple</code>(<code class="keyword">true</code>, (<code class="keyword">false</code>, $3) :: $5, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="identifier">appType</code> <code class="identifier">STAR</code> <code class="identifier">tupleOrQuotTypeElements</code>  <code class="identifier">recover</code>
    { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>()) 
      <code class="identifier">SynType</code>.<code class="identifier">Tuple</code>(<code class="keyword">true</code>, (<code class="keyword">false</code>, $3) :: $5, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="identifier">appType</code> <code class="identifier">STAR</code> <code class="identifier">recover</code>
    { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>()) 
      <code class="identifier">SynType</code>.<code class="identifier">Anon</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="identifier">appType</code> <code class="identifier">recover</code>
    { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>()) 
      <code class="identifier">SynType</code>.<code class="identifier">Anon</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">STRUCT</code> <code class="identifier">LPAREN</code> <code class="identifier">recover</code>
    { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnmatchedParen</code>()) 
      <code class="identifier">SynType</code>.<code class="identifier">Anon</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">rawConstant</code> 
     { <code class="identifier">SynType</code>.<code class="identifier">StaticConstant</code>($1, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) }

  | <code class="identifier">NULL</code>
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       <code class="identifier">SynType</code>.<code class="identifier">StaticConstant</code>(<code class="identifier">SynConst</code>.<code class="identifier">String</code> (<code class="keyword">null</code>, <code class="identifier">SynStringKind</code>.<code class="identifier">Regular</code>, <code class="identifier">m</code>), <code class="identifier">m</code>) }

  | <code class="identifier">CONST</code> <code class="identifier">atomicExpr</code>
     {  <code class="keyword">let</code> <code class="identifier">e</code>, <code class="identifier">_</code> = $2
        <code class="identifier">SynType</code>.<code class="identifier">StaticConstantExpr</code>(<code class="identifier">e</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">FALSE</code>  
      { <code class="identifier">SynType</code>.<code class="identifier">StaticConstant</code>(<code class="identifier">SynConst</code>.<code class="identifier">Bool</code> <code class="keyword">false</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

  | <code class="identifier">TRUE</code>  
      { <code class="identifier">SynType</code>.<code class="identifier">StaticConstant</code>(<code class="identifier">SynConst</code>.<code class="identifier">Bool</code> <code class="keyword">true</code>, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) } 

  | <code class="identifier">LPAREN</code> <code class="keyword">error</code> <code class="identifier">rparen</code>   
     { <code class="comment">(* silent recovery *)</code> <code class="identifier">SynType</code>.<code class="identifier">Anon</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) }  

  | <code class="identifier">appTypeCon</code> <code class="identifier">typeArgsNoHpaDeprecated</code> <code class="keyword">%prec</code> <code class="identifier">prec_atomtyp_path</code> 
     { <code class="keyword">let</code> <code class="identifier">mLessThan</code>, <code class="identifier">mGreaterThan</code>, <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">mWhole</code> = $2 <code class="keyword">in</code> <code class="identifier">SynType</code>.<code class="identifier">App</code>($1, <code class="identifier">Some</code>(<code class="identifier">mLessThan</code>), <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">mGreaterThan</code>, <code class="keyword">false</code>, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> <code class="identifier">mWhole</code>) } 

  | <code class="identifier">atomType</code> <code class="identifier">DOT</code> <code class="identifier">path</code> <code class="keyword">%prec</code> <code class="identifier">prec_atomtyp_get_path</code> 
     { <code class="identifier">SynType</code>.<code class="identifier">LongIdentApp</code>($1, $3, <code class="identifier">None</code>, [], [], <code class="identifier">None</code>, <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) $3.<code class="identifier">Range</code>) } 

  | <code class="identifier">atomType</code> <code class="identifier">DOT</code> <code class="identifier">path</code> <code class="identifier">typeArgsNoHpaDeprecated</code> <code class="keyword">%prec</code> <code class="identifier">prec_atomtyp_get_path</code> 
     { <code class="keyword">let</code> <code class="identifier">mLessThan</code>, <code class="identifier">mGreaterThan</code>, <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">mWhole</code> = $4 
       <code class="identifier">SynType</code>.<code class="identifier">LongIdentApp</code>($1, $3, <code class="identifier">Some</code>(<code class="identifier">mLessThan</code>), <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">mGreaterThan</code>, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> <code class="identifier">mWhole</code>) } 

  | <code class="identifier">appTypeCon</code> <code class="identifier">DOT</code> <code class="identifier">ends_coming_soon_or_recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsExpectedNameAfterToken</code>())
       $1 } 

<code class="identifier">typeArgsNoHpaDeprecated</code>:
  | <code class="identifier">typeArgsActual</code>
     { <code class="keyword">let</code> <code class="identifier">mLessThan</code>, <code class="identifier">mGreaterThan</code>, <code class="identifier">parsedOk</code>, <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">mAll</code> = $1
       <code class="keyword">if</code> <code class="identifier">parsedOk</code> <code class="keyword">then</code> <code class="comment">// if someone has "foo&lt;bar" without a closing greater-than, then the lexfilter does not introduce a HPA, even though it is adjacent</code>
           <code class="identifier">warning</code>(<code class="identifier">Error</code>(<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsNonAdjacentTyargs</code>(), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1))
       <code class="identifier">mLessThan</code>, <code class="identifier">mGreaterThan</code>, <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">mAll</code> } 

  | <code class="identifier">HIGH_PRECEDENCE_TYAPP</code> <code class="identifier">typeArgsActual</code> 
     { <code class="keyword">let</code> <code class="identifier">mLessThan</code>, <code class="identifier">mGreaterThan</code>, <code class="identifier">_</code>, <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">mAll</code> = $2
       <code class="identifier">mLessThan</code>, <code class="identifier">mGreaterThan</code>, <code class="identifier">args</code>, <code class="identifier">commas</code>, <code class="identifier">mAll</code> } 

<code class="identifier">typeArgsActual</code>:
  | <code class="identifier">LESS</code> <code class="identifier">typeArgActualOrDummyIfEmpty</code> <code class="identifier">COMMA</code> <code class="identifier">typeArgActualOrDummyIfEmpty</code> <code class="identifier">typeArgListElements</code> <code class="identifier">GREATER</code> 
     { <code class="keyword">let</code> <code class="identifier">typeArgs</code>, <code class="identifier">commas</code> = $5
       (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">Some</code>(<code class="identifier">rhs</code> <code class="identifier">parseState</code> 6), <code class="keyword">true</code>, ($2 :: $4 :: <code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">typeArgs</code>), (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) :: (<code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">commas</code>), <code class="identifier">lhs</code> <code class="identifier">parseState</code> } 

  | <code class="identifier">LESS</code> <code class="identifier">typeArgActualOrDummyIfEmpty</code> <code class="identifier">COMMA</code> <code class="identifier">typeArgActualOrDummyIfEmpty</code> <code class="identifier">typeArgListElements</code> <code class="identifier">recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $6 <code class="keyword">then</code> 
           <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedEndOfFileTypeArgs</code>())
       <code class="keyword">else</code>
           <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMissingGreaterThan</code>())
       <code class="keyword">let</code> <code class="identifier">typeArgs</code>, <code class="identifier">commas</code> = $5
       <code class="keyword">let</code> <code class="identifier">nextToken</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 6
       <code class="keyword">let</code> <code class="identifier">zeroWidthAtStartOfNextToken</code> = <code class="identifier">nextToken</code>.<code class="identifier">StartRange</code>
       (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">None</code>, <code class="keyword">false</code>, ($2 :: $4 :: <code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">typeArgs</code>), (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3) :: (<code class="identifier">List</code>.<code class="identifier">rev</code> <code class="identifier">commas</code>), <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">zeroWidthAtStartOfNextToken</code> } 

  | <code class="identifier">LESS</code> <code class="identifier">typeArgActualOrDummyIfEmpty</code> <code class="identifier">COMMA</code> <code class="identifier">ends_coming_soon_or_recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $4 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 4) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMissingTypeArgs</code>())
       <code class="keyword">let</code> <code class="identifier">nextToken</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 4
       <code class="keyword">let</code> <code class="identifier">zeroWidthAtStartOfNextToken</code> = <code class="identifier">nextToken</code>.<code class="identifier">StartRange</code>
       (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">None</code>, <code class="keyword">false</code>, [$2], [<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3], <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">zeroWidthAtStartOfNextToken</code> } 

  | <code class="identifier">LESS</code> <code class="identifier">typeArgActual</code> <code class="identifier">GREATER</code> 
     { (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">Some</code>(<code class="identifier">rhs</code> <code class="identifier">parseState</code> 3), <code class="keyword">true</code>, [$2], [], <code class="identifier">lhs</code> <code class="identifier">parseState</code> } 

  | <code class="identifier">LESS</code> <code class="identifier">typeArgActual</code> <code class="identifier">ends_coming_soon_or_recover</code>
     { <code class="keyword">let</code> <code class="identifier">nextToken</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 3
       <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> <code class="identifier">nextToken</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMissingTypeArgs</code>())
       <code class="keyword">let</code> <code class="identifier">zeroWidthAtStartOfNextToken</code> = <code class="identifier">nextToken</code>.<code class="identifier">StartRange</code>
       (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">None</code>, <code class="keyword">false</code>, [$2], [], <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">zeroWidthAtStartOfNextToken</code> } 

  | <code class="identifier">LESS</code> <code class="identifier">GREATER</code> 
     { (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">Some</code>(<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2), <code class="keyword">true</code>, [], [], <code class="identifier">lhs</code> <code class="identifier">parseState</code> } 

  | <code class="identifier">LESS</code> <code class="identifier">recover</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> $2 <code class="keyword">then</code>  
           <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsExpectedTypeAfterToken</code>())
       <code class="keyword">else</code>
           <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMissingTypeArgs</code>())
       <code class="keyword">let</code> <code class="identifier">nextToken</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2
       <code class="keyword">let</code> <code class="identifier">zeroWidthAtStartOfNextToken</code> = <code class="identifier">nextToken</code>.<code class="identifier">StartRange</code>
       (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1), <code class="identifier">None</code>, <code class="keyword">false</code>, [], [], <code class="identifier">unionRanges</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) <code class="identifier">zeroWidthAtStartOfNextToken</code> } 

<code class="identifier">typeArgActual</code>:
  | <code class="identifier">typ</code>
     { $1 }

  | <code class="identifier">typ</code> <code class="identifier">EQUALS</code> <code class="identifier">typ</code>
     { <code class="identifier">SynType</code>.<code class="identifier">StaticConstantNamed</code>($1, $3, <code class="identifier">unionRanges</code> $1.<code class="identifier">Range</code> $3.<code class="identifier">Range</code>) }

  | <code class="identifier">typ</code> <code class="identifier">EQUALS</code> <code class="comment">/* NOTE: no "recover" */</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMissingTypeArgs</code>())
       <code class="keyword">let</code> <code class="identifier">dummy</code> = <code class="identifier">SynType</code>.<code class="identifier">StaticConstant</code>(<code class="identifier">SynConst</code>.<code class="identifier">Int32</code>(0), <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2)
       <code class="identifier">SynType</code>.<code class="identifier">StaticConstantNamed</code>($1, <code class="identifier">dummy</code>, (<code class="identifier">rhs2</code> <code class="identifier">parseState</code> 1 2))
     }

<code class="identifier">typeArgActualOrDummyIfEmpty</code>:
  | <code class="identifier">typeArgActual</code>
     { $1 }

  | <code class="identifier">dummyTypeArg</code>
     { <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMissingTypeArgs</code>())
       $1 }

<code class="identifier">dummyTypeArg</code>:
  |  <code class="comment">/* EMPTY */</code>
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1
       <code class="keyword">let</code> <code class="identifier">dummyStatVal</code> = <code class="identifier">SynType</code>.<code class="identifier">StaticConstant</code>(<code class="identifier">SynConst</code>.<code class="identifier">Int32</code>(0), <code class="identifier">m</code>)
       <code class="keyword">let</code> <code class="identifier">dummyName</code> = <code class="identifier">SynType</code>.<code class="identifier">LongIdent</code>(<code class="identifier">LongIdentWithDots</code>([<code class="identifier">ident</code>(<code class="string">""</code>, <code class="identifier">m</code>)], []))
       <code class="keyword">let</code> <code class="identifier">dummyTypeArg</code> = <code class="identifier">SynType</code>.<code class="identifier">StaticConstantNamed</code>(<code class="identifier">dummyName</code>, <code class="identifier">dummyStatVal</code>, <code class="identifier">m</code>)
       <code class="identifier">dummyTypeArg</code> }

<code class="identifier">measureTypeArg</code>:
  | <code class="identifier">LESS</code> <code class="identifier">measureTypeExpr</code> <code class="identifier">GREATER</code>
     { $2 }

  | <code class="identifier">LESS</code> <code class="identifier">UNDERSCORE</code> <code class="identifier">GREATER</code>
     { <code class="identifier">SynMeasure</code>.<code class="identifier">Anon</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

<code class="identifier">measureTypeAtom</code>:
  | <code class="identifier">path</code> 
     { <code class="identifier">SynMeasure</code>.<code class="identifier">Named</code>($1.<code class="identifier">Lid</code>, $1.<code class="identifier">Range</code>) }

  | <code class="identifier">typar</code> 
     { <code class="identifier">SynMeasure</code>.<code class="identifier">Var</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">LPAREN</code> <code class="identifier">measureTypeExpr</code> <code class="identifier">rparen</code>
     { $2 }

<code class="identifier">measureTypePower</code>:
  | <code class="identifier">measureTypeAtom</code> 
      { $1 }

  | <code class="identifier">measureTypeAtom</code> <code class="identifier">INFIX_AT_HAT_OP</code> <code class="identifier">atomicRationalConstant</code>
     { <code class="keyword">if</code> $2 &lt;&gt; <code class="string">"^"</code> &amp;&amp; $2 &lt;&gt; <code class="string">"^-"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedOperatorForUnitOfMeasure</code>());
       <code class="keyword">if</code> $2 = <code class="string">"^-"</code> <code class="keyword">then</code> <code class="identifier">SynMeasure</code>.<code class="identifier">Power</code>($1, <code class="identifier">SynRationalConst</code>.<code class="identifier">Negate</code>($3), <code class="identifier">lhs</code> <code class="identifier">parseState</code>)
       <code class="keyword">else</code> <code class="identifier">SynMeasure</code>.<code class="identifier">Power</code>($1, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">INT32</code>
     { <code class="keyword">if</code> <code class="identifier">fst</code> $1 &lt;&gt; 1 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedIntegerLiteralForUnitOfMeasure</code>());
       <code class="identifier">SynMeasure</code>.<code class="identifier">One</code> }

<code class="identifier">measureTypeSeq</code>:
  | <code class="identifier">measureTypePower</code>
    { [$1] }

  | <code class="identifier">measureTypePower</code> <code class="identifier">measureTypeSeq</code>
    { $1 :: $2 }

<code class="identifier">measureTypeExpr</code>:
  | <code class="identifier">measureTypeSeq</code>
    { <code class="identifier">SynMeasure</code>.<code class="identifier">Seq</code>($1, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">measureTypeExpr</code> <code class="identifier">STAR</code> <code class="identifier">measureTypeExpr</code>
    { <code class="identifier">SynMeasure</code>.<code class="identifier">Product</code>($1, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">measureTypeExpr</code> <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> <code class="identifier">measureTypeExpr</code>
    { <code class="keyword">if</code> $2 &lt;&gt; <code class="string">"*"</code> &amp;&amp; $2 &lt;&gt; <code class="string">"/"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedOperatorForUnitOfMeasure</code>());
      <code class="keyword">if</code> $2 = <code class="string">"*"</code> <code class="keyword">then</code> <code class="identifier">SynMeasure</code>.<code class="identifier">Product</code>($1, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>)
      <code class="keyword">else</code> <code class="identifier">SynMeasure</code>.<code class="identifier">Divide</code>($1, $3, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }

  | <code class="identifier">INFIX_STAR_DIV_MOD_OP</code> <code class="identifier">measureTypeExpr</code>
     { <code class="keyword">if</code> $1 &lt;&gt; <code class="string">"/"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedOperatorForUnitOfMeasure</code>());
       <code class="identifier">SynMeasure</code>.<code class="identifier">Divide</code>(<code class="identifier">SynMeasure</code>.<code class="identifier">One</code>, $2, <code class="identifier">lhs</code> <code class="identifier">parseState</code>) }
   
<code class="identifier">typar</code>: 
  | <code class="identifier">QUOTE</code> <code class="identifier">ident</code> 
     {  <code class="keyword">let</code> <code class="identifier">id</code> = <code class="identifier">mkSynId</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) ($2).<code class="identifier">idText</code>
        <code class="identifier">SynTypar</code>(<code class="identifier">id</code>, <code class="identifier">TyparStaticReq</code>.<code class="identifier">None</code>, <code class="keyword">false</code>) }

  | <code class="identifier">staticallyKnownHeadTypar</code> 
     { $1 }

<code class="identifier">staticallyKnownHeadTypar</code>: 
  | <code class="identifier">INFIX_AT_HAT_OP</code> <code class="identifier">ident</code> 
    {  <code class="keyword">if</code> $1 &lt;&gt; <code class="string">"^"</code> <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsUnexpectedTypeParameter</code>());
       <code class="keyword">let</code> <code class="identifier">id</code> = <code class="identifier">mkSynId</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) ($2).<code class="identifier">idText</code>
       <code class="identifier">SynTypar</code>(<code class="identifier">id</code>, <code class="identifier">TyparStaticReq</code>.<code class="identifier">HeadType</code>, <code class="keyword">false</code>) }

<code class="identifier">ident</code>: 
  | <code class="identifier">IDENT</code> 
     { <code class="identifier">ident</code>($1, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) } 

<code class="comment">/* A A.B.C path used to an identifier */</code>
<code class="identifier">path</code>: 
  | <code class="identifier">GLOBAL</code>
      { <code class="identifier">LongIdentWithDots</code>([<code class="identifier">ident</code>(<code class="identifier">MangledGlobalName</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1)], []) }

  | <code class="identifier">ident</code>  
     { <code class="identifier">LongIdentWithDots</code>([$1], []) }

  | <code class="identifier">path</code> <code class="identifier">DOT</code> <code class="identifier">ident</code>  
     { <code class="keyword">let</code> (<code class="identifier">LongIdentWithDots</code>(<code class="identifier">lid</code>, <code class="identifier">dotms</code>)) = $1 <code class="keyword">in</code> <code class="identifier">LongIdentWithDots</code>(<code class="identifier">lid</code> @ [$3], <code class="identifier">dotms</code> @ [<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2]) } 

  | <code class="identifier">path</code> <code class="identifier">DOT</code> <code class="identifier">ends_coming_soon_or_recover</code>  
     { <code class="keyword">if</code> <code class="keyword">not</code> $3 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsExpectedNameAfterToken</code>())
       <code class="keyword">let</code> (<code class="identifier">LongIdentWithDots</code>(<code class="identifier">lid</code>, <code class="identifier">dotms</code>)) = $1 <code class="keyword">in</code> <code class="identifier">LongIdentWithDots</code>(<code class="identifier">lid</code>, <code class="identifier">dotms</code> @ [<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2])  } 


<code class="comment">/* An operator name, with surrounnding parentheses */</code>
<code class="identifier">opName</code>: 
  | <code class="identifier">LPAREN</code> <code class="identifier">operatorName</code> <code class="identifier">rparen</code>  
     {  <code class="identifier">ident</code>(<code class="identifier">CompileOpName</code> $2, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) }

  | <code class="identifier">LPAREN</code> <code class="keyword">error</code> <code class="identifier">rparen</code>  
     {  <code class="identifier">reportParseErrorAt</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsErrorParsingAsOperatorName</code>()); <code class="identifier">ident</code>(<code class="identifier">CompileOpName</code> <code class="string">"****"</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2) }

  | <code class="identifier">LPAREN_STAR_RPAREN</code>
     {  <code class="identifier">ident</code>(<code class="identifier">CompileOpName</code> <code class="string">"*"</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) }

  <code class="comment">/* active pattern name */</code>
  | <code class="identifier">LPAREN</code> <code class="identifier">activePatternCaseNames</code> <code class="identifier">BAR</code> <code class="identifier">rparen</code> 
     { <code class="keyword">let</code> <code class="identifier">text</code> = (<code class="string">"|"</code> + <code class="identifier">String</code>.<code class="identifier">concat</code> <code class="string">"|"</code> (<code class="identifier">List</code>.<code class="identifier">rev</code> $2) + <code class="string">"|"</code>)
       <code class="identifier">ident</code>(<code class="identifier">text</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 2 3) }
                         
  <code class="comment">/* partial active pattern name */</code>
  | <code class="identifier">LPAREN</code> <code class="identifier">activePatternCaseNames</code> <code class="identifier">BAR</code> <code class="identifier">UNDERSCORE</code> <code class="identifier">BAR</code> <code class="identifier">rparen</code> 
     { <code class="keyword">let</code> <code class="identifier">text</code> = (<code class="string">"|"</code> + <code class="identifier">String</code>.<code class="identifier">concat</code> <code class="string">"|"</code> (<code class="identifier">List</code>.<code class="identifier">rev</code> $2) + <code class="string">"|_|"</code> )
       <code class="identifier">ident</code>(<code class="identifier">text</code>, <code class="identifier">rhs2</code> <code class="identifier">parseState</code> 2 5) }

<code class="comment">/* An operator name, without surrounding parentheses */</code>
<code class="identifier">operatorName</code>: 
  | <code class="identifier">PREFIX_OP</code> 
     { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">IsValidPrefixOperatorDefinitionName</code> $1) <code class="keyword">then</code> 
           <code class="identifier">reportParseErrorAt</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsInvalidPrefixOperatorDefinition</code>());
       $1 }

  | <code class="identifier">INFIX_STAR_STAR_OP</code>
     { $1 }

  | <code class="identifier">INFIX_COMPARE_OP</code>
     { $1 }

  | <code class="identifier">INFIX_AT_HAT_OP</code>
     { $1 }

  | <code class="identifier">INFIX_BAR_OP</code>
     { $1 }

  | <code class="identifier">INFIX_AMP_OP</code>
     { $1 }

  | <code class="identifier">PLUS_MINUS_OP</code>
     { $1 }

  | <code class="identifier">INFIX_STAR_DIV_MOD_OP</code>
     { $1 }

  | <code class="identifier">DOLLAR</code>
     { <code class="string">"$"</code> }

  | <code class="identifier">ADJACENT_PREFIX_OP</code>
     { $1 }

  | <code class="identifier">MINUS</code>
     { <code class="string">"-"</code> }

  | <code class="identifier">STAR</code>
     { <code class="string">"*"</code> }

  | <code class="identifier">EQUALS</code>
     { <code class="string">"="</code> }

  | <code class="identifier">OR</code>
     { <code class="string">"or"</code> }

  | <code class="identifier">LESS</code>
     { <code class="string">"&lt;"</code> }

  | <code class="identifier">GREATER</code>
     { <code class="string">"&gt;"</code> }

  | <code class="identifier">QMARK</code>
     { <code class="string">"?"</code> }

  | <code class="identifier">AMP</code>
     { <code class="string">"&amp;"</code> }

  | <code class="identifier">AMP_AMP</code>
     { <code class="string">"&amp;&amp;"</code> }

  | <code class="identifier">BAR_BAR</code>
     { <code class="string">"||"</code> }

  | <code class="identifier">COLON_EQUALS</code>
     { <code class="string">":="</code> }

  | <code class="identifier">FUNKY_OPERATOR_NAME</code> 
     { <code class="keyword">if</code> $1 &lt;&gt; <code class="string">".[]"</code>  &amp;&amp; $1 &lt;&gt; <code class="string">".()"</code> &amp;&amp; $1 &lt;&gt; <code class="string">".()&lt;-"</code> <code class="keyword">then</code> 
            <code class="identifier">deprecatedOperator</code> (<code class="identifier">lhs</code> <code class="identifier">parseState</code>); 
       $1 }

  | <code class="identifier">PERCENT_OP</code>
     { $1 }

  | <code class="identifier">DOT_DOT</code>
     { <code class="string">".."</code> }

  | <code class="identifier">DOT_DOT</code> <code class="identifier">DOT_DOT</code>
     { <code class="string">".. .."</code> }

  | <code class="identifier">LQUOTE</code> <code class="identifier">RQUOTE</code> 
     { <code class="keyword">if</code> $1 &lt;&gt; $2 <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsMismatchedQuotationName</code>(<code class="identifier">fst</code> $1));  
       <code class="identifier">fst</code> $1 } 

<code class="comment">/* One part of an active pattern name */</code>
<code class="identifier">activePatternCaseName</code>: 
  | <code class="identifier">IDENT</code>
     { <code class="keyword">if</code> <code class="keyword">not</code> (<code class="identifier">String</code>.<code class="identifier">isLeadingIdentifierCharacterUpperCase</code> <code class="identifier">_1</code>) <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsActivePatternCaseMustBeginWithUpperCase</code>());  
       <code class="keyword">if</code> ($1.<code class="identifier">IndexOf</code>(<code class="char">'|'</code>) &lt;&gt; -1) <code class="keyword">then</code> <code class="identifier">reportParseErrorAt</code> (<code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsActivePatternCaseContainsPipe</code>());  
       $1 }

<code class="comment">/* Multiple parts of an active pattern name */</code>
<code class="identifier">activePatternCaseNames</code>: 
  | <code class="identifier">BAR</code> <code class="identifier">activePatternCaseName</code>
     { [$2] }

  | <code class="identifier">activePatternCaseNames</code> <code class="identifier">BAR</code> <code class="identifier">activePatternCaseName</code>
     { $3 :: $1 }

<code class="comment">/* A single item that is an identifier or operator name */</code>
<code class="identifier">identOrOp</code>: 
  | <code class="identifier">ident</code>  
     { $1 } 

  | <code class="identifier">opName</code> 
     { $1 }

<code class="comment">/* An A.B.C path ending in an identifier or operator name */</code>
<code class="comment">/* Note, only used in atomicPatternLongIdent */</code>
<code class="identifier">pathOp</code>: 
  | <code class="identifier">ident</code>  
     { <code class="identifier">LongIdentWithDots</code>([$1], []) }

  | <code class="identifier">opName</code> 
     { <code class="identifier">LongIdentWithDots</code>([$1], []) }

  | <code class="identifier">ident</code> <code class="identifier">DOT</code> <code class="identifier">pathOp</code> 
     { <code class="keyword">let</code> (<code class="identifier">LongIdentWithDots</code>(<code class="identifier">lid</code>, <code class="identifier">dotms</code>)) = $3 <code class="keyword">in</code> <code class="identifier">LongIdentWithDots</code>($1 :: <code class="identifier">lid</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 2 :: <code class="identifier">dotms</code>) } 

  | <code class="identifier">ident</code> <code class="identifier">DOT</code> <code class="keyword">error</code>  
     { <code class="comment">(* silent recovery *)</code> <code class="identifier">LongIdentWithDots</code>([$1], [<code class="identifier">rhs</code> <code class="identifier">parseState</code> 2]) }  


<code class="comment">/* nameop is identOrOp not used as part of a path */</code>
<code class="identifier">nameop</code>: 
  | <code class="identifier">identOrOp</code> { $1 } 

<code class="identifier">identExpr</code>:
  | <code class="identifier">ident</code>
     { <code class="identifier">SynExpr</code>.<code class="identifier">Ident</code>($1) }

  | <code class="identifier">opName</code>
     { <code class="keyword">let</code> <code class="identifier">m</code> = <code class="identifier">lhs</code> <code class="identifier">parseState</code>
       <code class="keyword">let</code> <code class="identifier">mLparen</code> = <code class="identifier">mkFileIndexRange</code> <code class="identifier">m</code>.<code class="identifier">FileIndex</code> <code class="identifier">m</code>.<code class="identifier">Start</code> (<code class="identifier">mkPos</code> <code class="identifier">m</code>.<code class="identifier">StartLine</code> (<code class="identifier">m</code>.<code class="identifier">StartColumn</code> + 1))
       <code class="keyword">let</code> <code class="identifier">mRparen</code> = <code class="identifier">mkFileIndexRange</code> <code class="identifier">m</code>.<code class="identifier">FileIndex</code> (<code class="identifier">mkPos</code> <code class="identifier">m</code>.<code class="identifier">EndLine</code> (<code class="identifier">m</code>.<code class="identifier">EndColumn</code> - 1)) <code class="identifier">m</code>.<code class="identifier">End</code>
       <code class="identifier">SynExpr</code>.<code class="identifier">Paren</code>(<code class="identifier">SynExpr</code>.<code class="identifier">Ident</code>($1), <code class="identifier">mLparen</code>, <code class="identifier">Some</code> <code class="identifier">mRparen</code>, <code class="identifier">m</code>) }

<code class="identifier">topSeparator</code>: 
  | <code class="identifier">SEMICOLON</code> { } 
  | <code class="identifier">SEMICOLON_SEMICOLON</code> { }
  | <code class="identifier">OBLOCKSEP</code> { }  

<code class="identifier">topSeparators</code>: 
  | <code class="identifier">topSeparator</code> { } 
  | <code class="identifier">topSeparator</code> <code class="identifier">topSeparators</code> { }

<code class="identifier">opt_topSeparators</code>: 
  | <code class="identifier">topSeparator</code> <code class="identifier">opt_topSeparators</code> { }
  | <code class="comment">/* EMPTY */</code>                    { } 

<code class="comment">/* Seprators in either #light or non-#light */</code>
<code class="identifier">seps</code>: 
  | <code class="identifier">OBLOCKSEP</code> { } 
  | <code class="identifier">SEMICOLON</code> { }
  | <code class="identifier">OBLOCKSEP</code> <code class="identifier">SEMICOLON</code> { }
  | <code class="identifier">SEMICOLON</code> <code class="identifier">OBLOCKSEP</code> { }

<code class="comment">/* An 'end' that's optional only in #light, where an ODECLEND gets inserted, and explicit 'end's get converted to OEND */</code>
<code class="identifier">declEnd</code>: 
  | <code class="identifier">ODECLEND</code> 
      { } 
  | <code class="identifier">OEND</code> 
      {   }
  | <code class="identifier">END</code> 
      { } 

<code class="comment">/* An 'end' that's optional in both #light and non-#light */</code>
<code class="identifier">opt_declEnd</code>: 
  | <code class="identifier">ODECLEND</code> 
      {} 
  | <code class="identifier">OEND</code> 
      { } 
  | <code class="identifier">END</code> 
      {} 
  | <code class="comment">/* EMPTY */</code>    
      {} 

<code class="identifier">opt_ODECLEND</code>: 
  | <code class="identifier">ODECLEND</code>    { } 
  | <code class="comment">/* EMPTY */</code> { }

<code class="identifier">deprecated_opt_equals</code>: 
  | <code class="identifier">EQUALS</code>      { <code class="identifier">deprecatedWithError</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsNoEqualShouldFollowNamespace</code>()) (<code class="identifier">lhs</code> <code class="identifier">parseState</code>); () } 
  | <code class="comment">/* EMPTY */</code> {  }

<code class="identifier">opt_equals</code>:
  | <code class="identifier">EQUALS</code>      { <code class="keyword">true</code> }
  | <code class="comment">/* EMPTY */</code> { <code class="keyword">false</code> } 

<code class="identifier">opt_OBLOCKSEP</code>: 
  | <code class="identifier">OBLOCKSEP</code>   { }
  | <code class="comment">/* EMPTY */</code> { } 

<code class="identifier">opt_seps</code>: 
  | <code class="identifier">seps</code>        { }
  | <code class="comment">/* EMPTY */</code> { } 

<code class="identifier">opt_rec</code>: 
  | <code class="identifier">REC</code>         { <code class="keyword">true</code> }
  | <code class="comment">/* EMPTY */</code> { <code class="keyword">false</code> } 

<code class="identifier">opt_bar</code>: 
  | <code class="identifier">BAR</code>         { } 
  | <code class="comment">/* EMPTY */</code> { } 

<code class="identifier">opt_inline</code>: 
  | <code class="identifier">INLINE</code>      { <code class="keyword">true</code> } 
  | <code class="comment">/* EMPTY */</code> { <code class="keyword">false</code> }

<code class="identifier">opt_mutable</code>: 
  | <code class="identifier">MUTABLE</code>     { <code class="keyword">true</code> } 
  | <code class="comment">/* EMPTY */</code> { <code class="keyword">false</code> }

<code class="comment">/* A 'do' token in either #light or non-#light */</code>
<code class="identifier">doToken</code>: 
  | <code class="identifier">DO</code>  { }
  | <code class="identifier">ODO</code> { }

<code class="identifier">doneDeclEnd</code>: 
  | <code class="identifier">DONE</code> { }
  | <code class="identifier">ODECLEND</code> { }  <code class="comment">/* DONE gets thrown away by the lexfilter in favour of ODECLEND */</code>

<code class="identifier">structOrBegin</code>: 
  | <code class="identifier">STRUCT</code> { <code class="identifier">mlCompatWarning</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSyntaxModuleStructEndDeprecated</code>()) (<code class="identifier">lhs</code> <code class="identifier">parseState</code>); }
  | <code class="identifier">BEGIN</code> { } 

<code class="identifier">sigOrBegin</code>: 
  | <code class="identifier">SIG</code> { <code class="identifier">mlCompatWarning</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSyntaxModuleSigEndDeprecated</code>()) (<code class="identifier">lhs</code> <code class="identifier">parseState</code>); }
  | <code class="identifier">BEGIN</code> { } 

<code class="identifier">colonOrEquals</code>: 
  | <code class="identifier">COLON</code> { <code class="identifier">mlCompatWarning</code> (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsSyntaxModuleSigEndDeprecated</code>()) (<code class="identifier">lhs</code> <code class="identifier">parseState</code>); }
  | <code class="identifier">EQUALS</code> { } 

<code class="comment">/* A literal string or a string from a keyword like __SOURCE_FILE__ */</code>
<code class="identifier">stringOrKeywordString</code>:
  | <code class="identifier">STRING</code> 
     { <code class="keyword">let</code> (<code class="identifier">s</code>, <code class="identifier">synStringKind</code>, <code class="identifier">_</code>) = $1
       <code class="identifier">s</code>, <code class="identifier">synStringKind</code> }
  | <code class="identifier">KEYWORD_STRING</code> { $1, <code class="identifier">SynStringKind</code>.<code class="identifier">Regular</code> }

<code class="identifier">interpolatedStringFill</code>:
  | <code class="identifier">declExpr</code>
     { ($1, <code class="identifier">None</code>) }

  | <code class="identifier">declExpr</code> <code class="identifier">COLON</code> <code class="identifier">ident</code> <code class="keyword">%prec</code> <code class="identifier">interpolation_fill</code>
     { ($1, <code class="identifier">Some</code> $3) }

<code class="identifier">interpolatedStringParts</code>:
  | <code class="identifier">INTERP_STRING_END</code>
     { [ <code class="identifier">SynInterpolatedStringPart</code>.<code class="identifier">String</code> (<code class="identifier">fst</code> $1, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) ] }

  | <code class="identifier">INTERP_STRING_PART</code> <code class="identifier">interpolatedStringFill</code> <code class="identifier">interpolatedStringParts</code>
     { <code class="identifier">SynInterpolatedStringPart</code>.<code class="identifier">String</code> (<code class="identifier">fst</code> $1, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) :: <code class="identifier">SynInterpolatedStringPart</code>.<code class="identifier">FillExpr</code> $2 :: $3 }

  | <code class="identifier">INTERP_STRING_PART</code> <code class="identifier">interpolatedStringParts</code>
     { 
       <code class="keyword">let</code> <code class="identifier">rbrace</code> = <code class="identifier">parseState</code>.<code class="identifier">InputEndPosition</code> 1
       <code class="keyword">let</code> <code class="identifier">lbrace</code> = <code class="identifier">parseState</code>.<code class="identifier">InputStartPosition</code> 2
       <code class="identifier">reportParseErrorAt</code> (<code class="identifier">mkSynRange</code> <code class="identifier">rbrace</code> <code class="identifier">lbrace</code>) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEmptyFillInInterpolatedString</code>())
       <code class="identifier">SynInterpolatedStringPart</code>.<code class="identifier">String</code> (<code class="identifier">fst</code> $1, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) :: $2 }

<code class="comment">/* INTERP_STRING_BEGIN_END */</code>
<code class="comment">/* INTERP_STRING_BEGIN_PART int32 INTERP_STRING_END */</code>
<code class="comment">/* INTERP_STRING_BEGIN_PART int32 INTERP_STRING_PART int32 INTERP_STRING_END */</code>
<code class="identifier">interpolatedString</code>:
  | <code class="identifier">INTERP_STRING_BEGIN_PART</code> <code class="identifier">interpolatedStringFill</code> <code class="identifier">interpolatedStringParts</code>
    { <code class="keyword">let</code> <code class="identifier">s</code>, <code class="identifier">synStringKind</code>, <code class="identifier">_</code> = $1
      <code class="identifier">SynInterpolatedStringPart</code>.<code class="identifier">String</code> (<code class="identifier">s</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) :: <code class="identifier">SynInterpolatedStringPart</code>.<code class="identifier">FillExpr</code> $2 :: $3, <code class="identifier">synStringKind</code> }

  | <code class="identifier">INTERP_STRING_BEGIN_END</code>
    { <code class="keyword">let</code> <code class="identifier">s</code>, <code class="identifier">synStringKind</code>, <code class="identifier">_</code> = $1
      [ <code class="identifier">SynInterpolatedStringPart</code>.<code class="identifier">String</code> (<code class="identifier">s</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) ], <code class="identifier">synStringKind</code> }

  | <code class="identifier">INTERP_STRING_BEGIN_PART</code> <code class="identifier">interpolatedStringParts</code>
    { 
      <code class="keyword">let</code> <code class="identifier">s</code>, <code class="identifier">synStringKind</code>, <code class="identifier">_</code> = $1
      <code class="keyword">let</code> <code class="identifier">rbrace</code> = <code class="identifier">parseState</code>.<code class="identifier">InputEndPosition</code> 1
      <code class="keyword">let</code> <code class="identifier">lbrace</code> = <code class="identifier">parseState</code>.<code class="identifier">InputStartPosition</code> 2
      <code class="identifier">reportParseErrorAt</code> (<code class="identifier">mkSynRange</code> <code class="identifier">rbrace</code> <code class="identifier">lbrace</code>) (<code class="identifier">FSComp</code>.<code class="identifier">SR</code>.<code class="identifier">parsEmptyFillInInterpolatedString</code>())
      <code class="identifier">SynInterpolatedStringPart</code>.<code class="identifier">String</code> (<code class="identifier">s</code>, <code class="identifier">rhs</code> <code class="identifier">parseState</code> 1) :: $2, <code class="identifier">synStringKind</code> }
  
<code class="identifier">opt_HIGH_PRECEDENCE_APP</code>:
  | <code class="identifier">HIGH_PRECEDENCE_BRACK_APP</code> { }
  | <code class="identifier">HIGH_PRECEDENCE_PAREN_APP</code> { }
  | <code class="comment">/* EMPTY */</code>   { }

<code class="identifier">opt_HIGH_PRECEDENCE_TYAPP</code>:
  | <code class="identifier">HIGH_PRECEDENCE_TYAPP</code> { }
  | <code class="comment">/* EMPTY */</code>   { }

<code class="comment">/* A 'type' keyword */</code>
<code class="identifier">typeKeyword</code>:
  | <code class="identifier">TYPE_COMING_SOON</code> <code class="identifier">typeKeyword</code> { }
  | <code class="identifier">TYPE_IS_HERE</code> { }
  | <code class="identifier">TYPE</code> { }

<code class="comment">/* A 'module' keyword */</code>
<code class="identifier">moduleKeyword</code>:
  | <code class="identifier">MODULE_COMING_SOON</code> <code class="identifier">moduleKeyword</code> { }
  | <code class="identifier">MODULE_IS_HERE</code> { }
  | <code class="identifier">MODULE</code> { }

<code class="identifier">rbrace</code>:
  | <code class="identifier">RBRACE_COMING_SOON</code> <code class="identifier">rbrace</code> { }
  | <code class="identifier">RBRACE_IS_HERE</code> { }
  | <code class="identifier">RBRACE</code> { }

<code class="identifier">bar_rbrace</code>:
  | <code class="identifier">BAR_RBRACE</code> { }

<code class="identifier">rparen</code>:
  | <code class="identifier">RPAREN_COMING_SOON</code> <code class="identifier">rparen</code> { }
  | <code class="identifier">RPAREN_IS_HERE</code> { }
  | <code class="identifier">RPAREN</code> { }

<code class="identifier">oblockend</code>:
  | <code class="identifier">OBLOCKEND_COMING_SOON</code> <code class="identifier">oblockend</code> { }
  | <code class="identifier">OBLOCKEND_IS_HERE</code> { }
  | <code class="identifier">OBLOCKEND</code> { }

<code class="identifier">ends_other_than_rparen_coming_soon_or_recover</code>:
  | <code class="identifier">TYPE_COMING_SOON</code> { <code class="keyword">false</code> }
  | <code class="identifier">MODULE_COMING_SOON</code> { <code class="keyword">false</code> }
  | <code class="identifier">RBRACE_COMING_SOON</code> { <code class="keyword">false</code> }
  | <code class="identifier">OBLOCKEND_COMING_SOON</code> { <code class="keyword">false</code> }
  | <code class="identifier">recover</code> { $1 }

<code class="identifier">ends_coming_soon_or_recover</code>:
  | <code class="identifier">TYPE_COMING_SOON</code> { <code class="keyword">false</code> }
  | <code class="identifier">MODULE_COMING_SOON</code> { <code class="keyword">false</code> }
  | <code class="identifier">RBRACE_COMING_SOON</code> { <code class="keyword">false</code> }
  | <code class="identifier">RPAREN_COMING_SOON</code> { <code class="keyword">false</code> }
  | <code class="identifier">OBLOCKEND_COMING_SOON</code> { <code class="keyword">false</code> }
  | <code class="identifier">recover</code> { $1 }
</pre>
</body></html>